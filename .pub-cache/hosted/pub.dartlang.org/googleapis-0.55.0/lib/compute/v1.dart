// This is a generated file (see the discoveryapis_generator project).

// ignore_for_file: unused_import, unnecessary_cast

library googleapis.compute.v1;

import 'dart:core' as core;
import 'dart:async' as async;
import 'dart:convert' as convert;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show ApiRequestError, DetailedApiRequestError;

const core.String USER_AGENT = 'dart-api-client compute/v1';

/// Creates and runs virtual machines on Google Cloud Platform.
class ComputeApi {
  /// View and manage your data across Google Cloud Platform services
  static const CloudPlatformScope =
      "https://www.googleapis.com/auth/cloud-platform";

  /// View and manage your Google Compute Engine resources
  static const ComputeScope = "https://www.googleapis.com/auth/compute";

  /// View your Google Compute Engine resources
  static const ComputeReadonlyScope =
      "https://www.googleapis.com/auth/compute.readonly";

  /// Manage your data and permissions in Google Cloud Storage
  static const DevstorageFullControlScope =
      "https://www.googleapis.com/auth/devstorage.full_control";

  /// View your data in Google Cloud Storage
  static const DevstorageReadOnlyScope =
      "https://www.googleapis.com/auth/devstorage.read_only";

  /// Manage your data in Google Cloud Storage
  static const DevstorageReadWriteScope =
      "https://www.googleapis.com/auth/devstorage.read_write";

  final commons.ApiRequester _requester;

  AcceleratorTypesResourceApi get acceleratorTypes =>
      new AcceleratorTypesResourceApi(_requester);
  AddressesResourceApi get addresses => new AddressesResourceApi(_requester);
  AutoscalersResourceApi get autoscalers =>
      new AutoscalersResourceApi(_requester);
  BackendBucketsResourceApi get backendBuckets =>
      new BackendBucketsResourceApi(_requester);
  BackendServicesResourceApi get backendServices =>
      new BackendServicesResourceApi(_requester);
  DiskTypesResourceApi get diskTypes => new DiskTypesResourceApi(_requester);
  DisksResourceApi get disks => new DisksResourceApi(_requester);
  ExternalVpnGatewaysResourceApi get externalVpnGateways =>
      new ExternalVpnGatewaysResourceApi(_requester);
  FirewallsResourceApi get firewalls => new FirewallsResourceApi(_requester);
  ForwardingRulesResourceApi get forwardingRules =>
      new ForwardingRulesResourceApi(_requester);
  GlobalAddressesResourceApi get globalAddresses =>
      new GlobalAddressesResourceApi(_requester);
  GlobalForwardingRulesResourceApi get globalForwardingRules =>
      new GlobalForwardingRulesResourceApi(_requester);
  GlobalNetworkEndpointGroupsResourceApi get globalNetworkEndpointGroups =>
      new GlobalNetworkEndpointGroupsResourceApi(_requester);
  GlobalOperationsResourceApi get globalOperations =>
      new GlobalOperationsResourceApi(_requester);
  HealthChecksResourceApi get healthChecks =>
      new HealthChecksResourceApi(_requester);
  HttpHealthChecksResourceApi get httpHealthChecks =>
      new HttpHealthChecksResourceApi(_requester);
  HttpsHealthChecksResourceApi get httpsHealthChecks =>
      new HttpsHealthChecksResourceApi(_requester);
  ImagesResourceApi get images => new ImagesResourceApi(_requester);
  InstanceGroupManagersResourceApi get instanceGroupManagers =>
      new InstanceGroupManagersResourceApi(_requester);
  InstanceGroupsResourceApi get instanceGroups =>
      new InstanceGroupsResourceApi(_requester);
  InstanceTemplatesResourceApi get instanceTemplates =>
      new InstanceTemplatesResourceApi(_requester);
  InstancesResourceApi get instances => new InstancesResourceApi(_requester);
  InterconnectAttachmentsResourceApi get interconnectAttachments =>
      new InterconnectAttachmentsResourceApi(_requester);
  InterconnectLocationsResourceApi get interconnectLocations =>
      new InterconnectLocationsResourceApi(_requester);
  InterconnectsResourceApi get interconnects =>
      new InterconnectsResourceApi(_requester);
  LicenseCodesResourceApi get licenseCodes =>
      new LicenseCodesResourceApi(_requester);
  LicensesResourceApi get licenses => new LicensesResourceApi(_requester);
  MachineTypesResourceApi get machineTypes =>
      new MachineTypesResourceApi(_requester);
  NetworkEndpointGroupsResourceApi get networkEndpointGroups =>
      new NetworkEndpointGroupsResourceApi(_requester);
  NetworksResourceApi get networks => new NetworksResourceApi(_requester);
  NodeGroupsResourceApi get nodeGroups => new NodeGroupsResourceApi(_requester);
  NodeTemplatesResourceApi get nodeTemplates =>
      new NodeTemplatesResourceApi(_requester);
  NodeTypesResourceApi get nodeTypes => new NodeTypesResourceApi(_requester);
  PacketMirroringsResourceApi get packetMirrorings =>
      new PacketMirroringsResourceApi(_requester);
  ProjectsResourceApi get projects => new ProjectsResourceApi(_requester);
  RegionAutoscalersResourceApi get regionAutoscalers =>
      new RegionAutoscalersResourceApi(_requester);
  RegionBackendServicesResourceApi get regionBackendServices =>
      new RegionBackendServicesResourceApi(_requester);
  RegionCommitmentsResourceApi get regionCommitments =>
      new RegionCommitmentsResourceApi(_requester);
  RegionDiskTypesResourceApi get regionDiskTypes =>
      new RegionDiskTypesResourceApi(_requester);
  RegionDisksResourceApi get regionDisks =>
      new RegionDisksResourceApi(_requester);
  RegionHealthChecksResourceApi get regionHealthChecks =>
      new RegionHealthChecksResourceApi(_requester);
  RegionInstanceGroupManagersResourceApi get regionInstanceGroupManagers =>
      new RegionInstanceGroupManagersResourceApi(_requester);
  RegionInstanceGroupsResourceApi get regionInstanceGroups =>
      new RegionInstanceGroupsResourceApi(_requester);
  RegionOperationsResourceApi get regionOperations =>
      new RegionOperationsResourceApi(_requester);
  RegionSslCertificatesResourceApi get regionSslCertificates =>
      new RegionSslCertificatesResourceApi(_requester);
  RegionTargetHttpProxiesResourceApi get regionTargetHttpProxies =>
      new RegionTargetHttpProxiesResourceApi(_requester);
  RegionTargetHttpsProxiesResourceApi get regionTargetHttpsProxies =>
      new RegionTargetHttpsProxiesResourceApi(_requester);
  RegionUrlMapsResourceApi get regionUrlMaps =>
      new RegionUrlMapsResourceApi(_requester);
  RegionsResourceApi get regions => new RegionsResourceApi(_requester);
  ReservationsResourceApi get reservations =>
      new ReservationsResourceApi(_requester);
  ResourcePoliciesResourceApi get resourcePolicies =>
      new ResourcePoliciesResourceApi(_requester);
  RoutersResourceApi get routers => new RoutersResourceApi(_requester);
  RoutesResourceApi get routes => new RoutesResourceApi(_requester);
  SecurityPoliciesResourceApi get securityPolicies =>
      new SecurityPoliciesResourceApi(_requester);
  SnapshotsResourceApi get snapshots => new SnapshotsResourceApi(_requester);
  SslCertificatesResourceApi get sslCertificates =>
      new SslCertificatesResourceApi(_requester);
  SslPoliciesResourceApi get sslPolicies =>
      new SslPoliciesResourceApi(_requester);
  SubnetworksResourceApi get subnetworks =>
      new SubnetworksResourceApi(_requester);
  TargetHttpProxiesResourceApi get targetHttpProxies =>
      new TargetHttpProxiesResourceApi(_requester);
  TargetHttpsProxiesResourceApi get targetHttpsProxies =>
      new TargetHttpsProxiesResourceApi(_requester);
  TargetInstancesResourceApi get targetInstances =>
      new TargetInstancesResourceApi(_requester);
  TargetPoolsResourceApi get targetPools =>
      new TargetPoolsResourceApi(_requester);
  TargetSslProxiesResourceApi get targetSslProxies =>
      new TargetSslProxiesResourceApi(_requester);
  TargetTcpProxiesResourceApi get targetTcpProxies =>
      new TargetTcpProxiesResourceApi(_requester);
  TargetVpnGatewaysResourceApi get targetVpnGateways =>
      new TargetVpnGatewaysResourceApi(_requester);
  UrlMapsResourceApi get urlMaps => new UrlMapsResourceApi(_requester);
  VpnGatewaysResourceApi get vpnGateways =>
      new VpnGatewaysResourceApi(_requester);
  VpnTunnelsResourceApi get vpnTunnels => new VpnTunnelsResourceApi(_requester);
  ZoneOperationsResourceApi get zoneOperations =>
      new ZoneOperationsResourceApi(_requester);
  ZonesResourceApi get zones => new ZonesResourceApi(_requester);

  ComputeApi(http.Client client,
      {core.String rootUrl = "https://compute.googleapis.com/",
      core.String servicePath = "compute/v1/projects/"})
      : _requester =
            new commons.ApiRequester(client, rootUrl, servicePath, USER_AGENT);
}

class AcceleratorTypesResourceApi {
  final commons.ApiRequester _requester;

  AcceleratorTypesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of accelerator types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/acceleratorTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new AcceleratorTypeAggregatedList.fromJson(data));
  }

  /// Returns the specified accelerator type.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [acceleratorType] - Name of the accelerator type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorType> get(
      core.String project, core.String zone, core.String acceleratorType,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (acceleratorType == null) {
      throw new core.ArgumentError("Parameter acceleratorType is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/acceleratorTypes/' +
        commons.Escaper.ecapeVariable('$acceleratorType');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AcceleratorType.fromJson(data));
  }

  /// Retrieves a list of accelerator types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/acceleratorTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AcceleratorTypeList.fromJson(data));
  }
}

class AddressesResourceApi {
  final commons.ApiRequester _requester;

  AddressesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/addresses';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AddressAggregatedList.fromJson(data));
  }

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String address,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (address == null) {
      throw new core.ArgumentError("Parameter address is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(
      core.String project, core.String region, core.String address,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (address == null) {
      throw new core.ArgumentError("Parameter address is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Address.fromJson(data));
  }

  /// Creates an address resource in the specified project by using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Address request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of addresses contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AddressList.fromJson(data));
  }
}

class AutoscalersResourceApi {
  final commons.ApiRequester _requester;

  AutoscalersResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of autoscalers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/autoscalers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new AutoscalerAggregatedList.fromJson(data));
  }

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String autoscaler,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (autoscaler == null) {
      throw new core.ArgumentError("Parameter autoscaler is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified autoscaler resource. Gets a list of available
  /// autoscalers by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
      core.String project, core.String zone, core.String autoscaler,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (autoscaler == null) {
      throw new core.ArgumentError("Parameter autoscaler is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Autoscaler.fromJson(data));
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Autoscaler request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of autoscalers contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AutoscalerList.fromJson(data));
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Autoscaler request, core.String project, core.String zone,
      {core.String autoscaler, core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (autoscaler != null) {
      _queryParams["autoscaler"] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      Autoscaler request, core.String project, core.String zone,
      {core.String autoscaler, core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (autoscaler != null) {
      _queryParams["autoscaler"] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class BackendBucketsResourceApi {
  final commons.ApiRequester _requester;

  BackendBucketsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a key for validating requests with signed URLs for this backend
  /// bucket.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addSignedUrlKey(
      SignedUrlKey request, core.String project, core.String backendBucket,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket') +
        '/addSignedUrlKey';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified BackendBucket resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String backendBucket,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes a key for validating requests with signed URLs for this backend
  /// bucket.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [keyName] - The name of the Signed URL Key to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteSignedUrlKey(
      core.String project, core.String backendBucket, core.String keyName,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if (keyName == null) {
      throw new core.ArgumentError("Parameter keyName is required.");
    }
    _queryParams["keyName"] = [keyName];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket') +
        '/deleteSignedUrlKey';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified BackendBucket resource. Gets a list of available
  /// backend buckets by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucket].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucket> get(
      core.String project, core.String backendBucket,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendBucket.fromJson(data));
  }

  /// Creates a BackendBucket resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(BackendBucket request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/backendBuckets';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of BackendBucket resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucketList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucketList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/backendBuckets';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendBucketList.fromJson(data));
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      BackendBucket request, core.String project, core.String backendBucket,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      BackendBucket request, core.String project, core.String backendBucket,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendBucket == null) {
      throw new core.ArgumentError("Parameter backendBucket is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class BackendServicesResourceApi {
  final commons.ApiRequester _requester;

  BackendServicesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a key for validating requests with signed URLs for this backend
  /// service.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addSignedUrlKey(
      SignedUrlKey request, core.String project, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/addSignedUrlKey';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of all BackendService resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/backendServices';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new BackendServiceAggregatedList.fromJson(data));
  }

  /// Deletes the specified BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes a key for validating requests with signed URLs for this backend
  /// service.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [keyName] - The name of the Signed URL Key to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteSignedUrlKey(
      core.String project, core.String backendService, core.String keyName,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (keyName == null) {
      throw new core.ArgumentError("Parameter keyName is required.");
    }
    _queryParams["keyName"] = [keyName];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/deleteSignedUrlKey';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified BackendService resource. Gets a list of available
  /// backend services.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
      core.String project, core.String backendService,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendService.fromJson(data));
  }

  /// Gets the most recent health check results for this BackendService.
  ///
  /// Example request body:
  ///
  /// { "group": "/zones/us-east1-b/instanceGroups/lb-backend-example" }
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// queried instance belongs.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
      ResourceGroupReference request,
      core.String project,
      core.String backendService,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/getHealth';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new BackendServiceGroupHealth.fromJson(data));
  }

  /// Creates a BackendService resource in the specified project using the data
  /// included in the request. There are several restrictions and guidelines to
  /// keep in mind when creating a backend service. Read  Understanding backend
  /// services for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(BackendService request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/backendServices';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of BackendService resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/backendServices';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendServiceList.fromJson(data));
  }

  /// Patches the specified BackendService resource with the data included in
  /// the request. There are several Understanding backend services to keep in
  /// mind when updating a backend service. Read  Understanding backend services
  /// for more information. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      BackendService request, core.String project, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the security policy for the specified backend service.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// security policy should be set. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSecurityPolicy(SecurityPolicyReference request,
      core.String project, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/setSecurityPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified BackendService resource with the data included in
  /// the request. There are several Understanding backend services to keep in
  /// mind when updating a backend service. Read  Understanding backend services
  /// for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      BackendService request, core.String project, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class DiskTypesResourceApi {
  final commons.ApiRequester _requester;

  DiskTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of disk types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/diskTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskTypeAggregatedList.fromJson(data));
  }

  /// Returns the specified disk type. Gets a list of available disk types by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
      core.String project, core.String zone, core.String diskType,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (diskType == null) {
      throw new core.ArgumentError("Parameter diskType is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/diskTypes/' +
        commons.Escaper.ecapeVariable('$diskType');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskType.fromJson(data));
  }

  /// Retrieves a list of disk types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/diskTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskTypeList.fromJson(data));
  }
}

class DisksResourceApi {
  final commons.ApiRequester _requester;

  DisksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds existing resource policies to a disk. You can only add one policy
  /// which will be applied to this disk for scheduling snapshot creation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
      DisksAddResourcePoliciesRequest request,
      core.String project,
      core.String zone,
      core.String disk,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/addResourcePolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves an aggregated list of persistent disks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/disks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskAggregatedList.fromJson(data));
  }

  /// Creates a snapshot of a specified persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to snapshot.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [guestFlush] - [Input Only] Specifies to create an application consistent
  /// snapshot by informing the OS to prepare for the snapshot process.
  /// Currently only supported on Windows instances using the Volume Shadow Copy
  /// Service (VSS).
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(
      Snapshot request, core.String project, core.String zone, core.String disk,
      {core.bool guestFlush, core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (guestFlush != null) {
      _queryParams["guestFlush"] = ["${guestFlush}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/createSnapshot';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified persistent disk. Deleting a disk removes its data
  /// permanently and is irreversible. However, deleting a disk does not delete
  /// any snapshots previously made from the disk. You must separately delete
  /// snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String disk,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns a specified persistent disk. Gets a list of available persistent
  /// disks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
      core.String project, core.String zone, core.String disk,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Disk.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
      core.String project, core.String zone, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Creates a persistent disk in the specified project using the data in the
  /// request. You can create a disk with a sourceImage, a sourceSnapshot, or
  /// create an empty 500 GB data disk by omitting all properties. You can also
  /// create a disk that is larger than the default size by specifying the
  /// sizeGb property.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Optional. Source image to restore onto a disk.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Disk request, core.String project, core.String zone,
      {core.String requestId, core.String sourceImage, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if (sourceImage != null) {
      _queryParams["sourceImage"] = [sourceImage];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of persistent disks contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskList.fromJson(data));
  }

  /// Removes resource policies from a disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
      DisksRemoveResourcePoliciesRequest request,
      core.String project,
      core.String zone,
      core.String disk,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/removeResourcePolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Resizes the specified persistent disk. You can only increase the size of
  /// the disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The name of the persistent disk.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(DisksResizeRequest request,
      core.String project, core.String zone, core.String disk,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/resize';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(ZoneSetPolicyRequest request,
      core.String project, core.String zone, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Sets the labels on a disk. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(ZoneSetLabelsRequest request,
      core.String project, core.String zone, core.String resource,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String zone,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class ExternalVpnGatewaysResourceApi {
  final commons.ApiRequester _requester;

  ExternalVpnGatewaysResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified externalVpnGateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [externalVpnGateway] - Name of the externalVpnGateways to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String externalVpnGateway,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (externalVpnGateway == null) {
      throw new core.ArgumentError("Parameter externalVpnGateway is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.Escaper.ecapeVariable('$externalVpnGateway');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified externalVpnGateway. Get a list of available
  /// externalVpnGateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [externalVpnGateway] - Name of the externalVpnGateway to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExternalVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExternalVpnGateway> get(
      core.String project, core.String externalVpnGateway,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (externalVpnGateway == null) {
      throw new core.ArgumentError("Parameter externalVpnGateway is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.Escaper.ecapeVariable('$externalVpnGateway');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ExternalVpnGateway.fromJson(data));
  }

  /// Creates a ExternalVpnGateway in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      ExternalVpnGateway request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of ExternalVpnGateway available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExternalVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExternalVpnGatewayList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ExternalVpnGatewayList.fromJson(data));
  }

  /// Sets the labels on an ExternalVpnGateway. To learn more about labels, read
  /// the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
      GlobalSetLabelsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class FirewallsResourceApi {
  final commons.ApiRequester _requester;

  FirewallsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String firewall,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (firewall == null) {
      throw new core.ArgumentError("Parameter firewall is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Firewall].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Firewall> get(core.String project, core.String firewall,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (firewall == null) {
      throw new core.ArgumentError("Parameter firewall is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Firewall.fromJson(data));
  }

  /// Creates a firewall rule in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Firewall request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/firewalls';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of firewall rules available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/firewalls';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new FirewallList.fromJson(data));
  }

  /// Updates the specified firewall rule with the data included in the request.
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Firewall request, core.String project, core.String firewall,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (firewall == null) {
      throw new core.ArgumentError("Parameter firewall is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified firewall rule with the data included in the request.
  /// Note that all fields will be updated if using PUT, even fields that are
  /// not specified. To update individual fields, please use PATCH instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      Firewall request, core.String project, core.String firewall,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (firewall == null) {
      throw new core.ArgumentError("Parameter firewall is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class ForwardingRulesResourceApi {
  final commons.ApiRequester _requester;

  ForwardingRulesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of forwarding rules.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/forwardingRules';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new ForwardingRuleAggregatedList.fromJson(data));
  }

  /// Deletes the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
      core.String project, core.String region, core.String forwardingRule,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ForwardingRule.fromJson(data));
  }

  /// Creates a ForwardingRule resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      ForwardingRule request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of ForwardingRule resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ForwardingRuleList.fromJson(data));
  }

  /// Updates the specified forwarding rule with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules. Currently, you can only patch the
  /// network_tier field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(ForwardingRule request, core.String project,
      core.String region, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes target URL for forwarding rule. The new target should be of the
  /// same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(TargetReference request,
      core.String project, core.String region, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule') +
        '/setTarget';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class GlobalAddressesResourceApi {
  final commons.ApiRequester _requester;

  GlobalAddressesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String address,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (address == null) {
      throw new core.ArgumentError("Parameter address is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified address resource. Gets a list of available addresses
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(core.String project, core.String address,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (address == null) {
      throw new core.ArgumentError("Parameter address is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Address.fromJson(data));
  }

  /// Creates an address resource in the specified project by using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Address request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/addresses';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of global addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/addresses';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new AddressList.fromJson(data));
  }
}

class GlobalForwardingRulesResourceApi {
  final commons.ApiRequester _requester;

  GlobalForwardingRulesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified GlobalForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified GlobalForwardingRule resource. Gets a list of
  /// available forwarding rules by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
      core.String project, core.String forwardingRule,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ForwardingRule.fromJson(data));
  }

  /// Creates a GlobalForwardingRule resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(ForwardingRule request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/forwardingRules';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of GlobalForwardingRule resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/forwardingRules';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ForwardingRuleList.fromJson(data));
  }

  /// Updates the specified forwarding rule with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules. Currently, you can only patch the
  /// network_tier field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      ForwardingRule request, core.String project, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes target URL for the GlobalForwardingRule resource. The new target
  /// should be of the same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(
      TargetReference request, core.String project, core.String forwardingRule,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forwardingRule == null) {
      throw new core.ArgumentError("Parameter forwardingRule is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule') +
        '/setTarget';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class GlobalNetworkEndpointGroupsResourceApi {
  final commons.ApiRequester _requester;

  GlobalNetworkEndpointGroupsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Attach a network endpoint to the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are attaching network endpoints to. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachNetworkEndpoints(
      GlobalNetworkEndpointGroupsAttachEndpointsRequest request,
      core.String project,
      core.String networkEndpointGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/attachNetworkEndpoints';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified network endpoint group.Note that the NEG cannot be
  /// deleted if there are backend services referencing it.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String networkEndpointGroup,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Detach the network endpoint from the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are removing network endpoints. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachNetworkEndpoints(
      GlobalNetworkEndpointGroupsDetachEndpointsRequest request,
      core.String project,
      core.String networkEndpointGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/detachNetworkEndpoints';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified network endpoint group. Gets a list of available
  /// network endpoint groups by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
      core.String project, core.String networkEndpointGroup,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NetworkEndpointGroup.fromJson(data));
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      NetworkEndpointGroup request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of network endpoint groups that are located in the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new NetworkEndpointGroupList.fromJson(data));
  }

  /// Lists the network endpoints in the specified network endpoint group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group from which
  /// you want to generate a list of included network endpoints. It should
  /// comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupsListNetworkEndpoints].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupsListNetworkEndpoints> listNetworkEndpoints(
      core.String project, core.String networkEndpointGroup,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/listNetworkEndpoints';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then(
        (data) => new NetworkEndpointGroupsListNetworkEndpoints.fromJson(data));
  }
}

class GlobalOperationsResourceApi {
  final commons.ApiRequester _requester;

  GlobalOperationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of all operations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/operations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new OperationAggregatedList.fromJson(data));
  }

  /// Deletes the specified Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(core.String project, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => null);
  }

  /// Retrieves the specified Operations resource. Gets a list of operations by
  /// making a `list()` request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(core.String project, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/operations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new OperationList.fromJson(data));
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource. This method differs from the `GET` method in that it
  /// waits for no more than the default deadline (2 minutes) and then returns
  /// the current state of the operation, which might be `DONE` or still in
  /// progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(core.String project, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/operations/' +
        commons.Escaper.ecapeVariable('$operation') +
        '/wait';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class HealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HealthChecksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all HealthCheck resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthChecksAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthChecksAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/healthChecks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new HealthChecksAggregatedList.fromJson(data));
  }

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified HealthCheck resource. Gets a list of available
  /// health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(core.String project, core.String healthCheck,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HealthCheck.fromJson(data));
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(HealthCheck request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/healthChecks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/healthChecks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HealthCheckList.fromJson(data));
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      HealthCheck request, core.String project, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      HealthCheck request, core.String project, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class HttpHealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HttpHealthChecksResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified HttpHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String httpHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified HttpHealthCheck resource. Gets a list of available
  /// HTTP health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheck> get(
      core.String project, core.String httpHealthCheck,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpHealthCheck is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HttpHealthCheck.fromJson(data));
  }

  /// Creates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(HttpHealthCheck request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpHealthChecks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of HttpHealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheckList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpHealthChecks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HttpHealthCheckList.fromJson(data));
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      HttpHealthCheck request, core.String project, core.String httpHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      HttpHealthCheck request, core.String project, core.String httpHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class HttpsHealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HttpsHealthChecksResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified HttpsHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String httpsHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpsHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpsHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified HttpsHealthCheck resource. Gets a list of available
  /// HTTPS health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheck> get(
      core.String project, core.String httpsHealthCheck,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpsHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpsHealthCheck is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HttpsHealthCheck.fromJson(data));
  }

  /// Creates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(HttpsHealthCheck request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpsHealthChecks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of HttpsHealthCheck resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheckList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpsHealthChecks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HttpsHealthCheckList.fromJson(data));
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request. This method supports PATCH semantics and
  /// uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(HttpsHealthCheck request, core.String project,
      core.String httpsHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpsHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpsHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(HttpsHealthCheck request, core.String project,
      core.String httpsHealthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (httpsHealthCheck == null) {
      throw new core.ArgumentError("Parameter httpsHealthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class ImagesResourceApi {
  final commons.ApiRequester _requester;

  ImagesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified image.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Name of the image resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String image,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (image == null) {
      throw new core.ArgumentError("Parameter image is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the deprecation status of an image.
  ///
  /// If an empty request body is given, clears the deprecation status instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Image name.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deprecate(
      DeprecationStatus request, core.String project, core.String image,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (image == null) {
      throw new core.ArgumentError("Parameter image is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image') +
        '/deprecate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified image. Gets a list of available images by making a
  /// list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Name of the image resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> get(core.String project, core.String image,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (image == null) {
      throw new core.ArgumentError("Parameter image is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Image.fromJson(data));
  }

  /// Returns the latest image that is part of an image family and is not
  /// deprecated.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [family] - Name of the image family to search for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> getFromFamily(core.String project, core.String family,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (family == null) {
      throw new core.ArgumentError("Parameter family is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/family/' +
        commons.Escaper.ecapeVariable('$family');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Image.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Creates an image in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forceCreate] - Force image creation if true.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Image request, core.String project,
      {core.bool forceCreate, core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (forceCreate != null) {
      _queryParams["forceCreate"] = ["${forceCreate}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/images';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of custom images available to the specified project.
  /// Custom images are images you create that belong to your project. This
  /// method does not get any images that belong to other projects, including
  /// publicly-available images, like Debian 8. If you want to get a list of
  /// publicly-available images, use this method to make a request to the
  /// respective image project, such as debian-cloud or windows-cloud.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ImageList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ImageList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/images';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ImageList.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
      GlobalSetPolicyRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Sets the labels on an image. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
      GlobalSetLabelsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class InstanceGroupManagersResourceApi {
  final commons.ApiRequester _requester;

  InstanceGroupManagersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Flags the specified instances to be removed from the managed instance
  /// group. Abandoning an instance does not delete the instance, but it does
  /// remove the instance from any target pools that are applied by the managed
  /// instance group. This method reduces the targetSize of the managed instance
  /// group by the number of instances that you abandon. This operation is
  /// marked as DONE when the action is scheduled even if the instances have not
  /// yet been removed from the group. You must separately verify the status of
  /// the abandoning action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
      InstanceGroupManagersAbandonInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of managed instance groups and groups them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/instanceGroupManagers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InstanceGroupManagerAggregatedList.fromJson(data));
  }

  /// Applies changes to selected instances on the managed instance group. This
  /// method can be used to apply new overrides and/or new versions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// Should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group, should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> applyUpdatesToInstances(
      InstanceGroupManagersApplyUpdatesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/applyUpdatesToInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Creates instances with per-instance configs in this managed instance
  /// group. Instances are created using the current instance template. The
  /// create instances operation is marked DONE if the createInstances request
  /// is successful. The underlying actions take additional time. You must
  /// separately verify the status of the creating or actions with the
  /// listmanagedinstances method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createInstances(
      InstanceGroupManagersCreateInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/createInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group. Note that the instance group must not belong to a backend
  /// service. Read  Deleting an instance group for more information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String instanceGroupManager,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Flags the specified instances in the managed instance group for immediate
  /// deletion. The instances are also removed from any target pools of which
  /// they were a member. This method reduces the targetSize of the managed
  /// instance group by the number of instances that you delete. This operation
  /// is marked as DONE when the action is scheduled even if the instances are
  /// still being deleted. You must separately verify the status of the deleting
  /// action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
      InstanceGroupManagersDeleteInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns all of the details about the specified managed instance group.
  /// Gets a list of available managed instance groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
      core.String project, core.String zone, core.String instanceGroupManager,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroupManager.fromJson(data));
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request. After the group is created, instances in the group are
  /// created using the specified instance template. This operation is marked as
  /// DONE when the group is created even if the instances in the group have not
  /// yet been created. You must separately verify the status of the individual
  /// instances with the listmanagedinstances method.
  ///
  /// A managed instance group can have up to 1000 VM instances per group.
  /// Please contact Cloud Support if you need an increase in this limit.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      InstanceGroupManager request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of managed instance groups that are contained within the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerList> list(
      core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InstanceGroupManagerList.fromJson(data));
  }

  /// Lists all errors thrown by actions on instances for a given managed
  /// instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It must
  /// be a string that meets the requirements in RFC1035, or an unsigned long
  /// integer: must match regexp pattern:
  /// (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|[1-9][0-9]{0,19}.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListErrorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListErrorsResponse> listErrors(
      core.String project, core.String zone, core.String instanceGroupManager,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listErrors';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then(
        (data) => new InstanceGroupManagersListErrorsResponse.fromJson(data));
  }

  /// Lists all of the instances in the managed instance group. Each instance in
  /// the list has a currentAction, which indicates the action that the managed
  /// instance group is performing on the instance. For example, if the group is
  /// still creating an instance, the currentAction is CREATING. If a previous
  /// action failed, the list displays the errors for that failed action.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListManagedInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListManagedInstancesResponse>
      listManagedInstances(core.String project, core.String zone,
          core.String instanceGroupManager,
          {core.String filter,
          core.int maxResults,
          core.String orderBy,
          core.String pageToken,
          core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) =>
        new InstanceGroupManagersListManagedInstancesResponse.fromJson(data));
  }

  /// Updates a managed instance group using the information that you specify in
  /// the request. This operation is marked as DONE when the group is patched
  /// even if the instances in the group are still in the process of being
  /// patched. You must separately verify the status of the individual instances
  /// with the listManagedInstances method. This method supports PATCH semantics
  /// and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [instanceGroupManager] - The name of the instance group manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(InstanceGroupManager request,
      core.String project, core.String zone, core.String instanceGroupManager,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately recreated. The instances are deleted and recreated using the
  /// current instance template for the managed instance group. This operation
  /// is marked as DONE when the flag is set even if the instances have not yet
  /// been recreated. You must separately verify the status of the recreating
  /// action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
      InstanceGroupManagersRecreateInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Resizes the managed instance group. If you increase the size, the group
  /// creates new instances using the current instance template. If you decrease
  /// the size, the group deletes instances. The resize operation is marked DONE
  /// when the resize actions are scheduled even if the group has not yet added
  /// or deleted any instances. You must separately verify the status of the
  /// creating or deleting actions with the listmanagedinstances method.
  ///
  /// When resizing down, the instance group arbitrarily chooses the order in
  /// which VMs are deleted. The group takes into account some VM attributes
  /// when making the selection including:
  ///
  /// + The status of the VM instance. + The health of the VM instance. + The
  /// instance template version the VM is based on. + For regional managed
  /// instance groups, the location of the VM instance.
  ///
  /// This list is subject to change.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [size] - The number of running instances that the managed instance group
  /// should maintain at any given time. The group automatically adds or removes
  /// instances to maintain the number of instances specified by this parameter.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(core.String project, core.String zone,
      core.String instanceGroupManager, core.int size,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (size == null) {
      throw new core.ArgumentError("Parameter size is required.");
    }
    _queryParams["size"] = ["${size}"];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/resize';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Specifies the instance template to use when creating new instances in this
  /// group. The templates for existing instances in the group do not change
  /// unless you recreate them.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
      InstanceGroupManagersSetInstanceTemplateRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Modifies the target pools to which all instances in this managed instance
  /// group are assigned. The target pools automatically apply to all of the
  /// instances in the managed instance group. This operation is marked DONE
  /// when you make the request even if the instances have not yet been added to
  /// their target pools. The change might take some time to apply to all of the
  /// instances in the group depending on the size of the group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
      InstanceGroupManagersSetTargetPoolsRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class InstanceGroupsResourceApi {
  final commons.ApiRequester _requester;

  InstanceGroupsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a list of instances to the specified instance group. All of the
  /// instances in the instance group must be in the same network/subnetwork.
  /// Read  Adding instances for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where you are adding
  /// instances.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstances(
      InstanceGroupsAddInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/addInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of instance groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/instanceGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InstanceGroupAggregatedList.fromJson(data));
  }

  /// Deletes the specified instance group. The instances in the group are not
  /// deleted. Note that instance group must not belong to a backend service.
  /// Read  Deleting an instance group for more information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String instanceGroup,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified instance group. Gets a list of available instance
  /// groups by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
      core.String project, core.String zone, core.String instanceGroup,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroup.fromJson(data));
  }

  /// Creates an instance group in the specified project using the parameters
  /// that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      InstanceGroup request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of instance groups that are located in the specified
  /// project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroupList.fromJson(data));
  }

  /// Lists the instances in the specified instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group from which you want to
  /// generate a list of included instances.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupsListInstances> listInstances(
      InstanceGroupsListInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroup,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/listInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InstanceGroupsListInstances.fromJson(data));
  }

  /// Removes one or more instances from the specified instance group, but does
  /// not delete those instances.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration before the VM instance is removed or deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the specified
  /// instances will be removed.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstances(
      InstanceGroupsRemoveInstancesRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/removeInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the named ports for the specified instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the named ports are
  /// updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
      InstanceGroupsSetNamedPortsRequest request,
      core.String project,
      core.String zone,
      core.String instanceGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/setNamedPorts';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class InstanceTemplatesResourceApi {
  final commons.ApiRequester _requester;

  InstanceTemplatesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified instance template. Deleting an instance template is
  /// permanent and cannot be undone. It is not possible to delete templates
  /// that are already in use by a managed instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [instanceTemplate] - The name of the instance template to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String instanceTemplate,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (instanceTemplate == null) {
      throw new core.ArgumentError("Parameter instanceTemplate is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$instanceTemplate');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified instance template. Gets a list of available instance
  /// templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [instanceTemplate] - The name of the instance template.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplate> get(
      core.String project, core.String instanceTemplate,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (instanceTemplate == null) {
      throw new core.ArgumentError("Parameter instanceTemplate is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$instanceTemplate');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceTemplate.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Creates an instance template in the specified project using the data that
  /// is included in the request. If you are creating a new template to update
  /// an existing instance group, your new instance template must use the same
  /// network or, if applicable, the same subnetwork as the original template.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(InstanceTemplate request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/instanceTemplates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of instance templates that are contained within the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplateList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/instanceTemplates';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceTemplateList.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
      GlobalSetPolicyRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class InstancesResourceApi {
  final commons.ApiRequester _requester;

  InstancesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds an access config to an instance's network interface.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [networkInterface] - The name of the network interface to add to this
  /// instance.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addAccessConfig(
      AccessConfig request,
      core.String project,
      core.String zone,
      core.String instance,
      core.String networkInterface,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (networkInterface == null) {
      throw new core.ArgumentError("Parameter networkInterface is required.");
    }
    _queryParams["networkInterface"] = [networkInterface];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/addAccessConfig';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Adds existing resource policies to an instance. You can only add one
  /// policy right now which will be applied to this instance for scheduling
  /// live migrations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
      InstancesAddResourcePoliciesRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/addResourcePolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves aggregated list of all of the instances in your project across
  /// all regions and zones.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/instances';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceAggregatedList.fromJson(data));
  }

  /// Attaches an existing Disk resource to an instance. You must first create
  /// the disk before you can attach it. It is not possible to create and attach
  /// a disk at the same time. For more information, read Adding a persistent
  /// disk to your instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [forceAttach] - Whether to force attach the disk even if it's currently
  /// attached to another instance.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachDisk(AttachedDisk request, core.String project,
      core.String zone, core.String instance,
      {core.bool forceAttach, core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (forceAttach != null) {
      _queryParams["forceAttach"] = ["${forceAttach}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/attachDisk';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified Instance resource. For more information, see
  /// Stopping or Deleting an Instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes an access config from an instance's network interface.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [accessConfig] - The name of the access config to delete.
  ///
  /// [networkInterface] - The name of the network interface.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteAccessConfig(
      core.String project,
      core.String zone,
      core.String instance,
      core.String accessConfig,
      core.String networkInterface,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (accessConfig == null) {
      throw new core.ArgumentError("Parameter accessConfig is required.");
    }
    _queryParams["accessConfig"] = [accessConfig];
    if (networkInterface == null) {
      throw new core.ArgumentError("Parameter networkInterface is required.");
    }
    _queryParams["networkInterface"] = [networkInterface];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/deleteAccessConfig';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Detaches a disk from an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [deviceName] - The device name of the disk to detach. Make a get() request
  /// on the instance to view currently attached disks and device names.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachDisk(core.String project, core.String zone,
      core.String instance, core.String deviceName,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (deviceName == null) {
      throw new core.ArgumentError("Parameter deviceName is required.");
    }
    _queryParams["deviceName"] = [deviceName];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/detachDisk';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Instance resource. Gets a list of available
  /// instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Instance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Instance> get(
      core.String project, core.String zone, core.String instance,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Instance.fromJson(data));
  }

  /// Returns the specified guest attributes entry.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [queryPath] - Specifies the guest attributes path to be queried.
  ///
  /// [variableKey] - Specifies the key for the guest attributes entry.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GuestAttributes].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GuestAttributes> getGuestAttributes(
      core.String project, core.String zone, core.String instance,
      {core.String queryPath, core.String variableKey, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (queryPath != null) {
      _queryParams["queryPath"] = [queryPath];
    }
    if (variableKey != null) {
      _queryParams["variableKey"] = [variableKey];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/getGuestAttributes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new GuestAttributes.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
      core.String project, core.String zone, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Returns the last 1 MB of serial port output from the specified instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [port] - Specifies which COM or serial port to retrieve data from.
  /// Value must be between "1" and "4".
  ///
  /// [start_1] - Returns output starting from a specific byte position. Use
  /// this to page through output when the output is too large to return in a
  /// single request. For the initial request, leave this field unspecified. For
  /// subsequent calls, this field should be set to the next value returned in
  /// the previous call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SerialPortOutput].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SerialPortOutput> getSerialPortOutput(
      core.String project, core.String zone, core.String instance,
      {core.int port, core.String start_1, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (port != null) {
      _queryParams["port"] = ["${port}"];
    }
    if (start_1 != null) {
      _queryParams["start"] = [start_1];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/serialPort';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SerialPortOutput.fromJson(data));
  }

  /// Returns the Shielded Instance Identity of an instance
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ShieldedInstanceIdentity].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ShieldedInstanceIdentity> getShieldedInstanceIdentity(
      core.String project, core.String zone, core.String instance,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/getShieldedInstanceIdentity';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new ShieldedInstanceIdentity.fromJson(data));
  }

  /// Creates an instance resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceInstanceTemplate] - Specifies instance template to create the
  /// instance.
  ///
  /// This field is optional. It can be a full or partial URL. For example, the
  /// following are all valid URLs to an instance template:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/instanceTemplates/instanceTemplate
  /// - projects/project/global/instanceTemplates/instanceTemplate
  /// - global/instanceTemplates/instanceTemplate
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Instance request, core.String project, core.String zone,
      {core.String requestId,
      core.String sourceInstanceTemplate,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if (sourceInstanceTemplate != null) {
      _queryParams["sourceInstanceTemplate"] = [sourceInstanceTemplate];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of instances contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceList.fromJson(data));
  }

  /// Retrieves the list of referrers to instances contained within the
  /// specified zone. For more information, read Viewing Referrers to VM
  /// Instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the target instance scoping this request, or '-' if
  /// the request should span over all instances in the container.
  /// Value must have pattern
  /// "-|[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceListReferrers].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceListReferrers> listReferrers(
      core.String project, core.String zone, core.String instance,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/referrers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceListReferrers.fromJson(data));
  }

  /// Removes resource policies from an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
      InstancesRemoveResourcePoliciesRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/removeResourcePolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Performs a reset on the instance. This is a hard reset the VM does not do
  /// a graceful shutdown. For more information, see Resetting an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> reset(
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/reset';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets deletion protection on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [deletionProtection] - Whether the resource should be protected against
  /// deletion.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDeletionProtection(
      core.String project, core.String zone, core.String resource,
      {core.bool deletionProtection,
      core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if (deletionProtection != null) {
      _queryParams["deletionProtection"] = ["${deletionProtection}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setDeletionProtection';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the auto-delete flag for a disk attached to an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [autoDelete] - Whether to auto-delete the disk when the instance is
  /// deleted.
  ///
  /// [deviceName] - The device name of the disk to modify. Make a get() request
  /// on the instance to view currently attached disks and device names.
  /// Value must have pattern "\w[\w.-]{0,254}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDiskAutoDelete(
      core.String project,
      core.String zone,
      core.String instance,
      core.bool autoDelete,
      core.String deviceName,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (autoDelete == null) {
      throw new core.ArgumentError("Parameter autoDelete is required.");
    }
    _queryParams["autoDelete"] = ["${autoDelete}"];
    if (deviceName == null) {
      throw new core.ArgumentError("Parameter deviceName is required.");
    }
    _queryParams["deviceName"] = [deviceName];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setDiskAutoDelete';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(ZoneSetPolicyRequest request,
      core.String project, core.String zone, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Sets labels on an instance. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(InstancesSetLabelsRequest request,
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the number and/or type of accelerator for a stopped instance to
  /// the values specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineResources(
      InstancesSetMachineResourcesRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMachineResources';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the machine type for a stopped instance to the machine type
  /// specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineType(InstancesSetMachineTypeRequest request,
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMachineType';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets metadata for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMetadata(Metadata request, core.String project,
      core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMetadata';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the minimum CPU platform that this instance should use. This
  /// method can only be called on a stopped instance. For more information,
  /// read Specifying a Minimum CPU Platform.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMinCpuPlatform(
      InstancesSetMinCpuPlatformRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMinCpuPlatform';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets an instance's scheduling options.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setScheduling(Scheduling request, core.String project,
      core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setScheduling';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the service account on the instance. For more information, read
  /// Changing the service account and access scopes for an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setServiceAccount(
      InstancesSetServiceAccountRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setServiceAccount';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the Shielded Instance integrity policy for an instance. You can only
  /// use this method on a running instance. This method supports PATCH
  /// semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setShieldedInstanceIntegrityPolicy(
      ShieldedInstanceIntegrityPolicy request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setShieldedInstanceIntegrityPolicy';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets network tags for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTags(
      Tags request, core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setTags';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Simulates a maintenance event on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> simulateMaintenanceEvent(
      core.String project, core.String zone, core.String instance,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/simulateMaintenanceEvent';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Starts an instance that was stopped using the instances().stop method. For
  /// more information, see Restart an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> start(
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/start';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Starts an instance that was stopped using the instances().stop method. For
  /// more information, see Restart an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> startWithEncryptionKey(
      InstancesStartWithEncryptionKeyRequest request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/startWithEncryptionKey';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Stops a running instance, shutting it down cleanly, and allows you to
  /// restart the instance at a later time. Stopped instances do not incur VM
  /// usage charges while they are stopped. However, resources that the VM is
  /// using, such as persistent disks and static IP addresses, will continue to
  /// be charged until they are deleted. For more information, see Stopping an
  /// instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to stop.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> stop(
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/stop';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String zone,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }

  /// Updates an instance only if the necessary resources are available. This
  /// method can update only a specific set of instance properties. See
  /// Updating a running instance for a list of updatable instance properties.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [minimalAction] - Specifies the action to take when updating an instance
  /// even if the updated properties do not require it. If not specified, then
  /// Compute Engine acts based on the minimum action that the updated
  /// properties require.
  /// Possible string values are:
  /// - "INVALID"
  /// - "NO_EFFECT"
  /// - "REFRESH"
  /// - "RESTART"
  ///
  /// [mostDisruptiveAllowedAction] - Specifies the most disruptive action that
  /// can be taken on the instance as part of the update. Compute Engine returns
  /// an error if the instance properties require a more disruptive action as
  /// part of the instance update. Valid options from lowest to highest are
  /// NO_EFFECT, REFRESH, and RESTART.
  /// Possible string values are:
  /// - "INVALID"
  /// - "NO_EFFECT"
  /// - "REFRESH"
  /// - "RESTART"
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(Instance request, core.String project,
      core.String zone, core.String instance,
      {core.String minimalAction,
      core.String mostDisruptiveAllowedAction,
      core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (minimalAction != null) {
      _queryParams["minimalAction"] = [minimalAction];
    }
    if (mostDisruptiveAllowedAction != null) {
      _queryParams["mostDisruptiveAllowedAction"] = [
        mostDisruptiveAllowedAction
      ];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified access config from an instance's network interface
  /// with the data included in the request. This method supports PATCH
  /// semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [networkInterface] - The name of the network interface where the access
  /// config is attached.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateAccessConfig(
      AccessConfig request,
      core.String project,
      core.String zone,
      core.String instance,
      core.String networkInterface,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (networkInterface == null) {
      throw new core.ArgumentError("Parameter networkInterface is required.");
    }
    _queryParams["networkInterface"] = [networkInterface];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateAccessConfig';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the Display config for a VM instance. You can only use this method
  /// on a stopped VM instance. This method supports PATCH semantics and uses
  /// the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateDisplayDevice(DisplayDevice request,
      core.String project, core.String zone, core.String instance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateDisplayDevice';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates an instance's network interface. This method follows PATCH
  /// semantics.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [networkInterface] - The name of the network interface to update.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateNetworkInterface(
      NetworkInterface request,
      core.String project,
      core.String zone,
      core.String instance,
      core.String networkInterface,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (networkInterface == null) {
      throw new core.ArgumentError("Parameter networkInterface is required.");
    }
    _queryParams["networkInterface"] = [networkInterface];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateNetworkInterface';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the Shielded Instance config for an instance. You can only use
  /// this method on a stopped instance. This method supports PATCH semantics
  /// and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateShieldedInstanceConfig(
      ShieldedInstanceConfig request,
      core.String project,
      core.String zone,
      core.String instance,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (instance == null) {
      throw new core.ArgumentError("Parameter instance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateShieldedInstanceConfig';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class InterconnectAttachmentsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectAttachmentsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of interconnect attachments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/interconnectAttachments';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then(
        (data) => new InterconnectAttachmentAggregatedList.fromJson(data));
  }

  /// Deletes the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String region,
      core.String interconnectAttachment,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (interconnectAttachment == null) {
      throw new core.ArgumentError(
          "Parameter interconnectAttachment is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.Escaper.ecapeVariable('$interconnectAttachment');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachment> get(core.String project,
      core.String region, core.String interconnectAttachment,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (interconnectAttachment == null) {
      throw new core.ArgumentError(
          "Parameter interconnectAttachment is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.Escaper.ecapeVariable('$interconnectAttachment');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InterconnectAttachment.fromJson(data));
  }

  /// Creates an InterconnectAttachment in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [validateOnly] - If true, the request will not be committed.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      InterconnectAttachment request, core.String project, core.String region,
      {core.String requestId, core.bool validateOnly, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if (validateOnly != null) {
      _queryParams["validateOnly"] = ["${validateOnly}"];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of interconnect attachments contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InterconnectAttachmentList.fromJson(data));
  }

  /// Updates the specified interconnect attachment with the data included in
  /// the request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      InterconnectAttachment request,
      core.String project,
      core.String region,
      core.String interconnectAttachment,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (interconnectAttachment == null) {
      throw new core.ArgumentError(
          "Parameter interconnectAttachment is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.Escaper.ecapeVariable('$interconnectAttachment');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class InterconnectLocationsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectLocationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Returns the details for the specified interconnect location. Gets a list
  /// of available interconnect locations by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnectLocation] - Name of the interconnect location to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocation> get(
      core.String project, core.String interconnectLocation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnectLocation == null) {
      throw new core.ArgumentError(
          "Parameter interconnectLocation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnectLocations/' +
        commons.Escaper.ecapeVariable('$interconnectLocation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InterconnectLocation.fromJson(data));
  }

  /// Retrieves the list of interconnect locations available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocationList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnectLocations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InterconnectLocationList.fromJson(data));
  }
}

class InterconnectsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String interconnect,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnect == null) {
      throw new core.ArgumentError("Parameter interconnect is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified interconnect. Get a list of available interconnects
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Interconnect].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Interconnect> get(core.String project, core.String interconnect,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnect == null) {
      throw new core.ArgumentError("Parameter interconnect is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Interconnect.fromJson(data));
  }

  /// Returns the interconnectDiagnostics for the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect resource to query.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectsGetDiagnosticsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectsGetDiagnosticsResponse> getDiagnostics(
      core.String project, core.String interconnect,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnect == null) {
      throw new core.ArgumentError("Parameter interconnect is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect') +
        '/getDiagnostics';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new InterconnectsGetDiagnosticsResponse.fromJson(data));
  }

  /// Creates a Interconnect in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Interconnect request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/interconnects';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of interconnect available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/interconnects';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InterconnectList.fromJson(data));
  }

  /// Updates the specified interconnect with the data included in the request.
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Interconnect request, core.String project, core.String interconnect,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (interconnect == null) {
      throw new core.ArgumentError("Parameter interconnect is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class LicenseCodesResourceApi {
  final commons.ApiRequester _requester;

  LicenseCodesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Return a specified license code. License codes are mirrored across all
  /// projects that have permissions to read the License Code.  Caution This
  /// resource is intended for use only by third-party partners who are creating
  /// Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [licenseCode] - Number corresponding to the License code resource to
  /// return.
  /// Value must have pattern "[0-9]{0,61}?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [LicenseCode].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<LicenseCode> get(core.String project, core.String licenseCode,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (licenseCode == null) {
      throw new core.ArgumentError("Parameter licenseCode is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenseCodes/' +
        commons.Escaper.ecapeVariable('$licenseCode');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new LicenseCode.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.  Caution
  /// This resource is intended for use only by third-party partners who are
  /// creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenseCodes/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class LicensesResourceApi {
  final commons.ApiRequester _requester;

  LicensesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified license.  Caution This resource is intended for use
  /// only by third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [license] - Name of the license resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String license,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (license == null) {
      throw new core.ArgumentError("Parameter license is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$license');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified License resource.  Caution This resource is intended
  /// for use only by third-party partners who are creating Cloud Marketplace
  /// images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [license] - Name of the License resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [License].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<License> get(core.String project, core.String license,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (license == null) {
      throw new core.ArgumentError("Parameter license is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$license');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new License.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.  Caution This resource is intended for use only
  /// by third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Create a License resource in the specified project.  Caution This resource
  /// is intended for use only by third-party partners who are creating Cloud
  /// Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(License request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/licenses';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of licenses available in the specified project. This
  /// method does not get any licenses that belong to other projects, including
  /// licenses attached to publicly-available images, like Debian 9. If you want
  /// to get a list of publicly-available licenses, use this method to make a
  /// request to the respective image project, such as debian-cloud or
  /// windows-cloud.  Caution This resource is intended for use only by
  /// third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [LicensesListResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<LicensesListResponse> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/licenses';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new LicensesListResponse.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.  Caution This resource is intended for use only by
  /// third-party partners who are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
      GlobalSetPolicyRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.  Caution
  /// This resource is intended for use only by third-party partners who are
  /// creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class MachineTypesResourceApi {
  final commons.ApiRequester _requester;

  MachineTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of machine types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/machineTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new MachineTypeAggregatedList.fromJson(data));
  }

  /// Returns the specified machine type. Gets a list of available machine types
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [machineType] - Name of the machine type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineType> get(
      core.String project, core.String zone, core.String machineType,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (machineType == null) {
      throw new core.ArgumentError("Parameter machineType is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/machineTypes/' +
        commons.Escaper.ecapeVariable('$machineType');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new MachineType.fromJson(data));
  }

  /// Retrieves a list of machine types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/machineTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new MachineTypeList.fromJson(data));
  }
}

class NetworkEndpointGroupsResourceApi {
  final commons.ApiRequester _requester;

  NetworkEndpointGroupsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves the list of network endpoint groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/networkEndpointGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new NetworkEndpointGroupAggregatedList.fromJson(data));
  }

  /// Attach a list of network endpoints to the specified network endpoint
  /// group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are attaching network endpoints to. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachNetworkEndpoints(
      NetworkEndpointGroupsAttachEndpointsRequest request,
      core.String project,
      core.String zone,
      core.String networkEndpointGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/attachNetworkEndpoints';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified network endpoint group. The network endpoints in the
  /// NEG and the VM instances they belong to are not terminated when the NEG is
  /// deleted. Note that the NEG cannot be deleted if there are backend services
  /// referencing it.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String networkEndpointGroup,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Detach a list of network endpoints from the specified network endpoint
  /// group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are removing network endpoints. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachNetworkEndpoints(
      NetworkEndpointGroupsDetachEndpointsRequest request,
      core.String project,
      core.String zone,
      core.String networkEndpointGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/detachNetworkEndpoints';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified network endpoint group. Gets a list of available
  /// network endpoint groups by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
      core.String project, core.String zone, core.String networkEndpointGroup,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NetworkEndpointGroup.fromJson(data));
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the network
  /// endpoint group. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      NetworkEndpointGroup request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of network endpoint groups that are located in the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
      core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new NetworkEndpointGroupList.fromJson(data));
  }

  /// Lists the network endpoints in the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group from which
  /// you want to generate a list of included network endpoints. It should
  /// comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupsListNetworkEndpoints].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupsListNetworkEndpoints> listNetworkEndpoints(
      NetworkEndpointGroupsListEndpointsRequest request,
      core.String project,
      core.String zone,
      core.String networkEndpointGroup,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (networkEndpointGroup == null) {
      throw new core.ArgumentError(
          "Parameter networkEndpointGroup is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/listNetworkEndpoints';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then(
        (data) => new NetworkEndpointGroupsListNetworkEndpoints.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String zone,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class NetworksResourceApi {
  final commons.ApiRequester _requester;

  NetworksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a peering to the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network resource to add peering to.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addPeering(NetworksAddPeeringRequest request,
      core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/addPeering';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified network.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified network. Gets a list of available networks by making
  /// a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Network].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Network> get(core.String project, core.String network,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Network.fromJson(data));
  }

  /// Creates a network in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Network request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/networks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of networks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/networks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NetworkList.fromJson(data));
  }

  /// Lists the peering routes exchanged over peering connection.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [direction] - The direction of the exchanged routes.
  /// Possible string values are:
  /// - "INCOMING"
  /// - "OUTGOING"
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [peeringName] - The response will show routes exchanged over the given
  /// peering connection.
  ///
  /// [region] - The region of the request. The response will include all subnet
  /// routes, static routes and dynamic routes in the region.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExchangedPeeringRoutesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExchangedPeeringRoutesList> listPeeringRoutes(
      core.String project, core.String network,
      {core.String direction,
      core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String peeringName,
      core.String region,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (direction != null) {
      _queryParams["direction"] = [direction];
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if (peeringName != null) {
      _queryParams["peeringName"] = [peeringName];
    }
    if (region != null) {
      _queryParams["region"] = [region];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/listPeeringRoutes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new ExchangedPeeringRoutesList.fromJson(data));
  }

  /// Patches the specified network with the data included in the request. Only
  /// the following fields can be modified: routingConfig.routingMode.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Network request, core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Removes a peering from the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network resource to remove peering from.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removePeering(NetworksRemovePeeringRequest request,
      core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/removePeering';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Switches the network mode from auto subnet mode to custom subnet mode.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to be updated.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> switchToCustomMode(
      core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/switchToCustomMode';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified network peering with the data included in the
  /// request Only the following fields can be modified:
  /// NetworkPeering.export_custom_routes, and
  /// NetworkPeering.import_custom_routes
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network resource which the updated peering is
  /// belonging to.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePeering(NetworksUpdatePeeringRequest request,
      core.String project, core.String network,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (network == null) {
      throw new core.ArgumentError("Parameter network is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/updatePeering';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class NodeGroupsResourceApi {
  final commons.ApiRequester _requester;

  NodeGroupsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds specified number of nodes to the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addNodes(NodeGroupsAddNodesRequest request,
      core.String project, core.String zone, core.String nodeGroup,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (nodeGroup == null) {
      throw new core.ArgumentError("Parameter nodeGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup') +
        '/addNodes';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves an aggregated list of node groups. Note: use
  /// nodeGroups.listNodes for more details about each group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/nodeGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeGroupAggregatedList.fromJson(data));
  }

  /// Deletes the specified NodeGroup resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String nodeGroup,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (nodeGroup == null) {
      throw new core.ArgumentError("Parameter nodeGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes specified nodes from the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource whose nodes will be deleted.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteNodes(NodeGroupsDeleteNodesRequest request,
      core.String project, core.String zone, core.String nodeGroup,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (nodeGroup == null) {
      throw new core.ArgumentError("Parameter nodeGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup') +
        '/deleteNodes';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified NodeGroup. Get a list of available NodeGroups by
  /// making a list() request. Note: the "nodes" field should not be used. Use
  /// nodeGroups.listNodes instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the node group to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroup> get(
      core.String project, core.String zone, core.String nodeGroup,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (nodeGroup == null) {
      throw new core.ArgumentError("Parameter nodeGroup is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeGroup.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
      core.String project, core.String zone, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Creates a NodeGroup resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [initialNodeCount] - Initial count of nodes in the node group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(NodeGroup request, core.String project,
      core.String zone, core.int initialNodeCount,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (initialNodeCount == null) {
      throw new core.ArgumentError("Parameter initialNodeCount is required.");
    }
    _queryParams["initialNodeCount"] = ["${initialNodeCount}"];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of node groups available to the specified project. Note:
  /// use nodeGroups.listNodes for more details about each group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeGroupList.fromJson(data));
  }

  /// Lists nodes in the node group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource whose nodes you want to list.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupsListNodes].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupsListNodes> listNodes(
      core.String project, core.String zone, core.String nodeGroup,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (nodeGroup == null) {
      throw new core.ArgumentError("Parameter nodeGroup is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup') +
        '/listNodes';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeGroupsListNodes.fromJson(data));
  }

  /// Updates the specified node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(NodeGroup request, core.String project,
      core.String zone, core.String nodeGroup,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (nodeGroup == null) {
      throw new core.ArgumentError("Parameter nodeGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(ZoneSetPolicyRequest request,
      core.String project, core.String zone, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Updates the node template of the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNodeTemplate(
      NodeGroupsSetNodeTemplateRequest request,
      core.String project,
      core.String zone,
      core.String nodeGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (nodeGroup == null) {
      throw new core.ArgumentError("Parameter nodeGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup') +
        '/setNodeTemplate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String zone,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class NodeTemplatesResourceApi {
  final commons.ApiRequester _requester;

  NodeTemplatesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of node templates.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplateAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplateAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/nodeTemplates';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new NodeTemplateAggregatedList.fromJson(data));
  }

  /// Deletes the specified NodeTemplate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeTemplate] - Name of the NodeTemplate resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String nodeTemplate,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (nodeTemplate == null) {
      throw new core.ArgumentError("Parameter nodeTemplate is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$nodeTemplate');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified node template. Gets a list of available node
  /// templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeTemplate] - Name of the node template to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplate> get(
      core.String project, core.String region, core.String nodeTemplate,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (nodeTemplate == null) {
      throw new core.ArgumentError("Parameter nodeTemplate is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$nodeTemplate');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeTemplate.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
      core.String project, core.String region, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Creates a NodeTemplate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      NodeTemplate request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of node templates available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplateList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeTemplateList.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(RegionSetPolicyRequest request,
      core.String project, core.String region, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String region,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class NodeTypesResourceApi {
  final commons.ApiRequester _requester;

  NodeTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of node types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTypeAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/nodeTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeTypeAggregatedList.fromJson(data));
  }

  /// Returns the specified node type. Gets a list of available node types by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeType] - Name of the node type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeType> get(
      core.String project, core.String zone, core.String nodeType,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (nodeType == null) {
      throw new core.ArgumentError("Parameter nodeType is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeTypes/' +
        commons.Escaper.ecapeVariable('$nodeType');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeType.fromJson(data));
  }

  /// Retrieves a list of node types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTypeList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new NodeTypeList.fromJson(data));
  }
}

class PacketMirroringsResourceApi {
  final commons.ApiRequester _requester;

  PacketMirroringsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of packetMirrorings.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroringAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroringAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/packetMirrorings';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new PacketMirroringAggregatedList.fromJson(data));
  }

  /// Deletes the specified PacketMirroring resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String packetMirroring,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (packetMirroring == null) {
      throw new core.ArgumentError("Parameter packetMirroring is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings/' +
        commons.Escaper.ecapeVariable('$packetMirroring');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified PacketMirroring resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroring].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroring> get(
      core.String project, core.String region, core.String packetMirroring,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (packetMirroring == null) {
      throw new core.ArgumentError("Parameter packetMirroring is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings/' +
        commons.Escaper.ecapeVariable('$packetMirroring');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new PacketMirroring.fromJson(data));
  }

  /// Creates a PacketMirroring resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      PacketMirroring request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of PacketMirroring resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroringList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroringList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new PacketMirroringList.fromJson(data));
  }

  /// Patches the specified PacketMirroring resource with the data included in
  /// the request. This method supports PATCH semantics and uses JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(PacketMirroring request, core.String project,
      core.String region, core.String packetMirroring,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (packetMirroring == null) {
      throw new core.ArgumentError("Parameter packetMirroring is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings/' +
        commons.Escaper.ecapeVariable('$packetMirroring');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String region,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class ProjectsResourceApi {
  final commons.ApiRequester _requester;

  ProjectsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Disable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnHost(core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/disableXpnHost';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Disable a service resource (also known as service project) associated with
  /// this host project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnResource(
      ProjectsDisableXpnResourceRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/disableXpnResource';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Enable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnHost(core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/enableXpnHost';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Enable service resource (a.k.a service project) for a host project, so
  /// that subnets in the host project can be used by instances in the service
  /// project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnResource(
      ProjectsEnableXpnResourceRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/enableXpnResource';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Project resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> get(core.String project, {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Project.fromJson(data));
  }

  /// Gets the shared VPC host project that this project links to. May be empty
  /// if no link exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> getXpnHost(core.String project, {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/getXpnHost';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Project.fromJson(data));
  }

  /// Gets service resources (a.k.a service project) associated with this host
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ProjectsGetXpnResources].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ProjectsGetXpnResources> getXpnResources(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/getXpnResources';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ProjectsGetXpnResources.fromJson(data));
  }

  /// Lists all shared VPC host projects visible to the user in an organization.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [XpnHostList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<XpnHostList> listXpnHosts(
      ProjectsListXpnHostsRequest request, core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/listXpnHosts';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new XpnHostList.fromJson(data));
  }

  /// Moves a persistent disk from one zone to another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveDisk(DiskMoveRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/moveDisk';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Moves an instance and its attached persistent disks from one zone to
  /// another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveInstance(
      InstanceMoveRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/moveInstance';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets metadata common to all instances within the specified project using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setCommonInstanceMetadata(
      Metadata request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/setCommonInstanceMetadata';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the default network tier of the project. The default network tier is
  /// used when an address/forwardingRule/instance is created without specifying
  /// the network tier field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDefaultNetworkTier(
      ProjectsSetDefaultNetworkTierRequest request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/setDefaultNetworkTier';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Enables the usage export feature and sets the usage export bucket where
  /// reports are stored. If you provide an empty request body using this
  /// method, the usage export feature will be disabled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUsageExportBucket(
      UsageExportLocation request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/setUsageExportBucket';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionAutoscalersResourceApi {
  final commons.ApiRequester _requester;

  RegionAutoscalersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String autoscaler,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (autoscaler == null) {
      throw new core.ArgumentError("Parameter autoscaler is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
      core.String project, core.String region, core.String autoscaler,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (autoscaler == null) {
      throw new core.ArgumentError("Parameter autoscaler is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Autoscaler.fromJson(data));
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Autoscaler request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of autoscalers contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionAutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionAutoscalerList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RegionAutoscalerList.fromJson(data));
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      Autoscaler request, core.String project, core.String region,
      {core.String autoscaler, core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (autoscaler != null) {
      _queryParams["autoscaler"] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      Autoscaler request, core.String project, core.String region,
      {core.String autoscaler, core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (autoscaler != null) {
      _queryParams["autoscaler"] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionBackendServicesResourceApi {
  final commons.ApiRequester _requester;

  RegionBackendServicesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
      core.String project, core.String region, core.String backendService,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendService.fromJson(data));
  }

  /// Gets the most recent health check results for this regional
  /// BackendService.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource for which to get
  /// health.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
      ResourceGroupReference request,
      core.String project,
      core.String region,
      core.String backendService,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/getHealth';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new BackendServiceGroupHealth.fromJson(data));
  }

  /// Creates a regional BackendService resource in the specified project using
  /// the data included in the request. There are several restrictions and
  /// guidelines to keep in mind when creating a regional backend service. Read
  /// Understanding backend services for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      BackendService request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of regional BackendService resources available to the
  /// specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new BackendServiceList.fromJson(data));
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request. There are several Understanding backend services
  /// to keep in mind when updating a backend service. Read  Understanding
  /// backend services for more information. This method supports PATCH
  /// semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(BackendService request, core.String project,
      core.String region, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request. There are several Understanding backend services
  /// to keep in mind when updating a backend service. Read  Understanding
  /// backend services for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(BackendService request, core.String project,
      core.String region, core.String backendService,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (backendService == null) {
      throw new core.ArgumentError("Parameter backendService is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionCommitmentsResourceApi {
  final commons.ApiRequester _requester;

  RegionCommitmentsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of commitments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/commitments';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new CommitmentAggregatedList.fromJson(data));
  }

  /// Returns the specified commitment resource. Gets a list of available
  /// commitments by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [commitment] - Name of the commitment to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Commitment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Commitment> get(
      core.String project, core.String region, core.String commitment,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (commitment == null) {
      throw new core.ArgumentError("Parameter commitment is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments/' +
        commons.Escaper.ecapeVariable('$commitment');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Commitment.fromJson(data));
  }

  /// Creates a commitment in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Commitment request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of commitments contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new CommitmentList.fromJson(data));
  }
}

class RegionDiskTypesResourceApi {
  final commons.ApiRequester _requester;

  RegionDiskTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified regional disk type. Gets a list of available disk
  /// types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
      core.String project, core.String region, core.String diskType,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (diskType == null) {
      throw new core.ArgumentError("Parameter diskType is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/diskTypes/' +
        commons.Escaper.ecapeVariable('$diskType');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskType.fromJson(data));
  }

  /// Retrieves a list of regional disk types available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionDiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionDiskTypeList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/diskTypes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RegionDiskTypeList.fromJson(data));
  }
}

class RegionDisksResourceApi {
  final commons.ApiRequester _requester;

  RegionDisksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds existing resource policies to a regional disk. You can only add one
  /// policy which will be applied to this disk for scheduling snapshot
  /// creation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
      RegionDisksAddResourcePoliciesRequest request,
      core.String project,
      core.String region,
      core.String disk,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/addResourcePolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Creates a snapshot of this regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the regional persistent disk to snapshot.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(Snapshot request, core.String project,
      core.String region, core.String disk,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/createSnapshot';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified regional persistent disk. Deleting a regional disk
  /// removes all the replicas of its data permanently and is irreversible.
  /// However, deleting a disk does not delete any snapshots previously made
  /// from the disk. You must separately delete snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the regional persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String disk,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns a specified regional persistent disk.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the regional persistent disk to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
      core.String project, core.String region, core.String disk,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Disk.fromJson(data));
  }

  /// Creates a persistent regional disk in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Optional. Source image to restore onto a disk.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Disk request, core.String project, core.String region,
      {core.String requestId, core.String sourceImage, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if (sourceImage != null) {
      _queryParams["sourceImage"] = [sourceImage];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of persistent disks contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new DiskList.fromJson(data));
  }

  /// Removes resource policies from a regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
      RegionDisksRemoveResourcePoliciesRequest request,
      core.String project,
      core.String region,
      core.String disk,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/removeResourcePolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Resizes the specified regional persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - The project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the regional persistent disk.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(RegionDisksResizeRequest request,
      core.String project, core.String region, core.String disk,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (disk == null) {
      throw new core.ArgumentError("Parameter disk is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/resize';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the labels on the target regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(RegionSetLabelsRequest request,
      core.String project, core.String region, core.String resource,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String region,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class RegionHealthChecksResourceApi {
  final commons.ApiRequester _requester;

  RegionHealthChecksResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified HealthCheck resource. Gets a list of available
  /// health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(
      core.String project, core.String region, core.String healthCheck,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HealthCheck.fromJson(data));
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      HealthCheck request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new HealthCheckList.fromJson(data));
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(HealthCheck request, core.String project,
      core.String region, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(HealthCheck request, core.String project,
      core.String region, core.String healthCheck,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (healthCheck == null) {
      throw new core.ArgumentError("Parameter healthCheck is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionInstanceGroupManagersResourceApi {
  final commons.ApiRequester _requester;

  RegionInstanceGroupManagersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Flags the specified instances to be immediately removed from the managed
  /// instance group. Abandoning an instance does not delete the instance, but
  /// it does remove the instance from any target pools that are applied by the
  /// managed instance group. This method reduces the targetSize of the managed
  /// instance group by the number of instances that you abandon. This operation
  /// is marked as DONE when the action is scheduled even if the instances have
  /// not yet been removed from the group. You must separately verify the status
  /// of the abandoning action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
      RegionInstanceGroupManagersAbandonInstancesRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Apply updates to selected instances the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group, should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> applyUpdatesToInstances(
      RegionInstanceGroupManagersApplyUpdatesRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/applyUpdatesToInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Creates instances with per-instance configs in this regional managed
  /// instance group. Instances are created using the current instance template.
  /// The create instances operation is marked DONE if the createInstances
  /// request is successful. The underlying actions take additional time. You
  /// must separately verify the status of the creating or actions with the
  /// listmanagedinstances method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region where the managed instance group is
  /// located. It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createInstances(
      RegionInstanceGroupManagersCreateInstancesRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/createInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String instanceGroupManager,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately deleted. The instances are also removed from any target pools
  /// of which they were a member. This method reduces the targetSize of the
  /// managed instance group by the number of instances that you delete. The
  /// deleteInstances operation is marked DONE if the deleteInstances request is
  /// successful. The underlying actions take additional time. You must
  /// separately verify the status of the deleting action with the
  /// listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
      RegionInstanceGroupManagersDeleteInstancesRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns all of the details about the specified managed instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
      core.String project, core.String region, core.String instanceGroupManager,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroupManager.fromJson(data));
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request. After the group is created, instances in the group are
  /// created using the specified instance template. This operation is marked as
  /// DONE when the group is created even if the instances in the group have not
  /// yet been created. You must separately verify the status of the individual
  /// instances with the listmanagedinstances method.
  ///
  /// A regional managed instance group can contain up to 2000 instances.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      InstanceGroupManager request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of managed instance groups that are contained within
  /// the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagerList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new RegionInstanceGroupManagerList.fromJson(data));
  }

  /// Lists all errors thrown by actions on instances for a given regional
  /// managed instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request. This should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It must
  /// be a string that meets the requirements in RFC1035, or an unsigned long
  /// integer: must match regexp pattern:
  /// (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|[1-9][0-9]{0,19}.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListErrorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListErrorsResponse> listErrors(
      core.String project, core.String region, core.String instanceGroupManager,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listErrors';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) =>
        new RegionInstanceGroupManagersListErrorsResponse.fromJson(data));
  }

  /// Lists the instances in the managed instance group and instances that are
  /// scheduled to be created. The list includes any current actions that the
  /// group has scheduled for its instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListInstancesResponse>
      listManagedInstances(core.String project, core.String region,
          core.String instanceGroupManager,
          {core.String filter,
          core.int maxResults,
          core.String orderBy,
          core.String pageToken,
          core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) =>
        new RegionInstanceGroupManagersListInstancesResponse.fromJson(data));
  }

  /// Updates a managed instance group using the information that you specify in
  /// the request. This operation is marked as DONE when the group is patched
  /// even if the instances in the group are still in the process of being
  /// patched. You must separately verify the status of the individual instances
  /// with the listmanagedinstances method. This method supports PATCH semantics
  /// and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the instance group manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(InstanceGroupManager request,
      core.String project, core.String region, core.String instanceGroupManager,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately recreated. The instances are deleted and recreated using the
  /// current instance template for the managed instance group. This operation
  /// is marked as DONE when the flag is set even if the instances have not yet
  /// been recreated. You must separately verify the status of the recreating
  /// action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
      RegionInstanceGroupManagersRecreateRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the intended size of the managed instance group. If you increase
  /// the size, the group creates new instances using the current instance
  /// template. If you decrease the size, the group deletes one or more
  /// instances.
  ///
  /// The resize operation is marked DONE if the resize request is successful.
  /// The underlying actions take additional time. You must separately verify
  /// the status of the creating or deleting actions with the
  /// listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [size] - Number of instances that should exist in this instance group
  /// manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(core.String project, core.String region,
      core.String instanceGroupManager, core.int size,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (size == null) {
      throw new core.ArgumentError("Parameter size is required.");
    }
    _queryParams["size"] = ["${size}"];
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/resize';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the instance template to use when creating new instances or
  /// recreating instances in this group. Existing instances are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
      RegionInstanceGroupManagersSetTemplateRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Modifies the target pools to which all new instances in this group are
  /// assigned. Existing instances in the group are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
      RegionInstanceGroupManagersSetTargetPoolsRequest request,
      core.String project,
      core.String region,
      core.String instanceGroupManager,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroupManager == null) {
      throw new core.ArgumentError(
          "Parameter instanceGroupManager is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionInstanceGroupsResourceApi {
  final commons.ApiRequester _requester;

  RegionInstanceGroupsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Returns the specified instance group resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the instance group resource to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
      core.String project, core.String region, core.String instanceGroup,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new InstanceGroup.fromJson(data));
  }

  /// Retrieves the list of instance group resources contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RegionInstanceGroupList.fromJson(data));
  }

  /// Lists the instances in the specified instance group and displays
  /// information about the named ports. Depending on the specified options,
  /// this method can list all instances or only the instances that are running.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the regional instance group for which we want to
  /// list the instances.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupsListInstances> listInstances(
      RegionInstanceGroupsListInstancesRequest request,
      core.String project,
      core.String region,
      core.String instanceGroup,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/listInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new RegionInstanceGroupsListInstances.fromJson(data));
  }

  /// Sets the named ports for the specified regional instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - The name of the regional instance group where the named
  /// ports are updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
      RegionInstanceGroupsSetNamedPortsRequest request,
      core.String project,
      core.String region,
      core.String instanceGroup,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (instanceGroup == null) {
      throw new core.ArgumentError("Parameter instanceGroup is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/setNamedPorts';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionOperationsResourceApi {
  final commons.ApiRequester _requester;

  RegionOperationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(
      core.String project, core.String region, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => null);
  }

  /// Retrieves the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
      core.String project, core.String region, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new OperationList.fromJson(data));
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource. This method differs from the `GET` method in that it
  /// waits for no more than the default deadline (2 minutes) and then returns
  /// the current state of the operation, which might be `DONE` or still in
  /// progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
      core.String project, core.String region, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation') +
        '/wait';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionSslCertificatesResourceApi {
  final commons.ApiRequester _requester;

  RegionSslCertificatesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified SslCertificate resource in the region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String sslCertificate,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (sslCertificate == null) {
      throw new core.ArgumentError("Parameter sslCertificate is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified SslCertificate resource in the specified region. Get
  /// a list of available SSL certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
      core.String project, core.String region, core.String sslCertificate,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (sslCertificate == null) {
      throw new core.ArgumentError("Parameter sslCertificate is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SslCertificate.fromJson(data));
  }

  /// Creates a SslCertificate resource in the specified project and region
  /// using the data included in the request
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      SslCertificate request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/sslCertificates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/sslCertificates';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SslCertificateList.fromJson(data));
  }
}

class RegionTargetHttpProxiesResourceApi {
  final commons.ApiRequester _requester;

  RegionTargetHttpProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String targetHttpProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetHttpProxy resource in the specified region.
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
      core.String project, core.String region, core.String targetHttpProxy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpProxy.fromJson(data));
  }

  /// Creates a TargetHttpProxy resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      TargetHttpProxy request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpProxyList.fromJson(data));
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(UrlMapReference request,
      core.String project, core.String region, core.String targetHttpProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionTargetHttpsProxiesResourceApi {
  final commons.ApiRequester _requester;

  RegionTargetHttpsProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String targetHttpsProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetHttpsProxy resource in the specified region.
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
      core.String project, core.String region, core.String targetHttpsProxy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpsProxy.fromJson(data));
  }

  /// Creates a TargetHttpsProxy resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      TargetHttpsProxy request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpsProxyList.fromJson(data));
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
      RegionTargetHttpsProxiesSetSslCertificatesRequest request,
      core.String project,
      core.String region,
      core.String targetHttpsProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy to set a URL map for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(UrlMapReference request,
      core.String project, core.String region, core.String targetHttpsProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RegionUrlMapsResourceApi {
  final commons.ApiRequester _requester;

  RegionUrlMapsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified UrlMap resource. Gets a list of available URL maps
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(
      core.String project, core.String region, core.String urlMap,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMap.fromJson(data));
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      UrlMap request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of UrlMap resources available to the specified project
  /// in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMapList.fromJson(data));
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request. This method supports PATCH semantics and uses JSON merge patch
  /// format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(UrlMap request, core.String project,
      core.String region, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(UrlMap request, core.String project,
      core.String region, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Runs static validation for the UrlMap. In particular, the tests of the
  /// provided UrlMap will be run. Calling this method does NOT create the
  /// UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
      RegionUrlMapsValidateRequest request,
      core.String project,
      core.String region,
      core.String urlMap,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap') +
        '/validate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMapsValidateResponse.fromJson(data));
  }
}

class RegionsResourceApi {
  final commons.ApiRequester _requester;

  RegionsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Region resource. Gets a list of available regions by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Region].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Region> get(core.String project, core.String region,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Region.fromJson(data));
  }

  /// Retrieves the list of region resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/regions';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RegionList.fromJson(data));
  }
}

class ReservationsResourceApi {
  final commons.ApiRequester _requester;

  ReservationsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of reservations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ReservationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ReservationAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/reservations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new ReservationAggregatedList.fromJson(data));
  }

  /// Deletes the specified reservation.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [reservation] - Name of the reservation to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String reservation,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (reservation == null) {
      throw new core.ArgumentError("Parameter reservation is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$reservation');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves information about the specified reservation.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [reservation] - Name of the reservation to retrieve.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Reservation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Reservation> get(
      core.String project, core.String zone, core.String reservation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (reservation == null) {
      throw new core.ArgumentError("Parameter reservation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$reservation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Reservation.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
      core.String project, core.String zone, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Creates a new reservation. For more information, read Reserving zonal
  /// resources.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Reservation request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// A list of all the reservations that have been configured for the specified
  /// project in specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ReservationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ReservationList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ReservationList.fromJson(data));
  }

  /// Resizes the reservation (applicable to standalone reservations only). For
  /// more information, read Modifying reservations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [reservation] - Name of the reservation to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(ReservationsResizeRequest request,
      core.String project, core.String zone, core.String reservation,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (reservation == null) {
      throw new core.ArgumentError("Parameter reservation is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$reservation') +
        '/resize';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(ZoneSetPolicyRequest request,
      core.String project, core.String zone, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String zone,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class ResourcePoliciesResourceApi {
  final commons.ApiRequester _requester;

  ResourcePoliciesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of resource policies.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicyAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/resourcePolicies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new ResourcePolicyAggregatedList.fromJson(data));
  }

  /// Deletes the specified resource policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resourcePolicy] - Name of the resource policy to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String resourcePolicy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resourcePolicy == null) {
      throw new core.ArgumentError("Parameter resourcePolicy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resourcePolicy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves all information of the specified resource policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resourcePolicy] - Name of the resource policy to retrieve.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicy> get(
      core.String project, core.String region, core.String resourcePolicy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resourcePolicy == null) {
      throw new core.ArgumentError("Parameter resourcePolicy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resourcePolicy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ResourcePolicy.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
      core.String project, core.String region, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Creates a new resource policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      ResourcePolicy request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// A list all the resource policies that have been configured for the
  /// specified project in specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicyList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ResourcePolicyList.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(RegionSetPolicyRequest request,
      core.String project, core.String region, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String region,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class RoutersResourceApi {
  final commons.ApiRequester _requester;

  RoutersResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of routers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/routers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RouterAggregatedList.fromJson(data));
  }

  /// Deletes the specified Router resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String router,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Router resource. Gets a list of available routers by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Router].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Router> get(
      core.String project, core.String region, core.String router,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Router.fromJson(data));
  }

  /// Retrieves runtime Nat mapping information of VM endpoints.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to query for Nat Mapping
  /// information of VM endpoints.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VmEndpointNatMappingsList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VmEndpointNatMappingsList> getNatMappingInfo(
      core.String project, core.String region, core.String router,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router') +
        '/getNatMappingInfo';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new VmEndpointNatMappingsList.fromJson(data));
  }

  /// Retrieves runtime information of the specified router.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterStatusResponse> getRouterStatus(
      core.String project, core.String region, core.String router,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router') +
        '/getRouterStatus';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RouterStatusResponse.fromJson(data));
  }

  /// Creates a Router resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Router request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of Router resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RouterList.fromJson(data));
  }

  /// Patches the specified Router resource with the data included in the
  /// request. This method supports PATCH semantics and uses JSON merge patch
  /// format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(Router request, core.String project,
      core.String region, core.String router,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Preview fields auto-generated during router create and update operations.
  /// Calling this method does NOT create or update the router.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RoutersPreviewResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RoutersPreviewResponse> preview(Router request,
      core.String project, core.String region, core.String router,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router') +
        '/preview';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RoutersPreviewResponse.fromJson(data));
  }

  /// Updates the specified Router resource with the data included in the
  /// request. This method conforms to PUT semantics, which requests that the
  /// state of the target resource be created or replaced with the state defined
  /// by the representation enclosed in the request message payload.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(Router request, core.String project,
      core.String region, core.String router,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (router == null) {
      throw new core.ArgumentError("Parameter router is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class RoutesResourceApi {
  final commons.ApiRequester _requester;

  RoutesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Route resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [route] - Name of the Route resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String route,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (route == null) {
      throw new core.ArgumentError("Parameter route is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/routes/' +
        commons.Escaper.ecapeVariable('$route');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Route resource. Gets a list of available routes by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [route] - Name of the Route resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Route].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Route> get(core.String project, core.String route,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (route == null) {
      throw new core.ArgumentError("Parameter route is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/routes/' +
        commons.Escaper.ecapeVariable('$route');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Route.fromJson(data));
  }

  /// Creates a Route resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(Route request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/routes';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of Route resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouteList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouteList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/routes';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new RouteList.fromJson(data));
  }
}

class SecurityPoliciesResourceApi {
  final commons.ApiRequester _requester;

  SecurityPoliciesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Inserts a rule into a security policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addRule(SecurityPolicyRule request,
      core.String project, core.String securityPolicy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (securityPolicy == null) {
      throw new core.ArgumentError("Parameter securityPolicy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy') +
        '/addRule';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes the specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String securityPolicy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (securityPolicy == null) {
      throw new core.ArgumentError("Parameter securityPolicy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// List all of the ordered rules present in a single specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to get.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicy> get(
      core.String project, core.String securityPolicy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (securityPolicy == null) {
      throw new core.ArgumentError("Parameter securityPolicy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SecurityPolicy.fromJson(data));
  }

  /// Gets a rule at the specified priority.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to which the queried rule
  /// belongs.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [priority] - The priority of the rule to get from the security policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicyRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicyRule> getRule(
      core.String project, core.String securityPolicy,
      {core.int priority, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (securityPolicy == null) {
      throw new core.ArgumentError("Parameter securityPolicy is required.");
    }
    if (priority != null) {
      _queryParams["priority"] = ["${priority}"];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy') +
        '/getRule';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SecurityPolicyRule.fromJson(data));
  }

  /// Creates a new policy in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(SecurityPolicy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/securityPolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// List all the policies that have been configured for the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/securityPolicies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SecurityPolicyList.fromJson(data));
  }

  /// Gets the current list of preconfigured Web Application Firewall (WAF)
  /// expressions.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [SecurityPoliciesListPreconfiguredExpressionSetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPoliciesListPreconfiguredExpressionSetsResponse>
      listPreconfiguredExpressionSets(core.String project,
          {core.String filter,
          core.int maxResults,
          core.String orderBy,
          core.String pageToken,
          core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/listPreconfiguredExpressionSets';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) =>
        new SecurityPoliciesListPreconfiguredExpressionSetsResponse.fromJson(
            data));
  }

  /// Patches the specified policy with the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      SecurityPolicy request, core.String project, core.String securityPolicy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (securityPolicy == null) {
      throw new core.ArgumentError("Parameter securityPolicy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Patches a rule at the specified priority.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [priority] - The priority of the rule to patch.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchRule(SecurityPolicyRule request,
      core.String project, core.String securityPolicy,
      {core.int priority, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (securityPolicy == null) {
      throw new core.ArgumentError("Parameter securityPolicy is required.");
    }
    if (priority != null) {
      _queryParams["priority"] = ["${priority}"];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy') +
        '/patchRule';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Deletes a rule at the specified priority.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [priority] - The priority of the rule to remove from the security policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeRule(
      core.String project, core.String securityPolicy,
      {core.int priority, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (securityPolicy == null) {
      throw new core.ArgumentError("Parameter securityPolicy is required.");
    }
    if (priority != null) {
      _queryParams["priority"] = ["${priority}"];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy') +
        '/removeRule';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class SnapshotsResourceApi {
  final commons.ApiRequester _requester;

  SnapshotsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Snapshot resource. Keep in mind that deleting a
  /// single snapshot might not necessarily delete all the data on that
  /// snapshot. If any data on the snapshot that is marked for deletion is
  /// needed for subsequent snapshots, the data will be moved to the next
  /// corresponding snapshot.
  ///
  /// For more information, see Deleting snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [snapshot] - Name of the Snapshot resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String snapshot,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (snapshot == null) {
      throw new core.ArgumentError("Parameter snapshot is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$snapshot');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified Snapshot resource. Gets a list of available
  /// snapshots by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [snapshot] - Name of the Snapshot resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Snapshot].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Snapshot> get(core.String project, core.String snapshot,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (snapshot == null) {
      throw new core.ArgumentError("Parameter snapshot is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$snapshot');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Snapshot.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Retrieves the list of Snapshot resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SnapshotList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SnapshotList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/snapshots';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SnapshotList.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
      GlobalSetPolicyRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Sets the labels on a snapshot. To learn more about labels, read the
  /// Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
      GlobalSetLabelsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request, core.String project, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class SslCertificatesResourceApi {
  final commons.ApiRequester _requester;

  SslCertificatesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all SslCertificate resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/sslCertificates';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new SslCertificateAggregatedList.fromJson(data));
  }

  /// Deletes the specified SslCertificate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String sslCertificate,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (sslCertificate == null) {
      throw new core.ArgumentError("Parameter sslCertificate is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified SslCertificate resource. Gets a list of available
  /// SSL certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
      core.String project, core.String sslCertificate,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (sslCertificate == null) {
      throw new core.ArgumentError("Parameter sslCertificate is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SslCertificate.fromJson(data));
  }

  /// Creates a SslCertificate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(SslCertificate request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/sslCertificates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/sslCertificates';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SslCertificateList.fromJson(data));
  }
}

class SslPoliciesResourceApi {
  final commons.ApiRequester _requester;

  SslPoliciesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified SSL policy. The SSL policy resource can be deleted
  /// only if it is not in use by any TargetHttpsProxy or TargetSslProxy
  /// resources.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslPolicy] - Name of the SSL policy to delete. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String sslPolicy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (sslPolicy == null) {
      throw new core.ArgumentError("Parameter sslPolicy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.Escaper.ecapeVariable('$sslPolicy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Lists all of the ordered rules present in a single specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslPolicy] - Name of the SSL policy to update. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPolicy> get(core.String project, core.String sslPolicy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (sslPolicy == null) {
      throw new core.ArgumentError("Parameter sslPolicy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.Escaper.ecapeVariable('$sslPolicy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SslPolicy.fromJson(data));
  }

  /// Returns the specified SSL policy resource. Gets a list of available SSL
  /// policies by making a list() request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(SslPolicy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/sslPolicies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Lists all the SSL policies that have been configured for the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPoliciesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPoliciesList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/sslPolicies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SslPoliciesList.fromJson(data));
  }

  /// Lists all features that can be specified in the SSL policy when using
  /// custom profile.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPoliciesListAvailableFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPoliciesListAvailableFeaturesResponse> listAvailableFeatures(
      core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslPolicies/listAvailableFeatures';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then(
        (data) => new SslPoliciesListAvailableFeaturesResponse.fromJson(data));
  }

  /// Patches the specified SSL policy with the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslPolicy] - Name of the SSL policy to update. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      SslPolicy request, core.String project, core.String sslPolicy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (sslPolicy == null) {
      throw new core.ArgumentError("Parameter sslPolicy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.Escaper.ecapeVariable('$sslPolicy');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class SubnetworksResourceApi {
  final commons.ApiRequester _requester;

  SubnetworksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of subnetworks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/subnetworks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new SubnetworkAggregatedList.fromJson(data));
  }

  /// Deletes the specified subnetwork.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String subnetwork,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Expands the IP CIDR range of the subnetwork to a specified value.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> expandIpCidrRange(
      SubnetworksExpandIpCidrRangeRequest request,
      core.String project,
      core.String region,
      core.String subnetwork,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork') +
        '/expandIpCidrRange';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified subnetwork. Gets a list of available subnetworks
  /// list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Subnetwork].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Subnetwork> get(
      core.String project, core.String region, core.String subnetwork,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Subnetwork.fromJson(data));
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
      core.String project, core.String region, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Creates a subnetwork in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      Subnetwork request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of subnetworks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new SubnetworkList.fromJson(data));
  }

  /// Retrieves an aggregated list of all usable subnetworks in the project. The
  /// list contains all of the subnetworks in the project and the subnetworks
  /// that were shared by a Shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UsableSubnetworksAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UsableSubnetworksAggregatedList> listUsable(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/subnetworks/listUsable';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new UsableSubnetworksAggregatedList.fromJson(data));
  }

  /// Patches the specified subnetwork with the data included in the request.
  /// Only certain fields can up updated with a patch request as indicated in
  /// the field descriptions. You must specify the current fingerprint of the
  /// subnetwork resource being patched.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [drainTimeoutSeconds] - The drain timeout specifies the upper bound in
  /// seconds on the amount of time allowed to drain connections from the
  /// current ACTIVE subnetwork to the current BACKUP subnetwork. The drain
  /// timeout is only applicable when the following conditions are true: - the
  /// subnetwork being patched has purpose = INTERNAL_HTTPS_LOAD_BALANCER - the
  /// subnetwork being patched has role = BACKUP - the patch request is setting
  /// the role to ACTIVE. Note that after this patch operation the roles of the
  /// ACTIVE and BACKUP subnetworks will be swapped.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(Subnetwork request, core.String project,
      core.String region, core.String subnetwork,
      {core.int drainTimeoutSeconds,
      core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if (drainTimeoutSeconds != null) {
      _queryParams["drainTimeoutSeconds"] = ["${drainTimeoutSeconds}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(RegionSetPolicyRequest request,
      core.String project, core.String region, core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Policy.fromJson(data));
  }

  /// Set whether VMs in this subnet can access Google services without
  /// assigning external IP addresses through Private Google Access.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setPrivateIpGoogleAccess(
      SubnetworksSetPrivateIpGoogleAccessRequest request,
      core.String project,
      core.String region,
      core.String subnetwork,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (subnetwork == null) {
      throw new core.ArgumentError("Parameter subnetwork is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork') +
        '/setPrivateIpGoogleAccess';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String region,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class TargetHttpProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetHttpProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves the list of all TargetHttpProxy resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetHttpProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetHttpProxyAggregatedList.fromJson(data));
  }

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String targetHttpProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetHttpProxy resource. Gets a list of available
  /// target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
      core.String project, core.String targetHttpProxy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpProxy.fromJson(data));
  }

  /// Creates a TargetHttpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(TargetHttpProxy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetHttpProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetHttpProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpProxyList.fromJson(data));
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
      UrlMapReference request, core.String project, core.String targetHttpProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetHttpsProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetHttpsProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves the list of all TargetHttpsProxy resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetHttpsProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetHttpsProxyAggregatedList.fromJson(data));
  }

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String targetHttpsProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetHttpsProxy resource. Gets a list of available
  /// target HTTPS proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
      core.String project, core.String targetHttpsProxy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpsProxy.fromJson(data));
  }

  /// Creates a TargetHttpsProxy resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(TargetHttpsProxy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetHttpsProxyList.fromJson(data));
  }

  /// Sets the QUIC override policy for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set the QUIC
  /// override policy for. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setQuicOverride(
      TargetHttpsProxiesSetQuicOverrideRequest request,
      core.String project,
      core.String targetHttpsProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setQuicOverride';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
      TargetHttpsProxiesSetSslCertificatesRequest request,
      core.String project,
      core.String targetHttpsProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
  /// server-side support for SSL features. This affects connections between
  /// clients and the HTTPS proxy load balancer. They do not affect the
  /// connection between the load balancer and the backends.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose SSL
  /// policy is to be set. The name must be 1-63 characters long, and comply
  /// with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslPolicy(SslPolicyReference request,
      core.String project, core.String targetHttpsProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setSslPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose URL map
  /// is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(UrlMapReference request,
      core.String project, core.String targetHttpsProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetHttpsProxy == null) {
      throw new core.ArgumentError("Parameter targetHttpsProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetInstancesResourceApi {
  final commons.ApiRequester _requester;

  TargetInstancesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of target instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetInstances';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetInstanceAggregatedList.fromJson(data));
  }

  /// Deletes the specified TargetInstance resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetInstance] - Name of the TargetInstance resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String zone, core.String targetInstance,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (targetInstance == null) {
      throw new core.ArgumentError("Parameter targetInstance is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances/' +
        commons.Escaper.ecapeVariable('$targetInstance');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetInstance resource. Gets a list of available
  /// target instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetInstance] - Name of the TargetInstance resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstance> get(
      core.String project, core.String zone, core.String targetInstance,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (targetInstance == null) {
      throw new core.ArgumentError("Parameter targetInstance is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances/' +
        commons.Escaper.ecapeVariable('$targetInstance');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetInstance.fromJson(data));
  }

  /// Creates a TargetInstance resource in the specified project and zone using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      TargetInstance request, core.String project, core.String zone,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of TargetInstance resources available to the specified
  /// project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetInstanceList.fromJson(data));
  }
}

class TargetPoolsResourceApi {
  final commons.ApiRequester _requester;

  TargetPoolsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds health check URLs to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the target pool to add a health check to.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addHealthCheck(
      TargetPoolsAddHealthCheckRequest request,
      core.String project,
      core.String region,
      core.String targetPool,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/addHealthCheck';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Adds an instance to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to add instances to.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstance(TargetPoolsAddInstanceRequest request,
      core.String project, core.String region, core.String targetPool,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/addInstance';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves an aggregated list of target pools.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/targetPools';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetPoolAggregatedList.fromJson(data));
  }

  /// Deletes the specified target pool.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String targetPool,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified target pool. Gets a list of available target pools
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPool> get(
      core.String project, core.String region, core.String targetPool,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetPool.fromJson(data));
  }

  /// Gets the most recent health check results for each IP for the instance
  /// that is referenced by the given target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to which the queried
  /// instance belongs.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolInstanceHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolInstanceHealth> getHealth(InstanceReference request,
      core.String project, core.String region, core.String targetPool,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/getHealth';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetPoolInstanceHealth.fromJson(data));
  }

  /// Creates a target pool in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      TargetPool request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of target pools available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetPoolList.fromJson(data));
  }

  /// Removes health check URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the target pool to remove health checks from.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeHealthCheck(
      TargetPoolsRemoveHealthCheckRequest request,
      core.String project,
      core.String region,
      core.String targetPool,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/removeHealthCheck';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Removes instance URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to remove instances from.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstance(
      TargetPoolsRemoveInstanceRequest request,
      core.String project,
      core.String region,
      core.String targetPool,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/removeInstance';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes a backup target pool's configurations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to set a backup pool for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [failoverRatio] - New failoverRatio value for the target pool.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackup(TargetReference request,
      core.String project, core.String region, core.String targetPool,
      {core.double failoverRatio, core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetPool == null) {
      throw new core.ArgumentError("Parameter targetPool is required.");
    }
    if (failoverRatio != null) {
      _queryParams["failoverRatio"] = ["${failoverRatio}"];
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/setBackup';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetSslProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetSslProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetSslProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String targetSslProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetSslProxy resource. Gets a list of available
  /// target SSL proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxy> get(
      core.String project, core.String targetSslProxy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetSslProxy.fromJson(data));
  }

  /// Creates a TargetSslProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(TargetSslProxy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetSslProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetSslProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetSslProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetSslProxyList.fromJson(data));
  }

  /// Changes the BackendService for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
      TargetSslProxiesSetBackendServiceRequest request,
      core.String project,
      core.String targetSslProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setBackendService';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the ProxyHeaderType for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
      TargetSslProxiesSetProxyHeaderRequest request,
      core.String project,
      core.String targetSslProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setProxyHeader';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes SslCertificates for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// SslCertificate resource is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
      TargetSslProxiesSetSslCertificatesRequest request,
      core.String project,
      core.String targetSslProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setSslCertificates';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
  /// server-side support for SSL features. This affects connections between
  /// clients and the SSL proxy load balancer. They do not affect the connection
  /// between the load balancer and the backends.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose SSL policy is
  /// to be set. The name must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslPolicy(SslPolicyReference request,
      core.String project, core.String targetSslProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetSslProxy == null) {
      throw new core.ArgumentError("Parameter targetSslProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setSslPolicy';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetTcpProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetTcpProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetTcpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String targetTcpProxy,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetTcpProxy == null) {
      throw new core.ArgumentError("Parameter targetTcpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified TargetTcpProxy resource. Gets a list of available
  /// target TCP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxy> get(
      core.String project, core.String targetTcpProxy,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetTcpProxy == null) {
      throw new core.ArgumentError("Parameter targetTcpProxy is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetTcpProxy.fromJson(data));
  }

  /// Creates a TargetTcpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(TargetTcpProxy request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetTcpProxies';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of TargetTcpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxyList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetTcpProxies';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetTcpProxyList.fromJson(data));
  }

  /// Changes the BackendService for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
      TargetTcpProxiesSetBackendServiceRequest request,
      core.String project,
      core.String targetTcpProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetTcpProxy == null) {
      throw new core.ArgumentError("Parameter targetTcpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy') +
        '/setBackendService';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Changes the ProxyHeaderType for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
      TargetTcpProxiesSetProxyHeaderRequest request,
      core.String project,
      core.String targetTcpProxy,
      {core.String requestId,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (targetTcpProxy == null) {
      throw new core.ArgumentError("Parameter targetTcpProxy is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy') +
        '/setProxyHeader';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class TargetVpnGatewaysResourceApi {
  final commons.ApiRequester _requester;

  TargetVpnGatewaysResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of target VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayAggregatedList> aggregatedList(
      core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetVpnGateways';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new TargetVpnGatewayAggregatedList.fromJson(data));
  }

  /// Deletes the specified target VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String targetVpnGateway,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetVpnGateway == null) {
      throw new core.ArgumentError("Parameter targetVpnGateway is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.Escaper.ecapeVariable('$targetVpnGateway');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified target VPN gateway. Gets a list of available target
  /// VPN gateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGateway> get(
      core.String project, core.String region, core.String targetVpnGateway,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (targetVpnGateway == null) {
      throw new core.ArgumentError("Parameter targetVpnGateway is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.Escaper.ecapeVariable('$targetVpnGateway');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetVpnGateway.fromJson(data));
  }

  /// Creates a target VPN gateway in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      TargetVpnGateway request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of target VPN gateways available to the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayList> list(
      core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TargetVpnGatewayList.fromJson(data));
  }
}

class UrlMapsResourceApi {
  final commons.ApiRequester _requester;

  UrlMapsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all UrlMap resources, regional and global, available
  /// to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/urlMaps';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMapsAggregatedList.fromJson(data));
  }

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(core.String project, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified UrlMap resource. Gets a list of available URL maps
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(core.String project, core.String urlMap,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMap.fromJson(data));
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(UrlMap request, core.String project,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/urlMaps';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Initiates a cache invalidation operation, invalidating the specified path,
  /// scoped to the specified UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> invalidateCache(
      CacheInvalidationRule request, core.String project, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap') +
        '/invalidateCache';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves the list of UrlMap resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/urlMaps';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMapList.fromJson(data));
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
      UrlMap request, core.String project, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "PATCH",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
      UrlMap request, core.String project, core.String urlMap,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    var _response = _requester.request(_url, "PUT",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Runs static validation for the UrlMap. In particular, the tests of the
  /// provided UrlMap will be run. Calling this method does NOT create the
  /// UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
      UrlMapsValidateRequest request, core.String project, core.String urlMap,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (urlMap == null) {
      throw new core.ArgumentError("Parameter urlMap is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap') +
        '/validate';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new UrlMapsValidateResponse.fromJson(data));
  }
}

class VpnGatewaysResourceApi {
  final commons.ApiRequester _requester;

  VpnGatewaysResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewayAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/vpnGateways';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new VpnGatewayAggregatedList.fromJson(data));
  }

  /// Deletes the specified VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnGateway] - Name of the VPN gateway to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String vpnGateway,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (vpnGateway == null) {
      throw new core.ArgumentError("Parameter vpnGateway is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$vpnGateway');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified VPN gateway. Gets a list of available VPN gateways
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnGateway] - Name of the VPN gateway to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGateway> get(
      core.String project, core.String region, core.String vpnGateway,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (vpnGateway == null) {
      throw new core.ArgumentError("Parameter vpnGateway is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$vpnGateway');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new VpnGateway.fromJson(data));
  }

  /// Returns the status for the specified VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnGateway] - Name of the VPN gateway to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewaysGetStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewaysGetStatusResponse> getStatus(
      core.String project, core.String region, core.String vpnGateway,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (vpnGateway == null) {
      throw new core.ArgumentError("Parameter vpnGateway is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$vpnGateway') +
        '/getStatus';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response
        .then((data) => new VpnGatewaysGetStatusResponse.fromJson(data));
  }

  /// Creates a VPN gateway in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      VpnGateway request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of VPN gateways available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewayList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new VpnGatewayList.fromJson(data));
  }

  /// Sets the labels on a VpnGateway. To learn more about labels, read the
  /// Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(RegionSetLabelsRequest request,
      core.String project, core.String region, core.String resource,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
      TestPermissionsRequest request,
      core.String project,
      core.String region,
      core.String resource,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (resource == null) {
      throw new core.ArgumentError("Parameter resource is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new TestPermissionsResponse.fromJson(data));
  }
}

class VpnTunnelsResourceApi {
  final commons.ApiRequester _requester;

  VpnTunnelsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN tunnels.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelAggregatedList> aggregatedList(core.String project,
      {core.String filter,
      core.bool includeAllScopes,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams["includeAllScopes"] = ["${includeAllScopes}"];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/vpnTunnels';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new VpnTunnelAggregatedList.fromJson(data));
  }

  /// Deletes the specified VpnTunnel resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
      core.String project, core.String region, core.String vpnTunnel,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (vpnTunnel == null) {
      throw new core.ArgumentError("Parameter vpnTunnel is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels/' +
        commons.Escaper.ecapeVariable('$vpnTunnel');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Returns the specified VpnTunnel resource. Gets a list of available VPN
  /// tunnels by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnel].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnel> get(
      core.String project, core.String region, core.String vpnTunnel,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (vpnTunnel == null) {
      throw new core.ArgumentError("Parameter vpnTunnel is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels/' +
        commons.Escaper.ecapeVariable('$vpnTunnel');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new VpnTunnel.fromJson(data));
  }

  /// Creates a VpnTunnel resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
      VpnTunnel request, core.String project, core.String region,
      {core.String requestId, core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (request != null) {
      _body = convert.json.encode((request).toJson());
    }
    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (requestId != null) {
      _queryParams["requestId"] = [requestId];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of VpnTunnel resources contained in the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelList> list(core.String project, core.String region,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (region == null) {
      throw new core.ArgumentError("Parameter region is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new VpnTunnelList.fromJson(data));
  }
}

class ZoneOperationsResourceApi {
  final commons.ApiRequester _requester;

  ZoneOperationsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(
      core.String project, core.String zone, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "DELETE",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => null);
  }

  /// Retrieves the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
      core.String project, core.String zone, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(core.String project, core.String zone,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new OperationList.fromJson(data));
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource. This method differs from the `GET` method in that it
  /// waits for no more than the default deadline (2 minutes) and then returns
  /// the current state of the operation, which might be `DONE` or still in
  /// progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
      core.String project, core.String zone, core.String operation,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if (operation == null) {
      throw new core.ArgumentError("Parameter operation is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation') +
        '/wait';

    var _response = _requester.request(_url, "POST",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Operation.fromJson(data));
  }
}

class ZonesResourceApi {
  final commons.ApiRequester _requester;

  ZonesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Zone resource. Gets a list of available zones by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Zone].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Zone> get(core.String project, core.String zone,
      {core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (zone == null) {
      throw new core.ArgumentError("Parameter zone is required.");
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone');

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new Zone.fromJson(data));
  }

  /// Retrieves the list of Zone resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ZoneList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ZoneList> list(core.String project,
      {core.String filter,
      core.int maxResults,
      core.String orderBy,
      core.String pageToken,
      core.String $fields}) {
    var _url;
    var _queryParams = new core.Map<core.String, core.List<core.String>>();
    var _uploadMedia;
    var _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    var _body;

    if (project == null) {
      throw new core.ArgumentError("Parameter project is required.");
    }
    if (filter != null) {
      _queryParams["filter"] = [filter];
    }
    if (maxResults != null) {
      _queryParams["maxResults"] = ["${maxResults}"];
    }
    if (orderBy != null) {
      _queryParams["orderBy"] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams["pageToken"] = [pageToken];
    }
    if ($fields != null) {
      _queryParams["fields"] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/zones';

    var _response = _requester.request(_url, "GET",
        body: _body,
        queryParams: _queryParams,
        uploadOptions: _uploadOptions,
        uploadMedia: _uploadMedia,
        downloadOptions: _downloadOptions);
    return _response.then((data) => new ZoneList.fromJson(data));
  }
}

/// A specification of the type and number of accelerator cards attached to the
/// instance.
class AcceleratorConfig {
  /// The number of the guest accelerator cards exposed to this instance.
  core.int acceleratorCount;

  /// Full or partial URL of the accelerator type resource to attach to this
  /// instance. For example:
  /// projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100
  /// If you are creating an instance template, specify only the accelerator
  /// name. See GPUs on Compute Engine for a full list of accelerator types.
  core.String acceleratorType;

  AcceleratorConfig();

  AcceleratorConfig.fromJson(core.Map _json) {
    if (_json.containsKey("acceleratorCount")) {
      acceleratorCount = _json["acceleratorCount"];
    }
    if (_json.containsKey("acceleratorType")) {
      acceleratorType = _json["acceleratorType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (acceleratorCount != null) {
      _json["acceleratorCount"] = acceleratorCount;
    }
    if (acceleratorType != null) {
      _json["acceleratorType"] = acceleratorType;
    }
    return _json;
  }
}

/// Represents an Accelerator Type resource.
///
/// Google Cloud Platform provides graphics processing units (accelerators) that
/// you can add to VM instances to improve or accelerate performance when
/// working with intensive workloads. For more information, read GPUs on Compute
/// Engine. (== resource_for {$api_version}.acceleratorTypes ==)
class AcceleratorType {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this accelerator
  /// type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#acceleratorType for
  /// accelerator types.
  core.String kind;

  /// [Output Only] Maximum accelerator cards allowed per instance.
  core.int maximumCardsPerInstance;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// [Output Only] The name of the zone where the accelerator type resides,
  /// such as us-central1-a. You must specify this field as part of the HTTP
  /// request URL. It is not settable as a field in the request body.
  core.String zone;

  AcceleratorType();

  AcceleratorType.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("maximumCardsPerInstance")) {
      maximumCardsPerInstance = _json["maximumCardsPerInstance"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (maximumCardsPerInstance != null) {
      _json["maximumCardsPerInstance"] = maximumCardsPerInstance;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class AcceleratorTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypeAggregatedListWarningData();

  AcceleratorTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AcceleratorTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypeAggregatedListWarning();

  AcceleratorTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AcceleratorTypeAggregatedListWarningData>((value) =>
              new AcceleratorTypeAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AcceleratorTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AcceleratorTypesScopedList resources.
  core.Map<core.String, AcceleratorTypesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#acceleratorTypeAggregatedList for aggregated lists of accelerator
  /// types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AcceleratorTypeAggregatedListWarning warning;

  AcceleratorTypeAggregatedList();

  AcceleratorTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, AcceleratorTypesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new AcceleratorTypesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new AcceleratorTypeAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<AcceleratorTypesScopedList,
              core.Map<core.String, core.Object>>(
          items, (AcceleratorTypesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AcceleratorTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypeListWarningData();

  AcceleratorTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AcceleratorTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypeListWarning();

  AcceleratorTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AcceleratorTypeListWarningData>(
              (value) => new AcceleratorTypeListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of accelerator types.
class AcceleratorTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AcceleratorType resources.
  core.List<AcceleratorType> items;

  /// [Output Only] Type of resource. Always compute#acceleratorTypeList for
  /// lists of accelerator types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AcceleratorTypeListWarning warning;

  AcceleratorTypeList();

  AcceleratorTypeList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<AcceleratorType>((value) => new AcceleratorType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AcceleratorTypeListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AcceleratorTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypesScopedListWarningData();

  AcceleratorTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the accelerator
/// types list is empty.
class AcceleratorTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypesScopedListWarning();

  AcceleratorTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AcceleratorTypesScopedListWarningData>((value) =>
              new AcceleratorTypesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AcceleratorTypesScopedList {
  /// [Output Only] A list of accelerator types contained in this scope.
  core.List<AcceleratorType> acceleratorTypes;

  /// [Output Only] An informational warning that appears when the accelerator
  /// types list is empty.
  AcceleratorTypesScopedListWarning warning;

  AcceleratorTypesScopedList();

  AcceleratorTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("acceleratorTypes")) {
      acceleratorTypes = (_json["acceleratorTypes"] as core.List)
          .map<AcceleratorType>((value) => new AcceleratorType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new AcceleratorTypesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (acceleratorTypes != null) {
      _json["acceleratorTypes"] =
          acceleratorTypes.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// An access configuration attached to an instance's network interface. Only
/// one access config per instance is supported.
class AccessConfig {
  /// [Output Only] Type of the resource. Always compute#accessConfig for access
  /// configs.
  core.String kind;

  /// The name of this access configuration. The default and recommended name is
  /// External NAT, but you can use any arbitrary string, such as My external IP
  /// or Network Access.
  core.String name;

  /// An external IP address associated with this instance. Specify an unused
  /// static external IP address available to the project or leave this field
  /// undefined to use an IP from a shared ephemeral IP address pool. If you
  /// specify a static external IP address, it must live in the same region as
  /// the zone of the instance.
  core.String natIP;

  /// This signifies the networking tier used for configuring this access
  /// configuration and can only take the following values: PREMIUM, STANDARD.
  ///
  /// If an AccessConfig is specified without a valid external IP address, an
  /// ephemeral IP will be created with this networkTier.
  ///
  /// If an AccessConfig with a valid external IP address is specified, it must
  /// match that of the networkTier associated with the Address resource owning
  /// that IP.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String networkTier;

  /// The DNS domain name for the public PTR record. You can set this field only
  /// if the `setPublicPtr` field is enabled.
  core.String publicPtrDomainName;

  /// Specifies whether a public DNS 'PTR' record should be created to map the
  /// external IP address of the instance to a DNS domain name.
  core.bool setPublicPtr;

  /// The type of configuration. The default and only option is ONE_TO_ONE_NAT.
  /// Possible string values are:
  /// - "ONE_TO_ONE_NAT"
  core.String type;

  AccessConfig();

  AccessConfig.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("natIP")) {
      natIP = _json["natIP"];
    }
    if (_json.containsKey("networkTier")) {
      networkTier = _json["networkTier"];
    }
    if (_json.containsKey("publicPtrDomainName")) {
      publicPtrDomainName = _json["publicPtrDomainName"];
    }
    if (_json.containsKey("setPublicPtr")) {
      setPublicPtr = _json["setPublicPtr"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (natIP != null) {
      _json["natIP"] = natIP;
    }
    if (networkTier != null) {
      _json["networkTier"] = networkTier;
    }
    if (publicPtrDomainName != null) {
      _json["publicPtrDomainName"] = publicPtrDomainName;
    }
    if (setPublicPtr != null) {
      _json["setPublicPtr"] = setPublicPtr;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

/// Use global external addresses for GFE-based external HTTP(S) load balancers
/// in Premium Tier.
///
/// Use global internal addresses for reserved peering network range.
///
/// Use regional external addresses for the following resources:
///
/// - External IP addresses for VM instances - Regional external forwarding
/// rules - Cloud NAT external IP addresses - GFE based LBs in Standard Tier -
/// Network LBs in Premium or Standard Tier - Cloud VPN gateways (both Classic
/// and HA)
///
/// Use regional internal IP addresses for subnet IP ranges (primary and
/// secondary). This includes:
///
/// - Internal IP addresses for VM instances - Alias IP ranges of VM instances
/// (/32 only) - Regional internal forwarding rules - Internal TCP/UDP load
/// balancer addresses - Internal HTTP(S) load balancer addresses - Cloud DNS
/// inbound forwarding IP addresses
///
/// For more information, read reserved IP address.
///
/// (== resource_for {$api_version}.addresses ==) (== resource_for
/// {$api_version}.globalAddresses ==)
class Address {
  /// The static IP address represented by this resource.
  core.String address;

  /// The type of address to reserve, either INTERNAL or EXTERNAL. If
  /// unspecified, defaults to EXTERNAL.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "UNSPECIFIED_TYPE"
  core.String addressType;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this field when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The IP version that will be used by this address. Valid options are IPV4
  /// or IPV6. This can only be specified for a global address.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String ipVersion;

  /// [Output Only] Type of the resource. Always compute#address for addresses.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
  /// lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String name;

  /// The URL of the network in which to reserve the address. This field can
  /// only be used with INTERNAL type with the VPC_PEERING purpose.
  core.String network;

  /// This signifies the networking tier used for configuring this address and
  /// can only take the following values: PREMIUM or STANDARD. Global forwarding
  /// rules can only be Premium Tier. Regional forwarding rules can be either
  /// Premium or Standard Tier. Standard Tier addresses applied to regional
  /// forwarding rules can be used with any external load balancer. Regional
  /// forwarding rules in Premium Tier can only be used with a network load
  /// balancer.
  ///
  /// If this field is not specified, it is assumed to be PREMIUM.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String networkTier;

  /// The prefix length if the resource reprensents an IP range.
  core.int prefixLength;

  /// The purpose of this resource, which can be one of the following values:
  /// - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP
  /// ranges, internal load balancers, and similar resources.
  /// - `DNS_RESOLVER` for a DNS resolver address in a subnetwork
  /// - `VPC_PEERING` for addresses that are reserved for VPC peer networks.
  /// - `NAT_AUTO` for addresses that are external IP addresses automatically
  /// reserved for Cloud NAT.
  /// Possible string values are:
  /// - "DNS_RESOLVER"
  /// - "GCE_ENDPOINT"
  /// - "NAT_AUTO"
  /// - "VPC_PEERING"
  core.String purpose;

  /// [Output Only] The URL of the region where the regional address resides.
  /// This field is not applicable to global addresses. You must specify this
  /// field as part of the HTTP request URL.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the address, which can be one of RESERVING,
  /// RESERVED, or IN_USE. An address that is RESERVING is currently in the
  /// process of being reserved. A RESERVED address is currently reserved and
  /// available to use. An IN_USE address is currently being used by another
  /// resource and is not available.
  /// Possible string values are:
  /// - "IN_USE"
  /// - "RESERVED"
  /// - "RESERVING"
  core.String status;

  /// The URL of the subnetwork in which to reserve the address. If an IP
  /// address is specified, it must be within the subnetwork's IP range. This
  /// field can only be used with INTERNAL type with a GCE_ENDPOINT or
  /// DNS_RESOLVER purpose.
  core.String subnetwork;

  /// [Output Only] The URLs of the resources that are using this address.
  core.List<core.String> users;

  Address();

  Address.fromJson(core.Map _json) {
    if (_json.containsKey("address")) {
      address = _json["address"];
    }
    if (_json.containsKey("addressType")) {
      addressType = _json["addressType"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ipVersion")) {
      ipVersion = _json["ipVersion"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("networkTier")) {
      networkTier = _json["networkTier"];
    }
    if (_json.containsKey("prefixLength")) {
      prefixLength = _json["prefixLength"];
    }
    if (_json.containsKey("purpose")) {
      purpose = _json["purpose"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
    if (_json.containsKey("users")) {
      users = (_json["users"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (address != null) {
      _json["address"] = address;
    }
    if (addressType != null) {
      _json["addressType"] = addressType;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (ipVersion != null) {
      _json["ipVersion"] = ipVersion;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (networkTier != null) {
      _json["networkTier"] = networkTier;
    }
    if (prefixLength != null) {
      _json["prefixLength"] = prefixLength;
    }
    if (purpose != null) {
      _json["purpose"] = purpose;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    if (users != null) {
      _json["users"] = users;
    }
    return _json;
  }
}

class AddressAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressAggregatedListWarningData();

  AddressAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AddressAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressAggregatedListWarning();

  AddressAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AddressAggregatedListWarningData>(
              (value) => new AddressAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AddressAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AddressesScopedList resources.
  core.Map<core.String, AddressesScopedList> items;

  /// [Output Only] Type of resource. Always compute#addressAggregatedList for
  /// aggregated lists of addresses.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AddressAggregatedListWarning warning;

  AddressAggregatedList();

  AddressAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, AddressesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new AddressesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AddressAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<AddressesScopedList, core.Map<core.String, core.Object>>(
              items, (AddressesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AddressListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressListWarningData();

  AddressListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AddressListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressListWarning();

  AddressListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AddressListWarningData>(
              (value) => new AddressListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of addresses.
class AddressList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Address resources.
  core.List<Address> items;

  /// [Output Only] Type of resource. Always compute#addressList for lists of
  /// addresses.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AddressListWarning warning;

  AddressList();

  AddressList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Address>((value) => new Address.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AddressListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AddressesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressesScopedListWarningData();

  AddressesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of addresses
/// when the list is empty.
class AddressesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressesScopedListWarning();

  AddressesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AddressesScopedListWarningData>(
              (value) => new AddressesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AddressesScopedList {
  /// [Output Only] A list of addresses contained in this scope.
  core.List<Address> addresses;

  /// [Output Only] Informational warning which replaces the list of addresses
  /// when the list is empty.
  AddressesScopedListWarning warning;

  AddressesScopedList();

  AddressesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("addresses")) {
      addresses = (_json["addresses"] as core.List)
          .map<Address>((value) => new Address.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new AddressesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (addresses != null) {
      _json["addresses"] = addresses.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// An alias IP range attached to an instance's network interface.
class AliasIpRange {
  /// The IP alias ranges to allocate for this interface. This IP CIDR range
  /// must belong to the specified subnetwork and cannot contain IP addresses
  /// reserved by system or used by other network interfaces. This range may be
  /// a single IP address (such as 10.2.3.4), a netmask (such as /24) or a
  /// CIDR-formatted string (such as 10.1.2.0/24).
  core.String ipCidrRange;

  /// The name of a subnetwork secondary IP range from which to allocate an IP
  /// alias range. If not specified, the primary range of the subnetwork is
  /// used.
  core.String subnetworkRangeName;

  AliasIpRange();

  AliasIpRange.fromJson(core.Map _json) {
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
    if (_json.containsKey("subnetworkRangeName")) {
      subnetworkRangeName = _json["subnetworkRangeName"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    if (subnetworkRangeName != null) {
      _json["subnetworkRangeName"] = subnetworkRangeName;
    }
    return _json;
  }
}

class AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk {
  /// Specifies the size of the disk in base-2 GB.
  core.String diskSizeGb;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME. The default is SCSI. For performance characteristics
  /// of SCSI over NVMe, see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String interface;

  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk();

  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk.fromJson(
      core.Map _json) {
    if (_json.containsKey("diskSizeGb")) {
      diskSizeGb = _json["diskSizeGb"];
    }
    if (_json.containsKey("interface")) {
      interface = _json["interface"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskSizeGb != null) {
      _json["diskSizeGb"] = diskSizeGb;
    }
    if (interface != null) {
      _json["interface"] = interface;
    }
    return _json;
  }
}

/// Properties of the SKU instances being reserved.
class AllocationSpecificSKUAllocationReservedInstanceProperties {
  /// Specifies accelerator type and count.
  core.List<AcceleratorConfig> guestAccelerators;

  /// Specifies amount of local ssd to reserve with each instance. The type of
  /// disk is local-ssd.
  core.List<
          AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk>
      localSsds;

  /// Specifies type of machine (name only) which has fixed number of vCPUs and
  /// fixed amount of memory. This also includes specifying custom machine type
  /// following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
  core.String machineType;

  /// Minimum cpu platform the reservation.
  core.String minCpuPlatform;

  AllocationSpecificSKUAllocationReservedInstanceProperties();

  AllocationSpecificSKUAllocationReservedInstanceProperties.fromJson(
      core.Map _json) {
    if (_json.containsKey("guestAccelerators")) {
      guestAccelerators = (_json["guestAccelerators"] as core.List)
          .map<AcceleratorConfig>(
              (value) => new AcceleratorConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("localSsds")) {
      localSsds = (_json["localSsds"] as core.List)
          .map<AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk>(
              (value) =>
                  new AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
                      .fromJson(value))
          .toList();
    }
    if (_json.containsKey("machineType")) {
      machineType = _json["machineType"];
    }
    if (_json.containsKey("minCpuPlatform")) {
      minCpuPlatform = _json["minCpuPlatform"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (guestAccelerators != null) {
      _json["guestAccelerators"] =
          guestAccelerators.map((value) => (value).toJson()).toList();
    }
    if (localSsds != null) {
      _json["localSsds"] = localSsds.map((value) => (value).toJson()).toList();
    }
    if (machineType != null) {
      _json["machineType"] = machineType;
    }
    if (minCpuPlatform != null) {
      _json["minCpuPlatform"] = minCpuPlatform;
    }
    return _json;
  }
}

/// This reservation type allows to pre allocate specific instance
/// configuration.
class AllocationSpecificSKUReservation {
  /// Specifies the number of resources that are allocated.
  core.String count;

  /// [Output Only] Indicates how many instances are in use.
  core.String inUseCount;

  /// The instance properties for the reservation.
  AllocationSpecificSKUAllocationReservedInstanceProperties instanceProperties;

  AllocationSpecificSKUReservation();

  AllocationSpecificSKUReservation.fromJson(core.Map _json) {
    if (_json.containsKey("count")) {
      count = _json["count"];
    }
    if (_json.containsKey("inUseCount")) {
      inUseCount = _json["inUseCount"];
    }
    if (_json.containsKey("instanceProperties")) {
      instanceProperties =
          new AllocationSpecificSKUAllocationReservedInstanceProperties
              .fromJson(_json["instanceProperties"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (count != null) {
      _json["count"] = count;
    }
    if (inUseCount != null) {
      _json["inUseCount"] = inUseCount;
    }
    if (instanceProperties != null) {
      _json["instanceProperties"] = (instanceProperties).toJson();
    }
    return _json;
  }
}

/// An instance-attached disk resource.
class AttachedDisk {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool autoDelete;

  /// Indicates that this is a boot disk. The virtual machine will use the first
  /// partition of the disk for its root filesystem.
  core.bool boot;

  /// Specifies a unique device name of your choice that is reflected into the
  /// /dev/disk/by-id/google-* tree of a Linux operating system running within
  /// the instance. This name can be used to reference the device for mounting,
  /// resizing, and so on, from within the instance.
  ///
  /// If not specified, the server chooses a default device name to apply to
  /// this disk, in the form persistent-disk-x, where x is a number assigned by
  /// Google Compute Engine. This field is only applicable for persistent disks.
  core.String deviceName;

  /// Encrypts or decrypts a disk using a customer-supplied encryption key.
  ///
  /// If you are creating a new disk, this field encrypts the new disk using an
  /// encryption key that you provide. If you are attaching an existing disk
  /// that is already encrypted, this field decrypts the disk using the
  /// customer-supplied encryption key.
  ///
  /// If you encrypt a disk using a customer-supplied key, you must provide the
  /// same key again when you attempt to use this resource at a later time. For
  /// example, you must provide the key when you create a snapshot or an image
  /// from the disk or when you attach the disk to a virtual machine instance.
  ///
  /// If you do not provide an encryption key, then the disk will be encrypted
  /// using an automatically generated key and you do not need to provide a key
  /// to use the disk later.
  ///
  /// Instance templates do not store customer-supplied encryption keys, so you
  /// cannot use your own keys to encrypt disks in a managed instance group.
  CustomerEncryptionKey diskEncryptionKey;

  /// The size of the disk in GB.
  core.String diskSizeGb;

  /// A list of features to enable on the guest operating system. Applicable
  /// only for bootable images. Read  Enabling guest operating system features
  /// to see a list of available options.
  core.List<GuestOsFeature> guestOsFeatures;

  /// [Output Only] A zero-based index to this disk, where 0 is reserved for the
  /// boot disk. If you have many disks attached to an instance, each disk would
  /// have a unique index number.
  core.int index;

  /// [Input Only] Specifies the parameters for a new disk that will be created
  /// alongside the new instance. Use initialization parameters to create boot
  /// disks or local SSDs attached to the new instance.
  ///
  /// This property is mutually exclusive with the source property; you can only
  /// define one or the other, but not both.
  AttachedDiskInitializeParams initializeParams;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME. The default is SCSI. Persistent disks must always use
  /// SCSI and the request will fail if you attempt to attach a persistent disk
  /// in any other format than SCSI. Local SSDs can use either NVME or SCSI. For
  /// performance characteristics of SCSI over NVMe, see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String interface;

  /// [Output Only] Type of the resource. Always compute#attachedDisk for
  /// attached disks.
  core.String kind;

  /// [Output Only] Any valid publicly visible licenses.
  core.List<core.String> licenses;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
  /// not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY"
  /// - "READ_WRITE"
  core.String mode;

  /// [Output Only] shielded vm initial state stored on disk
  InitialStateConfig shieldedInstanceInitialState;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource. When creating a new instance, one of
  /// initializeParams.sourceImage or initializeParams.sourceSnapshot or
  /// disks.source is required except for local SSD.
  ///
  /// If desired, you can also attach existing non-root persistent disks using
  /// this property. This field is only applicable for persistent disks.
  ///
  /// Note that for InstanceTemplate, specify the disk name, not the URL for the
  /// disk.
  core.String source;

  /// Specifies the type of the disk, either SCRATCH or PERSISTENT. If not
  /// specified, the default is PERSISTENT.
  /// Possible string values are:
  /// - "PERSISTENT"
  /// - "SCRATCH"
  core.String type;

  AttachedDisk();

  AttachedDisk.fromJson(core.Map _json) {
    if (_json.containsKey("autoDelete")) {
      autoDelete = _json["autoDelete"];
    }
    if (_json.containsKey("boot")) {
      boot = _json["boot"];
    }
    if (_json.containsKey("deviceName")) {
      deviceName = _json["deviceName"];
    }
    if (_json.containsKey("diskEncryptionKey")) {
      diskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["diskEncryptionKey"]);
    }
    if (_json.containsKey("diskSizeGb")) {
      diskSizeGb = _json["diskSizeGb"];
    }
    if (_json.containsKey("guestOsFeatures")) {
      guestOsFeatures = (_json["guestOsFeatures"] as core.List)
          .map<GuestOsFeature>((value) => new GuestOsFeature.fromJson(value))
          .toList();
    }
    if (_json.containsKey("index")) {
      index = _json["index"];
    }
    if (_json.containsKey("initializeParams")) {
      initializeParams =
          new AttachedDiskInitializeParams.fromJson(_json["initializeParams"]);
    }
    if (_json.containsKey("interface")) {
      interface = _json["interface"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("licenses")) {
      licenses = (_json["licenses"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("mode")) {
      mode = _json["mode"];
    }
    if (_json.containsKey("shieldedInstanceInitialState")) {
      shieldedInstanceInitialState = new InitialStateConfig.fromJson(
          _json["shieldedInstanceInitialState"]);
    }
    if (_json.containsKey("source")) {
      source = _json["source"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoDelete != null) {
      _json["autoDelete"] = autoDelete;
    }
    if (boot != null) {
      _json["boot"] = boot;
    }
    if (deviceName != null) {
      _json["deviceName"] = deviceName;
    }
    if (diskEncryptionKey != null) {
      _json["diskEncryptionKey"] = (diskEncryptionKey).toJson();
    }
    if (diskSizeGb != null) {
      _json["diskSizeGb"] = diskSizeGb;
    }
    if (guestOsFeatures != null) {
      _json["guestOsFeatures"] =
          guestOsFeatures.map((value) => (value).toJson()).toList();
    }
    if (index != null) {
      _json["index"] = index;
    }
    if (initializeParams != null) {
      _json["initializeParams"] = (initializeParams).toJson();
    }
    if (interface != null) {
      _json["interface"] = interface;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (licenses != null) {
      _json["licenses"] = licenses;
    }
    if (mode != null) {
      _json["mode"] = mode;
    }
    if (shieldedInstanceInitialState != null) {
      _json["shieldedInstanceInitialState"] =
          (shieldedInstanceInitialState).toJson();
    }
    if (source != null) {
      _json["source"] = source;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

/// [Input Only] Specifies the parameters for a new disk that will be created
/// alongside the new instance. Use initialization parameters to create boot
/// disks or local SSDs attached to the new instance.
///
/// This property is mutually exclusive with the source property; you can only
/// define one or the other, but not both.
class AttachedDiskInitializeParams {
  /// An optional description. Provide this property when creating the disk.
  core.String description;

  /// Specifies the disk name. If not specified, the default is to use the name
  /// of the instance. If a disk with the same name already exists in the given
  /// region, the existing disk is attached to the new instance and the new disk
  /// is not created.
  core.String diskName;

  /// Specifies the size of the disk in base-2 GB. The size must be at least 10
  /// GB. If you specify a sourceImage, which is required for boot disks, the
  /// default size is the size of the sourceImage. If you do not specify a
  /// sourceImage, the default disk size is 500 GB.
  core.String diskSizeGb;

  /// Specifies the disk type to use to create the instance. If not specified,
  /// the default is pd-standard, specified using the full URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/pd-standard
  ///
  ///
  /// Other values include pd-ssd and local-ssd. If you define this field, you
  /// can provide either the full or partial URL. For example, the following are
  /// valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/diskType
  /// - projects/project/zones/zone/diskTypes/diskType
  /// - zones/zone/diskTypes/diskType  Note that for InstanceTemplate, this is
  /// the name of the disk type, not URL.
  core.String diskType;

  /// Labels to apply to this disk. These can be later modified by the
  /// disks.setLabels method. This field is only applicable for persistent
  /// disks.
  core.Map<core.String, core.String> labels;

  /// Specifies which action to take on instance update with this disk. Default
  /// is to use the existing disk.
  /// Possible string values are:
  /// - "RECREATE_DISK"
  /// - "RECREATE_DISK_IF_SOURCE_CHANGED"
  /// - "USE_EXISTING_DISK"
  core.String onUpdateAction;

  /// Resource policies applied to this disk for automatic snapshot creations.
  /// Specified using the full or partial URL. For instance template, specify
  /// only the resource policy name.
  core.List<core.String> resourcePolicies;

  /// The source image to create this disk. When creating a new instance, one of
  /// initializeParams.sourceImage or initializeParams.sourceSnapshot or
  /// disks.source is required except for local SSD.
  ///
  /// To create a disk with one of the public operating system images, specify
  /// the image by its family name. For example, specify family/debian-9 to use
  /// the latest Debian 9 image:
  /// projects/debian-cloud/global/images/family/debian-9
  ///
  ///
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD
  ///
  ///
  /// To create a disk with a custom image that you created, specify the image
  /// name in the following format:
  /// global/images/my-custom-image
  ///
  ///
  /// You can also specify a custom image by its image family, which returns the
  /// latest version of the image in that family. Replace the image name with
  /// family/family-name:
  /// global/images/family/my-image-family
  ///
  ///
  /// If the source image is deleted later, this field will not be set.
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  ///
  /// Instance templates do not store customer-supplied encryption keys, so you
  /// cannot create disks for instances in a managed instance group if the
  /// source images are encrypted with your own keys.
  CustomerEncryptionKey sourceImageEncryptionKey;

  /// The source snapshot to create this disk. When creating a new instance, one
  /// of initializeParams.sourceSnapshot or initializeParams.sourceImage or
  /// disks.source is required except for local SSD.
  ///
  /// To create a disk with a snapshot that you created, specify the snapshot
  /// name in the following format:
  /// global/snapshots/my-backup
  ///
  ///
  /// If the source snapshot is deleted later, this field will not be set.
  core.String sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot.
  CustomerEncryptionKey sourceSnapshotEncryptionKey;

  AttachedDiskInitializeParams();

  AttachedDiskInitializeParams.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("diskName")) {
      diskName = _json["diskName"];
    }
    if (_json.containsKey("diskSizeGb")) {
      diskSizeGb = _json["diskSizeGb"];
    }
    if (_json.containsKey("diskType")) {
      diskType = _json["diskType"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("onUpdateAction")) {
      onUpdateAction = _json["onUpdateAction"];
    }
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("sourceImage")) {
      sourceImage = _json["sourceImage"];
    }
    if (_json.containsKey("sourceImageEncryptionKey")) {
      sourceImageEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceImageEncryptionKey"]);
    }
    if (_json.containsKey("sourceSnapshot")) {
      sourceSnapshot = _json["sourceSnapshot"];
    }
    if (_json.containsKey("sourceSnapshotEncryptionKey")) {
      sourceSnapshotEncryptionKey = new CustomerEncryptionKey.fromJson(
          _json["sourceSnapshotEncryptionKey"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (diskName != null) {
      _json["diskName"] = diskName;
    }
    if (diskSizeGb != null) {
      _json["diskSizeGb"] = diskSizeGb;
    }
    if (diskType != null) {
      _json["diskType"] = diskType;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (onUpdateAction != null) {
      _json["onUpdateAction"] = onUpdateAction;
    }
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    if (sourceImage != null) {
      _json["sourceImage"] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json["sourceImageEncryptionKey"] = (sourceImageEncryptionKey).toJson();
    }
    if (sourceSnapshot != null) {
      _json["sourceSnapshot"] = sourceSnapshot;
    }
    if (sourceSnapshotEncryptionKey != null) {
      _json["sourceSnapshotEncryptionKey"] =
          (sourceSnapshotEncryptionKey).toJson();
    }
    return _json;
  }
}

/// Specifies the audit configuration for a service. The configuration
/// determines which permission types are logged, and what identities, if any,
/// are exempted from logging. An AuditConfig must have one or more
/// AuditLogConfigs.
///
/// If there are AuditConfigs for both `allServices` and a specific service, the
/// union of the two AuditConfigs is used for that service: the log_types
/// specified in each AuditConfig are enabled, and the exempted_members in each
/// AuditLogConfig are exempted.
///
/// Example Policy with multiple AuditConfigs:
///
/// { "audit_configs": [ { "service": "allServices" "audit_log_configs": [ {
/// "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] },
/// { "log_type": "DATA_WRITE", }, { "log_type": "ADMIN_READ", } ] }, {
/// "service": "sampleservice.googleapis.com" "audit_log_configs": [ {
/// "log_type": "DATA_READ", }, { "log_type": "DATA_WRITE", "exempted_members":
/// [ "user:aliya@example.com" ] } ] } ] }
///
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts jose@example.com from DATA_READ logging, and
/// aliya@example.com from DATA_WRITE logging.
class AuditConfig {
  /// The configuration for logging of each type of permission.
  core.List<AuditLogConfig> auditLogConfigs;
  core.List<core.String> exemptedMembers;

  /// Specifies a service that will be enabled for audit logging. For example,
  /// `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
  /// special value that covers all services.
  core.String service;

  AuditConfig();

  AuditConfig.fromJson(core.Map _json) {
    if (_json.containsKey("auditLogConfigs")) {
      auditLogConfigs = (_json["auditLogConfigs"] as core.List)
          .map<AuditLogConfig>((value) => new AuditLogConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("exemptedMembers")) {
      exemptedMembers =
          (_json["exemptedMembers"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (auditLogConfigs != null) {
      _json["auditLogConfigs"] =
          auditLogConfigs.map((value) => (value).toJson()).toList();
    }
    if (exemptedMembers != null) {
      _json["exemptedMembers"] = exemptedMembers;
    }
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

/// Provides the configuration for logging a type of permissions. Example:
///
/// { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
/// "user:jose@example.com" ] }, { "log_type": "DATA_WRITE", } ] }
///
/// This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
/// jose@example.com from DATA_READ logging.
class AuditLogConfig {
  /// Specifies the identities that do not cause logging for this type of
  /// permission. Follows the same format of [Binding.members][].
  core.List<core.String> exemptedMembers;
  core.bool ignoreChildExemptions;

  /// The log type that this config enables.
  /// Possible string values are:
  /// - "ADMIN_READ"
  /// - "DATA_READ"
  /// - "DATA_WRITE"
  /// - "LOG_TYPE_UNSPECIFIED"
  core.String logType;

  AuditLogConfig();

  AuditLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey("exemptedMembers")) {
      exemptedMembers =
          (_json["exemptedMembers"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("ignoreChildExemptions")) {
      ignoreChildExemptions = _json["ignoreChildExemptions"];
    }
    if (_json.containsKey("logType")) {
      logType = _json["logType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (exemptedMembers != null) {
      _json["exemptedMembers"] = exemptedMembers;
    }
    if (ignoreChildExemptions != null) {
      _json["ignoreChildExemptions"] = ignoreChildExemptions;
    }
    if (logType != null) {
      _json["logType"] = logType;
    }
    return _json;
  }
}

/// Authorization-related information used by Cloud Audit Logging.
class AuthorizationLoggingOptions {
  /// The type of the permission that was checked.
  /// Possible string values are:
  /// - "ADMIN_READ"
  /// - "ADMIN_WRITE"
  /// - "DATA_READ"
  /// - "DATA_WRITE"
  /// - "PERMISSION_TYPE_UNSPECIFIED"
  core.String permissionType;

  AuthorizationLoggingOptions();

  AuthorizationLoggingOptions.fromJson(core.Map _json) {
    if (_json.containsKey("permissionType")) {
      permissionType = _json["permissionType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (permissionType != null) {
      _json["permissionType"] = permissionType;
    }
    return _json;
  }
}

/// Represents an Autoscaler resource.
///
/// Google Compute Engine has two Autoscaler resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/autoscalers) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionAutoscalers)
///
/// Use autoscalers to automatically add or delete instances from a managed
/// instance group according to your defined autoscaling policy. For more
/// information, read Autoscaling Groups of Instances.
///
/// For zonal managed instance groups resource, use the autoscaler resource.
///
/// For regional managed instance groups, use the regionAutoscalers resource.
/// (== resource_for {$api_version}.autoscalers ==) (== resource_for
/// {$api_version}.regionAutoscalers ==)
class Autoscaler {
  /// The configuration parameters for the autoscaling algorithm. You can define
  /// one or more of the policies for an autoscaler: cpuUtilization,
  /// customMetricUtilizations, and loadBalancingUtilization.
  ///
  /// If none of these are specified, the default will be to autoscale based on
  /// cpuUtilization to 0.6 or 60%.
  AutoscalingPolicy autoscalingPolicy;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#autoscaler for
  /// autoscalers.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Target recommended MIG size (number of instances) computed
  /// by autoscaler. Autoscaler calculates recommended MIG size even when
  /// autoscaling policy mode is different from ON. This field is empty when
  /// autoscaler is not connected to the existing managed instance group or
  /// autoscaler did not generate its prediction.
  core.int recommendedSize;

  /// [Output Only] URL of the region where the instance group resides (for
  /// autoscalers living in regional scope).
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the autoscaler configuration. Current set of
  /// possible values:
  /// - PENDING: Autoscaler backend hasn't read new/updated configuration.
  /// - DELETING: Configuration is being deleted.
  /// - ACTIVE: Configuration is acknowledged to be effective. Some warnings
  /// might be present in the statusDetails field.
  /// - ERROR: Configuration has errors. Actionable for users. Details are
  /// present in the statusDetails field.  New values might be added in the
  /// future.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DELETING"
  /// - "ERROR"
  /// - "PENDING"
  core.String status;

  /// [Output Only] Human-readable details about the current state of the
  /// autoscaler. Read the documentation for Commonly returned status messages
  /// for examples of status messages you might encounter.
  core.List<AutoscalerStatusDetails> statusDetails;

  /// URL of the managed instance group that this autoscaler will scale.
  core.String target;

  /// [Output Only] URL of the zone where the instance group resides (for
  /// autoscalers living in zonal scope).
  core.String zone;

  Autoscaler();

  Autoscaler.fromJson(core.Map _json) {
    if (_json.containsKey("autoscalingPolicy")) {
      autoscalingPolicy =
          new AutoscalingPolicy.fromJson(_json["autoscalingPolicy"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("recommendedSize")) {
      recommendedSize = _json["recommendedSize"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusDetails")) {
      statusDetails = (_json["statusDetails"] as core.List)
          .map<AutoscalerStatusDetails>(
              (value) => new AutoscalerStatusDetails.fromJson(value))
          .toList();
    }
    if (_json.containsKey("target")) {
      target = _json["target"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoscalingPolicy != null) {
      _json["autoscalingPolicy"] = (autoscalingPolicy).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (recommendedSize != null) {
      _json["recommendedSize"] = recommendedSize;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusDetails != null) {
      _json["statusDetails"] =
          statusDetails.map((value) => (value).toJson()).toList();
    }
    if (target != null) {
      _json["target"] = target;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class AutoscalerAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalerAggregatedListWarningData();

  AutoscalerAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AutoscalerAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalerAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalerAggregatedListWarning();

  AutoscalerAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AutoscalerAggregatedListWarningData>((value) =>
              new AutoscalerAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AutoscalerAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AutoscalersScopedList resources.
  core.Map<core.String, AutoscalersScopedList> items;

  /// [Output Only] Type of resource. Always compute#autoscalerAggregatedList
  /// for aggregated lists of autoscalers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AutoscalerAggregatedListWarning warning;

  AutoscalerAggregatedList();

  AutoscalerAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, AutoscalersScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new AutoscalersScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AutoscalerAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<AutoscalersScopedList, core.Map<core.String, core.Object>>(
              items, (AutoscalersScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AutoscalerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalerListWarningData();

  AutoscalerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AutoscalerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalerListWarning();

  AutoscalerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AutoscalerListWarningData>(
              (value) => new AutoscalerListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Autoscaler resources.
class AutoscalerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler> items;

  /// [Output Only] Type of resource. Always compute#autoscalerList for lists of
  /// autoscalers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AutoscalerListWarning warning;

  AutoscalerList();

  AutoscalerList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Autoscaler>((value) => new Autoscaler.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new AutoscalerListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class AutoscalerStatusDetails {
  /// The status message.
  core.String message;

  /// The type of error, warning, or notice returned. Current set of possible
  /// values:
  /// - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance group
  /// are unhealthy (not in RUNNING state).
  /// - BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service
  /// attached to the instance group.
  /// - CAPPED_AT_MAX_NUM_REPLICAS (WARNING): Autoscaler recommends a size
  /// greater than maxNumReplicas.
  /// - CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric
  /// samples are not exported often enough to be a credible base for
  /// autoscaling.
  /// - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does
  /// not exist or does not have the necessary labels.
  /// - MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas.
  /// This means the autoscaler cannot add or remove instances from the instance
  /// group.
  /// - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not
  /// receive any data from the custom metric configured for autoscaling.
  /// - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is
  /// configured to scale based on a load balancing signal but the instance
  /// group has not received any requests from the load balancer.
  /// - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances
  /// in the group won't change automatically. The autoscaling configuration is
  /// preserved.
  /// - MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only up" mode.
  /// The autoscaler can add instances but not remove any.
  /// - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be
  /// autoscaled because it has more than one backend service attached to it.
  /// - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the
  /// necessary resources, such as CPU or number of instances.
  /// - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers:
  /// there is a resource stockout in the chosen region.
  /// - SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not
  /// exist.
  /// - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR): Autoscaling
  /// does not work with an HTTP/S load balancer that has been configured for
  /// maxRate.
  /// - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal autoscalers: there is a
  /// resource stockout in the chosen zone. For regional autoscalers: in at
  /// least one of the zones you're using there is a resource stockout.  New
  /// values might be added in the future. Some of the values might not be
  /// available in all API versions.
  /// Possible string values are:
  /// - "ALL_INSTANCES_UNHEALTHY"
  /// - "BACKEND_SERVICE_DOES_NOT_EXIST"
  /// - "CAPPED_AT_MAX_NUM_REPLICAS"
  /// - "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE"
  /// - "CUSTOM_METRIC_INVALID"
  /// - "MIN_EQUALS_MAX"
  /// - "MISSING_CUSTOM_METRIC_DATA_POINTS"
  /// - "MISSING_LOAD_BALANCING_DATA_POINTS"
  /// - "MODE_OFF"
  /// - "MODE_ONLY_UP"
  /// - "MORE_THAN_ONE_BACKEND_SERVICE"
  /// - "NOT_ENOUGH_QUOTA_AVAILABLE"
  /// - "REGION_RESOURCE_STOCKOUT"
  /// - "SCALING_TARGET_DOES_NOT_EXIST"
  /// - "UNKNOWN"
  /// - "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION"
  /// - "ZONE_RESOURCE_STOCKOUT"
  core.String type;

  AutoscalerStatusDetails();

  AutoscalerStatusDetails.fromJson(core.Map _json) {
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (message != null) {
      _json["message"] = message;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class AutoscalersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalersScopedListWarningData();

  AutoscalersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of autoscalers
/// when the list is empty.
class AutoscalersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalersScopedListWarning();

  AutoscalersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<AutoscalersScopedListWarningData>(
              (value) => new AutoscalersScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class AutoscalersScopedList {
  /// [Output Only] A list of autoscalers contained in this scope.
  core.List<Autoscaler> autoscalers;

  /// [Output Only] Informational warning which replaces the list of autoscalers
  /// when the list is empty.
  AutoscalersScopedListWarning warning;

  AutoscalersScopedList();

  AutoscalersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("autoscalers")) {
      autoscalers = (_json["autoscalers"] as core.List)
          .map<Autoscaler>((value) => new Autoscaler.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new AutoscalersScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoscalers != null) {
      _json["autoscalers"] =
          autoscalers.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Cloud Autoscaler policy.
class AutoscalingPolicy {
  /// The number of seconds that the autoscaler should wait before it starts
  /// collecting information from a new instance. This prevents the autoscaler
  /// from collecting information when the instance is initializing, during
  /// which the collected usage would not be reliable. The default time
  /// autoscaler waits is 60 seconds.
  ///
  /// Virtual machine initialization times might vary because of numerous
  /// factors. We recommend that you test how long an instance may take to
  /// initialize. To do this, create an instance and time the startup process.
  core.int coolDownPeriodSec;

  /// Defines the CPU utilization policy that allows the autoscaler to scale
  /// based on the average CPU utilization of a managed instance group.
  AutoscalingPolicyCpuUtilization cpuUtilization;

  /// Configuration parameters of autoscaling based on a custom metric.
  core.List<AutoscalingPolicyCustomMetricUtilization> customMetricUtilizations;

  /// Configuration parameters of autoscaling based on load balancer.
  AutoscalingPolicyLoadBalancingUtilization loadBalancingUtilization;

  /// The maximum number of instances that the autoscaler can scale up to. This
  /// is required when creating or updating an autoscaler. The maximum number of
  /// replicas should not be lower than minimal number of replicas.
  core.int maxNumReplicas;

  /// The minimum number of replicas that the autoscaler can scale down to. This
  /// cannot be less than 0. If not provided, autoscaler will choose a default
  /// value depending on maximum number of instances allowed.
  core.int minNumReplicas;

  /// Defines operating mode for this policy.
  /// Possible string values are:
  /// - "OFF"
  /// - "ON"
  /// - "ONLY_UP"
  core.String mode;

  AutoscalingPolicy();

  AutoscalingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("coolDownPeriodSec")) {
      coolDownPeriodSec = _json["coolDownPeriodSec"];
    }
    if (_json.containsKey("cpuUtilization")) {
      cpuUtilization =
          new AutoscalingPolicyCpuUtilization.fromJson(_json["cpuUtilization"]);
    }
    if (_json.containsKey("customMetricUtilizations")) {
      customMetricUtilizations =
          (_json["customMetricUtilizations"] as core.List)
              .map<AutoscalingPolicyCustomMetricUtilization>((value) =>
                  new AutoscalingPolicyCustomMetricUtilization.fromJson(value))
              .toList();
    }
    if (_json.containsKey("loadBalancingUtilization")) {
      loadBalancingUtilization =
          new AutoscalingPolicyLoadBalancingUtilization.fromJson(
              _json["loadBalancingUtilization"]);
    }
    if (_json.containsKey("maxNumReplicas")) {
      maxNumReplicas = _json["maxNumReplicas"];
    }
    if (_json.containsKey("minNumReplicas")) {
      minNumReplicas = _json["minNumReplicas"];
    }
    if (_json.containsKey("mode")) {
      mode = _json["mode"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (coolDownPeriodSec != null) {
      _json["coolDownPeriodSec"] = coolDownPeriodSec;
    }
    if (cpuUtilization != null) {
      _json["cpuUtilization"] = (cpuUtilization).toJson();
    }
    if (customMetricUtilizations != null) {
      _json["customMetricUtilizations"] =
          customMetricUtilizations.map((value) => (value).toJson()).toList();
    }
    if (loadBalancingUtilization != null) {
      _json["loadBalancingUtilization"] = (loadBalancingUtilization).toJson();
    }
    if (maxNumReplicas != null) {
      _json["maxNumReplicas"] = maxNumReplicas;
    }
    if (minNumReplicas != null) {
      _json["minNumReplicas"] = minNumReplicas;
    }
    if (mode != null) {
      _json["mode"] = mode;
    }
    return _json;
  }
}

/// CPU utilization policy.
class AutoscalingPolicyCpuUtilization {
  /// The target CPU utilization that the autoscaler should maintain. Must be a
  /// float value in the range (0, 1]. If not specified, the default is 0.6.
  ///
  /// If the CPU level is below the target utilization, the autoscaler scales
  /// down the number of instances until it reaches the minimum number of
  /// instances you specified or until the average CPU of your instances reaches
  /// the target utilization.
  ///
  /// If the average CPU is above the target utilization, the autoscaler scales
  /// up until it reaches the maximum number of instances you specified or until
  /// the average utilization reaches the target utilization.
  core.double utilizationTarget;

  AutoscalingPolicyCpuUtilization();

  AutoscalingPolicyCpuUtilization.fromJson(core.Map _json) {
    if (_json.containsKey("utilizationTarget")) {
      utilizationTarget = _json["utilizationTarget"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (utilizationTarget != null) {
      _json["utilizationTarget"] = utilizationTarget;
    }
    return _json;
  }
}

/// Custom utilization metric policy.
class AutoscalingPolicyCustomMetricUtilization {
  /// The identifier (type) of the Stackdriver Monitoring metric. The metric
  /// cannot have negative values.
  ///
  /// The metric must have a value type of INT64 or DOUBLE.
  core.String metric;

  /// The target value of the metric that autoscaler should maintain. This must
  /// be a positive value. A utilization metric scales number of virtual
  /// machines handling requests to increase or decrease proportionally to the
  /// metric.
  ///
  /// For example, a good metric to use as a utilization_target is
  /// compute.googleapis.com/instance/network/received_bytes_count. The
  /// autoscaler will work to keep this value constant for each of the
  /// instances.
  core.double utilizationTarget;

  /// Defines how target utilization value is expressed for a Stackdriver
  /// Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
  /// Possible string values are:
  /// - "DELTA_PER_MINUTE"
  /// - "DELTA_PER_SECOND"
  /// - "GAUGE"
  core.String utilizationTargetType;

  AutoscalingPolicyCustomMetricUtilization();

  AutoscalingPolicyCustomMetricUtilization.fromJson(core.Map _json) {
    if (_json.containsKey("metric")) {
      metric = _json["metric"];
    }
    if (_json.containsKey("utilizationTarget")) {
      utilizationTarget = _json["utilizationTarget"].toDouble();
    }
    if (_json.containsKey("utilizationTargetType")) {
      utilizationTargetType = _json["utilizationTargetType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (metric != null) {
      _json["metric"] = metric;
    }
    if (utilizationTarget != null) {
      _json["utilizationTarget"] = utilizationTarget;
    }
    if (utilizationTargetType != null) {
      _json["utilizationTargetType"] = utilizationTargetType;
    }
    return _json;
  }
}

/// Configuration parameters of autoscaling based on load balancing.
class AutoscalingPolicyLoadBalancingUtilization {
  /// Fraction of backend capacity utilization (set in HTTP(S) load balancing
  /// configuration) that autoscaler should maintain. Must be a positive float
  /// value. If not defined, the default is 0.8.
  core.double utilizationTarget;

  AutoscalingPolicyLoadBalancingUtilization();

  AutoscalingPolicyLoadBalancingUtilization.fromJson(core.Map _json) {
    if (_json.containsKey("utilizationTarget")) {
      utilizationTarget = _json["utilizationTarget"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (utilizationTarget != null) {
      _json["utilizationTarget"] = utilizationTarget;
    }
    return _json;
  }
}

/// Message containing information of one individual backend.
class Backend {
  /// Specifies the balancing mode for the backend.
  ///
  /// When choosing a balancing mode, you need to consider the
  /// loadBalancingScheme, and protocol for the backend service, as well as the
  /// type of backend (instance group or NEG).
  ///
  ///
  /// - If the load balancing mode is CONNECTION, then the load is spread based
  /// on how many concurrent connections the backend can handle.
  /// You can use the CONNECTION balancing mode if the protocol for the backend
  /// service is SSL, TCP, or UDP.
  ///
  /// If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy
  /// and TCP Proxy load balancers), you must also specify exactly one of the
  /// following parameters: maxConnections (except for regional managed instance
  /// groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
  ///
  /// If the loadBalancingScheme for the backend service is INTERNAL (internal
  /// TCP/UDP load balancers), you cannot specify any additional parameters.
  ///
  /// - If the load balancing mode is RATE, the load is spread based on the rate
  /// of HTTP requests per second (RPS).
  /// You can use the RATE balancing mode if the protocol for the backend
  /// service is HTTP or HTTPS. You must specify exactly one of the following
  /// parameters: maxRate (except for regional managed instance groups),
  /// maxRatePerInstance, or maxRatePerEndpoint.
  ///
  /// - If the load balancing mode is UTILIZATION, the load is spread based on
  /// the backend utilization of instances in an instance group.
  /// You can use the UTILIZATION balancing mode if the loadBalancingScheme of
  /// the backend service is EXTERNAL, INTERNAL_SELF_MANAGED, or
  /// INTERNAL_MANAGED and the backends are instance groups. There are no
  /// restrictions on the backend service protocol.
  /// Possible string values are:
  /// - "CONNECTION"
  /// - "RATE"
  /// - "UTILIZATION"
  core.String balancingMode;

  /// A multiplier applied to the group's maximum servicing capacity (based on
  /// UTILIZATION, RATE or CONNECTION). Default value is 1, which means the
  /// group will serve up to 100% of its configured capacity (depending on
  /// balancingMode). A setting of 0 means the group is completely drained,
  /// offering 0% of its available Capacity. Valid range is [0.0,1.0].
  ///
  /// This cannot be used for internal load balancing.
  core.double capacityScaler;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// This field designates whether this is a failover backend. More than one
  /// failover backend can be configured for a given BackendService.
  core.bool failover;

  /// The fully-qualified URL of an instance group or network endpoint group
  /// (NEG) resource. The type of backend that a backend service supports
  /// depends on the backend service's loadBalancingScheme.
  ///
  ///
  /// - When the loadBalancingScheme for the backend service is EXTERNAL,
  /// INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the backend can be either an
  /// instance group or a NEG. The backends on the backend service must be
  /// either all instance groups or all NEGs. You cannot mix instance group and
  /// NEG backends on the same backend service.
  ///
  ///
  /// - When the loadBalancingScheme for the backend service is INTERNAL, the
  /// backend must be an instance group in the same region as the backend
  /// service. NEGs are not supported.
  ///
  /// You must use the fully-qualified URL (starting with
  /// https://www.googleapis.com/) to specify the instance group or NEG. Partial
  /// URLs are not supported.
  core.String group;

  /// Defines a target maximum number of simultaneous connections that the
  /// backend can handle. Valid for network endpoint group and instance group
  /// backends (except for regional managed instance groups). If the backend's
  /// balancingMode is UTILIZATION, this is an optional parameter. If the
  /// backend's balancingMode is CONNECTION, and backend is attached to a
  /// backend service whose loadBalancingScheme is EXTERNAL, you must specify
  /// either this parameter, maxConnectionsPerInstance, or
  /// maxConnectionsPerEndpoint.
  ///
  /// Not available if the backend's balancingMode is RATE. If the
  /// loadBalancingScheme is INTERNAL, then maxConnections is not supported,
  /// even though the backend requires a balancing mode of CONNECTION.
  core.int maxConnections;

  /// Defines a target maximum number of simultaneous connections for an
  /// endpoint of a NEG. This is multiplied by the number of endpoints in the
  /// NEG to implicitly calculate a maximum number of target maximum
  /// simultaneous connections for the NEG. If the backend's balancingMode is
  /// CONNECTION, and the backend is attached to a backend service whose
  /// loadBalancingScheme is EXTERNAL, you must specify either this parameter,
  /// maxConnections, or maxConnectionsPerInstance.
  ///
  /// Not available if the backend's balancingMode is RATE. Internal TCP/UDP
  /// load balancing does not support setting maxConnectionsPerEndpoint even
  /// though its backends require a balancing mode of CONNECTION.
  core.int maxConnectionsPerEndpoint;

  /// Defines a target maximum number of simultaneous connections for a single
  /// VM in a backend instance group. This is multiplied by the number of
  /// instances in the instance group to implicitly calculate a target maximum
  /// number of simultaneous connections for the whole instance group. If the
  /// backend's balancingMode is UTILIZATION, this is an optional parameter. If
  /// the backend's balancingMode is CONNECTION, and backend is attached to a
  /// backend service whose loadBalancingScheme is EXTERNAL, you must specify
  /// either this parameter, maxConnections, or maxConnectionsPerEndpoint.
  ///
  /// Not available if the backend's balancingMode is RATE. Internal TCP/UDP
  /// load balancing does not support setting maxConnectionsPerInstance even
  /// though its backends require a balancing mode of CONNECTION.
  core.int maxConnectionsPerInstance;

  /// Defines a maximum number of HTTP requests per second (RPS) that the
  /// backend can handle. Valid for network endpoint group and instance group
  /// backends (except for regional managed instance groups). Must not be
  /// defined if the backend is a managed instance group that uses autoscaling
  /// based on load balancing.
  ///
  /// If the backend's balancingMode is UTILIZATION, this is an optional
  /// parameter. If the backend's balancingMode is RATE, you must specify
  /// maxRate, maxRatePerInstance, or maxRatePerEndpoint.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.int maxRate;

  /// Defines a maximum target for requests per second (RPS) for an endpoint of
  /// a NEG. This is multiplied by the number of endpoints in the NEG to
  /// implicitly calculate a target maximum rate for the NEG.
  ///
  /// If the backend's balancingMode is RATE, you must specify either this
  /// parameter, maxRate (except for regional managed instance groups), or
  /// maxRatePerInstance.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.double maxRatePerEndpoint;

  /// Defines a maximum target for requests per second (RPS) for a single VM in
  /// a backend instance group. This is multiplied by the number of instances in
  /// the instance group to implicitly calculate a target maximum rate for the
  /// whole instance group.
  ///
  /// If the backend's balancingMode is UTILIZATION, this is an optional
  /// parameter. If the backend's balancingMode is RATE, you must specify either
  /// this parameter, maxRate (except for regional managed instance groups), or
  /// maxRatePerEndpoint.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.double maxRatePerInstance;

  /// Defines the maximum average backend utilization of a backend VM in an
  /// instance group. The valid range is [0.0, 1.0]. This is an optional
  /// parameter if the backend's balancingMode is UTILIZATION.
  ///
  /// This parameter can be used in conjunction with maxRate,
  /// maxRatePerInstance, maxConnections (except for regional managed instance
  /// groups), or maxConnectionsPerInstance.
  core.double maxUtilization;

  Backend();

  Backend.fromJson(core.Map _json) {
    if (_json.containsKey("balancingMode")) {
      balancingMode = _json["balancingMode"];
    }
    if (_json.containsKey("capacityScaler")) {
      capacityScaler = _json["capacityScaler"].toDouble();
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("failover")) {
      failover = _json["failover"];
    }
    if (_json.containsKey("group")) {
      group = _json["group"];
    }
    if (_json.containsKey("maxConnections")) {
      maxConnections = _json["maxConnections"];
    }
    if (_json.containsKey("maxConnectionsPerEndpoint")) {
      maxConnectionsPerEndpoint = _json["maxConnectionsPerEndpoint"];
    }
    if (_json.containsKey("maxConnectionsPerInstance")) {
      maxConnectionsPerInstance = _json["maxConnectionsPerInstance"];
    }
    if (_json.containsKey("maxRate")) {
      maxRate = _json["maxRate"];
    }
    if (_json.containsKey("maxRatePerEndpoint")) {
      maxRatePerEndpoint = _json["maxRatePerEndpoint"].toDouble();
    }
    if (_json.containsKey("maxRatePerInstance")) {
      maxRatePerInstance = _json["maxRatePerInstance"].toDouble();
    }
    if (_json.containsKey("maxUtilization")) {
      maxUtilization = _json["maxUtilization"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (balancingMode != null) {
      _json["balancingMode"] = balancingMode;
    }
    if (capacityScaler != null) {
      _json["capacityScaler"] = capacityScaler;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (failover != null) {
      _json["failover"] = failover;
    }
    if (group != null) {
      _json["group"] = group;
    }
    if (maxConnections != null) {
      _json["maxConnections"] = maxConnections;
    }
    if (maxConnectionsPerEndpoint != null) {
      _json["maxConnectionsPerEndpoint"] = maxConnectionsPerEndpoint;
    }
    if (maxConnectionsPerInstance != null) {
      _json["maxConnectionsPerInstance"] = maxConnectionsPerInstance;
    }
    if (maxRate != null) {
      _json["maxRate"] = maxRate;
    }
    if (maxRatePerEndpoint != null) {
      _json["maxRatePerEndpoint"] = maxRatePerEndpoint;
    }
    if (maxRatePerInstance != null) {
      _json["maxRatePerInstance"] = maxRatePerInstance;
    }
    if (maxUtilization != null) {
      _json["maxUtilization"] = maxUtilization;
    }
    return _json;
  }
}

/// Represents a Cloud Storage Bucket resource.
///
/// This Cloud Storage bucket resource is referenced by a URL map of a load
/// balancer. For more information, read Backend Buckets.
class BackendBucket {
  /// Cloud Storage bucket name.
  core.String bucketName;

  /// Cloud CDN configuration for this BackendBucket.
  BackendBucketCdnPolicy cdnPolicy;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String description;

  /// If true, enable Cloud CDN for this BackendBucket.
  core.bool enableCdn;

  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  BackendBucket();

  BackendBucket.fromJson(core.Map _json) {
    if (_json.containsKey("bucketName")) {
      bucketName = _json["bucketName"];
    }
    if (_json.containsKey("cdnPolicy")) {
      cdnPolicy = new BackendBucketCdnPolicy.fromJson(_json["cdnPolicy"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enableCdn")) {
      enableCdn = _json["enableCdn"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bucketName != null) {
      _json["bucketName"] = bucketName;
    }
    if (cdnPolicy != null) {
      _json["cdnPolicy"] = (cdnPolicy).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enableCdn != null) {
      _json["enableCdn"] = enableCdn;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

/// Message containing Cloud CDN configuration for a backend bucket.
class BackendBucketCdnPolicy {
  /// Maximum number of seconds the response to a signed URL request will be
  /// considered fresh. After this time period, the response will be revalidated
  /// before being served. Defaults to 1hr (3600s). When serving responses to
  /// signed URL requests, Cloud CDN will internally behave as though all
  /// responses from this backend had a "Cache-Control: public, max-age=[TTL]"
  /// header, regardless of any existing Cache-Control header. The actual
  /// headers served in responses will not be altered.
  core.String signedUrlCacheMaxAgeSec;

  /// [Output Only] Names of the keys for signing request URLs.
  core.List<core.String> signedUrlKeyNames;

  BackendBucketCdnPolicy();

  BackendBucketCdnPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("signedUrlCacheMaxAgeSec")) {
      signedUrlCacheMaxAgeSec = _json["signedUrlCacheMaxAgeSec"];
    }
    if (_json.containsKey("signedUrlKeyNames")) {
      signedUrlKeyNames =
          (_json["signedUrlKeyNames"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (signedUrlCacheMaxAgeSec != null) {
      _json["signedUrlCacheMaxAgeSec"] = signedUrlCacheMaxAgeSec;
    }
    if (signedUrlKeyNames != null) {
      _json["signedUrlKeyNames"] = signedUrlKeyNames;
    }
    return _json;
  }
}

class BackendBucketListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendBucketListWarningData();

  BackendBucketListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendBucketListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendBucketListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendBucketListWarning();

  BackendBucketListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<BackendBucketListWarningData>(
              (value) => new BackendBucketListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendBucket resources.
class BackendBucketList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendBucket resources.
  core.List<BackendBucket> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  BackendBucketListWarning warning;

  BackendBucketList();

  BackendBucketList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<BackendBucket>((value) => new BackendBucket.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new BackendBucketListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Backend Service resource.
///
/// A backend service contains configuration values for Google Cloud Platform
/// load balancing services.
///
/// Backend services in Google Compute Engine can be either regionally or
/// globally scoped.
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/backendServices) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionBackendServices)
///
/// For more information, read Backend Services.
///
/// (== resource_for {$api_version}.backendService ==)
class BackendService {
  /// If set to 0, the cookie is non-persistent and lasts only until the end of
  /// the browser session (or equivalent). The maximum allowed value is one day
  /// (86,400).
  core.int affinityCookieTtlSec;

  /// The list of backends that serve this BackendService.
  core.List<Backend> backends;

  /// Cloud CDN configuration for this BackendService.
  BackendServiceCdnPolicy cdnPolicy;

  /// Settings controlling the volume of connections to a backend service. If
  /// not set, this feature is considered disabled.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  CircuitBreakers circuitBreakers;
  ConnectionDraining connectionDraining;

  /// Consistent Hash-based load balancing can be used to provide soft session
  /// affinity based on HTTP headers, cookies or other properties. This load
  /// balancing policy is applicable only for HTTP connections. The affinity to
  /// a particular destination host will be lost when one or more hosts are
  /// added/removed from the destination service. This field specifies
  /// parameters that control consistent hashing. This field is only applicable
  /// when localityLbPolicy is set to MAGLEV or RING_HASH.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ConsistentHashLoadBalancerSettings consistentHash;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// Headers that the HTTP/S load balancer should add to proxied requests.
  core.List<core.String> customRequestHeaders;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// If true, enables Cloud CDN for the backend service. Only applicable if the
  /// loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
  core.bool enableCDN;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing. Requires
  /// at least one backend instance group to be defined as a backup (failover)
  /// backend.
  BackendServiceFailoverPolicy failoverPolicy;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a BackendService. An up-to-date fingerprint must be
  /// provided in order to update the BackendService, otherwise the request will
  /// fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// BackendService.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of URLs to the healthChecks, httpHealthChecks (legacy), or
  /// httpsHealthChecks (legacy) resource for health checking this backend
  /// service. Not all backend services support legacy health checks. See  Load
  /// balancer guide. Currently at most one health check can be specified.
  /// Backend services with instance group or zonal NEG backends must have a
  /// health check. Backend services with internet NEG backends must not have a
  /// health check. A health check must
  core.List<core.String> healthChecks;
  BackendServiceIAP iap;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#backendService for backend
  /// services.
  core.String kind;

  /// Specifies the load balancer type. Choose EXTERNAL for load balancers that
  /// receive traffic from external clients. Choose INTERNAL for Internal
  /// TCP/UDP Load Balancing. Choose INTERNAL_MANAGED for Internal HTTP(S) Load
  /// Balancing. Choose INTERNAL_SELF_MANAGED for Traffic Director. A backend
  /// service created for one type of load balancing cannot be used with
  /// another. For more information, refer to Choosing a load balancer.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INTERNAL_MANAGED"
  /// - "INTERNAL_SELF_MANAGED"
  /// - "INVALID_LOAD_BALANCING_SCHEME"
  core.String loadBalancingScheme;

  /// The load balancing algorithm used within the scope of the locality. The
  /// possible values are:
  /// - ROUND_ROBIN: This is a simple policy in which each healthy backend is
  /// selected in round robin order. This is the default.
  /// - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts
  /// and picks the host which has fewer active requests.
  /// - RING_HASH: The ring/modulo hash load balancer implements consistent
  /// hashing to backends. The algorithm has the property that the
  /// addition/removal of a host from a set of N hosts only affects 1/N of the
  /// requests.
  /// - RANDOM: The load balancer selects a random healthy host.
  /// - ORIGINAL_DESTINATION: Backend host is selected based on the client
  /// connection metadata, i.e., connections are opened to the same address as
  /// the destination address of the incoming connection before the connection
  /// was redirected to the load balancer.
  /// - MAGLEV: used as a drop in replacement for the ring hash load balancer.
  /// Maglev is not as stable as ring hash but has faster table lookup build
  /// times and host selection times. For more information about Maglev, refer
  /// to https://ai.google/research/pubs/pub44824
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// If sessionAffinity is not NONE, and this field is not set to >MAGLEV or
  /// RING_HASH, session affinity settings will not take effect.
  /// Possible string values are:
  /// - "INVALID_LB_POLICY"
  /// - "LEAST_REQUEST"
  /// - "MAGLEV"
  /// - "ORIGINAL_DESTINATION"
  /// - "RANDOM"
  /// - "RING_HASH"
  /// - "ROUND_ROBIN"
  core.String localityLbPolicy;

  /// This field denotes the logging options for the load balancer traffic
  /// served by this backend service. If logging is enabled, logs will be
  /// exported to Stackdriver.
  BackendServiceLogConfig logConfig;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The URL of the network to which this backend service belongs. This field
  /// can only be spcified when the load balancing scheme is set to INTERNAL.
  core.String network;

  /// Settings controlling the eviction of unhealthy hosts from the load
  /// balancing pool for the backend service. If not set, this feature is
  /// considered disabled.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  OutlierDetection outlierDetection;

  /// Deprecated in favor of portName. The TCP port to connect on the backend.
  /// The default value is 80.
  ///
  /// This cannot be used if the loadBalancingScheme is INTERNAL (Internal
  /// TCP/UDP Load Balancing).
  core.int port;

  /// A named port on a backend instance group representing the port for
  /// communication to the backend VMs in that group. Required when the
  /// loadBalancingScheme is EXTERNAL, INTERNAL_MANAGED, or
  /// INTERNAL_SELF_MANAGED and the backends are instance groups. The named port
  /// must be defined on each backend instance group. This parameter has no
  /// meaning if the backends are NEGs.
  ///
  ///
  ///
  /// Must be omitted when the loadBalancingScheme is INTERNAL (Internal TCP/UDP
  /// Load Blaancing).
  core.String portName;

  /// The protocol this BackendService uses to communicate with backends.
  ///
  /// Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, or UDP. depending on the
  /// chosen load balancer or Traffic Director configuration. Refer to the
  /// documentation for the load balancer or for Traffic Director for more
  /// information.
  /// Possible string values are:
  /// - "HTTP"
  /// - "HTTP2"
  /// - "HTTPS"
  /// - "SSL"
  /// - "TCP"
  /// - "UDP"
  core.String protocol;

  /// [Output Only] URL of the region where the regional backend service
  /// resides. This field is not applicable to global backend services. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// [Output Only] The resource URL for the security policy associated with
  /// this backend service.
  core.String securityPolicy;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Type of session affinity to use. The default is NONE. Session affinity is
  /// not applicable if the --protocol is UDP.
  ///
  /// When the loadBalancingScheme is EXTERNAL, possible values are NONE,
  /// CLIENT_IP, or GENERATED_COOKIE. You can use GENERATED_COOKIE if the
  /// protocol is HTTP or HTTPS.
  ///
  /// When the loadBalancingScheme is INTERNAL, possible values are NONE,
  /// CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
  ///
  /// When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or
  /// INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE,
  /// HEADER_FIELD, or HTTP_COOKIE.
  /// Possible string values are:
  /// - "CLIENT_IP"
  /// - "CLIENT_IP_PORT_PROTO"
  /// - "CLIENT_IP_PROTO"
  /// - "GENERATED_COOKIE"
  /// - "HEADER_FIELD"
  /// - "HTTP_COOKIE"
  /// - "NONE"
  core.String sessionAffinity;

  /// The backend service timeout has a different meaning depending on the type
  /// of load balancer. For more information read,  Backend service settings The
  /// default is 30 seconds.
  core.int timeoutSec;

  BackendService();

  BackendService.fromJson(core.Map _json) {
    if (_json.containsKey("affinityCookieTtlSec")) {
      affinityCookieTtlSec = _json["affinityCookieTtlSec"];
    }
    if (_json.containsKey("backends")) {
      backends = (_json["backends"] as core.List)
          .map<Backend>((value) => new Backend.fromJson(value))
          .toList();
    }
    if (_json.containsKey("cdnPolicy")) {
      cdnPolicy = new BackendServiceCdnPolicy.fromJson(_json["cdnPolicy"]);
    }
    if (_json.containsKey("circuitBreakers")) {
      circuitBreakers = new CircuitBreakers.fromJson(_json["circuitBreakers"]);
    }
    if (_json.containsKey("connectionDraining")) {
      connectionDraining =
          new ConnectionDraining.fromJson(_json["connectionDraining"]);
    }
    if (_json.containsKey("consistentHash")) {
      consistentHash = new ConsistentHashLoadBalancerSettings.fromJson(
          _json["consistentHash"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("customRequestHeaders")) {
      customRequestHeaders =
          (_json["customRequestHeaders"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enableCDN")) {
      enableCDN = _json["enableCDN"];
    }
    if (_json.containsKey("failoverPolicy")) {
      failoverPolicy =
          new BackendServiceFailoverPolicy.fromJson(_json["failoverPolicy"]);
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("healthChecks")) {
      healthChecks = (_json["healthChecks"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("iap")) {
      iap = new BackendServiceIAP.fromJson(_json["iap"]);
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("loadBalancingScheme")) {
      loadBalancingScheme = _json["loadBalancingScheme"];
    }
    if (_json.containsKey("localityLbPolicy")) {
      localityLbPolicy = _json["localityLbPolicy"];
    }
    if (_json.containsKey("logConfig")) {
      logConfig = new BackendServiceLogConfig.fromJson(_json["logConfig"]);
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("outlierDetection")) {
      outlierDetection =
          new OutlierDetection.fromJson(_json["outlierDetection"]);
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("protocol")) {
      protocol = _json["protocol"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("securityPolicy")) {
      securityPolicy = _json["securityPolicy"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sessionAffinity")) {
      sessionAffinity = _json["sessionAffinity"];
    }
    if (_json.containsKey("timeoutSec")) {
      timeoutSec = _json["timeoutSec"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (affinityCookieTtlSec != null) {
      _json["affinityCookieTtlSec"] = affinityCookieTtlSec;
    }
    if (backends != null) {
      _json["backends"] = backends.map((value) => (value).toJson()).toList();
    }
    if (cdnPolicy != null) {
      _json["cdnPolicy"] = (cdnPolicy).toJson();
    }
    if (circuitBreakers != null) {
      _json["circuitBreakers"] = (circuitBreakers).toJson();
    }
    if (connectionDraining != null) {
      _json["connectionDraining"] = (connectionDraining).toJson();
    }
    if (consistentHash != null) {
      _json["consistentHash"] = (consistentHash).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (customRequestHeaders != null) {
      _json["customRequestHeaders"] = customRequestHeaders;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enableCDN != null) {
      _json["enableCDN"] = enableCDN;
    }
    if (failoverPolicy != null) {
      _json["failoverPolicy"] = (failoverPolicy).toJson();
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (healthChecks != null) {
      _json["healthChecks"] = healthChecks;
    }
    if (iap != null) {
      _json["iap"] = (iap).toJson();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (loadBalancingScheme != null) {
      _json["loadBalancingScheme"] = loadBalancingScheme;
    }
    if (localityLbPolicy != null) {
      _json["localityLbPolicy"] = localityLbPolicy;
    }
    if (logConfig != null) {
      _json["logConfig"] = (logConfig).toJson();
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (outlierDetection != null) {
      _json["outlierDetection"] = (outlierDetection).toJson();
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (protocol != null) {
      _json["protocol"] = protocol;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (securityPolicy != null) {
      _json["securityPolicy"] = securityPolicy;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sessionAffinity != null) {
      _json["sessionAffinity"] = sessionAffinity;
    }
    if (timeoutSec != null) {
      _json["timeoutSec"] = timeoutSec;
    }
    return _json;
  }
}

class BackendServiceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServiceAggregatedListWarningData();

  BackendServiceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendServiceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServiceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServiceAggregatedListWarning();

  BackendServiceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<BackendServiceAggregatedListWarningData>((value) =>
              new BackendServiceAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendServicesScopedList.
class BackendServiceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendServicesScopedList resources.
  core.Map<core.String, BackendServicesScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  BackendServiceAggregatedListWarning warning;

  BackendServiceAggregatedList();

  BackendServiceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, BackendServicesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new BackendServicesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new BackendServiceAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<BackendServicesScopedList,
              core.Map<core.String, core.Object>>(
          items, (BackendServicesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Message containing Cloud CDN configuration for a backend service.
class BackendServiceCdnPolicy {
  /// The CacheKeyPolicy for this CdnPolicy.
  CacheKeyPolicy cacheKeyPolicy;

  /// Maximum number of seconds the response to a signed URL request will be
  /// considered fresh. After this time period, the response will be revalidated
  /// before being served. Defaults to 1hr (3600s). When serving responses to
  /// signed URL requests, Cloud CDN will internally behave as though all
  /// responses from this backend had a "Cache-Control: public, max-age=[TTL]"
  /// header, regardless of any existing Cache-Control header. The actual
  /// headers served in responses will not be altered.
  core.String signedUrlCacheMaxAgeSec;

  /// [Output Only] Names of the keys for signing request URLs.
  core.List<core.String> signedUrlKeyNames;

  BackendServiceCdnPolicy();

  BackendServiceCdnPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("cacheKeyPolicy")) {
      cacheKeyPolicy = new CacheKeyPolicy.fromJson(_json["cacheKeyPolicy"]);
    }
    if (_json.containsKey("signedUrlCacheMaxAgeSec")) {
      signedUrlCacheMaxAgeSec = _json["signedUrlCacheMaxAgeSec"];
    }
    if (_json.containsKey("signedUrlKeyNames")) {
      signedUrlKeyNames =
          (_json["signedUrlKeyNames"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (cacheKeyPolicy != null) {
      _json["cacheKeyPolicy"] = (cacheKeyPolicy).toJson();
    }
    if (signedUrlCacheMaxAgeSec != null) {
      _json["signedUrlCacheMaxAgeSec"] = signedUrlCacheMaxAgeSec;
    }
    if (signedUrlKeyNames != null) {
      _json["signedUrlKeyNames"] = signedUrlKeyNames;
    }
    return _json;
  }
}

/// Applicable only to Failover for Internal TCP/UDP Load Balancing. On failover
/// or failback, this field indicates whether connection draining will be
/// honored. GCP has a fixed connection draining timeout of 10 minutes. A
/// setting of true terminates existing TCP connections to the active pool
/// during failover and failback, immediately draining traffic. A setting of
/// false allows existing TCP connections to persist, even on VMs no longer in
/// the active pool, for up to the duration of the connection draining timeout
/// (10 minutes).
class BackendServiceFailoverPolicy {
  /// This can be set to true only if the protocol is TCP.
  ///
  /// The default is false.
  core.bool disableConnectionDrainOnFailover;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing. If set to
  /// true, connections to the load balancer are dropped when all primary and
  /// all backup backend VMs are unhealthy. If set to false, connections are
  /// distributed among all primary VMs when all primary and all backup backend
  /// VMs are unhealthy.
  ///
  /// The default is false.
  core.bool dropTrafficIfUnhealthy;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing. The value
  /// of the field must be in the range [0, 1]. If the value is 0, the load
  /// balancer performs a failover when the number of healthy primary VMs equals
  /// zero. For all other values, the load balancer performs a failover when the
  /// total number of healthy primary VMs is less than this ratio.
  core.double failoverRatio;

  BackendServiceFailoverPolicy();

  BackendServiceFailoverPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("disableConnectionDrainOnFailover")) {
      disableConnectionDrainOnFailover =
          _json["disableConnectionDrainOnFailover"];
    }
    if (_json.containsKey("dropTrafficIfUnhealthy")) {
      dropTrafficIfUnhealthy = _json["dropTrafficIfUnhealthy"];
    }
    if (_json.containsKey("failoverRatio")) {
      failoverRatio = _json["failoverRatio"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (disableConnectionDrainOnFailover != null) {
      _json["disableConnectionDrainOnFailover"] =
          disableConnectionDrainOnFailover;
    }
    if (dropTrafficIfUnhealthy != null) {
      _json["dropTrafficIfUnhealthy"] = dropTrafficIfUnhealthy;
    }
    if (failoverRatio != null) {
      _json["failoverRatio"] = failoverRatio;
    }
    return _json;
  }
}

class BackendServiceGroupHealth {
  /// Health state of the backend instances or endpoints in requested instance
  /// or network endpoint group, determined based on configured health checks.
  core.List<HealthStatus> healthStatus;

  /// [Output Only] Type of resource. Always compute#backendServiceGroupHealth
  /// for the health of backend services.
  core.String kind;

  BackendServiceGroupHealth();

  BackendServiceGroupHealth.fromJson(core.Map _json) {
    if (_json.containsKey("healthStatus")) {
      healthStatus = (_json["healthStatus"] as core.List)
          .map<HealthStatus>((value) => new HealthStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthStatus != null) {
      _json["healthStatus"] =
          healthStatus.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    return _json;
  }
}

/// Identity-Aware Proxy
class BackendServiceIAP {
  core.bool enabled;
  core.String oauth2ClientId;
  core.String oauth2ClientSecret;

  /// [Output Only] SHA256 hash value for the field oauth2_client_secret above.
  core.String oauth2ClientSecretSha256;

  BackendServiceIAP();

  BackendServiceIAP.fromJson(core.Map _json) {
    if (_json.containsKey("enabled")) {
      enabled = _json["enabled"];
    }
    if (_json.containsKey("oauth2ClientId")) {
      oauth2ClientId = _json["oauth2ClientId"];
    }
    if (_json.containsKey("oauth2ClientSecret")) {
      oauth2ClientSecret = _json["oauth2ClientSecret"];
    }
    if (_json.containsKey("oauth2ClientSecretSha256")) {
      oauth2ClientSecretSha256 = _json["oauth2ClientSecretSha256"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (enabled != null) {
      _json["enabled"] = enabled;
    }
    if (oauth2ClientId != null) {
      _json["oauth2ClientId"] = oauth2ClientId;
    }
    if (oauth2ClientSecret != null) {
      _json["oauth2ClientSecret"] = oauth2ClientSecret;
    }
    if (oauth2ClientSecretSha256 != null) {
      _json["oauth2ClientSecretSha256"] = oauth2ClientSecretSha256;
    }
    return _json;
  }
}

class BackendServiceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServiceListWarningData();

  BackendServiceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendServiceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServiceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServiceListWarning();

  BackendServiceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<BackendServiceListWarningData>(
              (value) => new BackendServiceListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendService resources.
class BackendServiceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendService resources.
  core.List<BackendService> items;

  /// [Output Only] Type of resource. Always compute#backendServiceList for
  /// lists of backend services.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  BackendServiceListWarning warning;

  BackendServiceList();

  BackendServiceList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<BackendService>((value) => new BackendService.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new BackendServiceListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// The available logging options for the load balancer traffic served by this
/// backend service.
class BackendServiceLogConfig {
  /// This field denotes whether to enable logging for the load balancer traffic
  /// served by this backend service.
  core.bool enable;

  /// This field can only be specified if logging is enabled for this backend
  /// service. The value of the field must be in [0, 1]. This configures the
  /// sampling rate of requests to the load balancer where 1.0 means all logged
  /// requests are reported and 0.0 means no logged requests are reported. The
  /// default value is 1.0.
  core.double sampleRate;

  BackendServiceLogConfig();

  BackendServiceLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey("enable")) {
      enable = _json["enable"];
    }
    if (_json.containsKey("sampleRate")) {
      sampleRate = _json["sampleRate"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (enable != null) {
      _json["enable"] = enable;
    }
    if (sampleRate != null) {
      _json["sampleRate"] = sampleRate;
    }
    return _json;
  }
}

class BackendServiceReference {
  core.String backendService;

  BackendServiceReference();

  BackendServiceReference.fromJson(core.Map _json) {
    if (_json.containsKey("backendService")) {
      backendService = _json["backendService"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (backendService != null) {
      _json["backendService"] = backendService;
    }
    return _json;
  }
}

class BackendServicesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServicesScopedListWarningData();

  BackendServicesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class BackendServicesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServicesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServicesScopedListWarning();

  BackendServicesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<BackendServicesScopedListWarningData>((value) =>
              new BackendServicesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class BackendServicesScopedList {
  /// A list of BackendServices contained in this scope.
  core.List<BackendService> backendServices;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  BackendServicesScopedListWarning warning;

  BackendServicesScopedList();

  BackendServicesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("backendServices")) {
      backendServices = (_json["backendServices"] as core.List)
          .map<BackendService>((value) => new BackendService.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new BackendServicesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (backendServices != null) {
      _json["backendServices"] =
          backendServices.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Associates `members` with a `role`.
class Binding {
  /// The condition that is associated with this binding. NOTE: An unsatisfied
  /// condition will not allow user access via current binding. Different
  /// bindings, including their conditions, are examined independently.
  Expr condition;

  /// Specifies the identities requesting access for a Cloud Platform resource.
  /// `members` can have the following values:
  ///
  /// * `allUsers`: A special identifier that represents anyone who is on the
  /// internet; with or without a Google account.
  ///
  /// * `allAuthenticatedUsers`: A special identifier that represents anyone who
  /// is authenticated with a Google account or a service account.
  ///
  /// * `user:{emailid}`: An email address that represents a specific Google
  /// account. For example, `alice@example.com` .
  ///
  ///
  ///
  /// * `serviceAccount:{emailid}`: An email address that represents a service
  /// account. For example, `my-other-app@appspot.gserviceaccount.com`.
  ///
  /// * `group:{emailid}`: An email address that represents a Google group. For
  /// example, `admins@example.com`.
  ///
  /// * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
  /// identifier) representing a user that has been recently deleted. For
  /// example, `alice@example.com?uid=123456789012345678901`. If the user is
  /// recovered, this value reverts to `user:{emailid}` and the recovered user
  /// retains the role in the binding.
  ///
  /// * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address
  /// (plus unique identifier) representing a service account that has been
  /// recently deleted. For example,
  /// `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If
  /// the service account is undeleted, this value reverts to
  /// `serviceAccount:{emailid}` and the undeleted service account retains the
  /// role in the binding.
  ///
  /// * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
  /// identifier) representing a Google group that has been recently deleted.
  /// For example, `admins@example.com?uid=123456789012345678901`. If the group
  /// is recovered, this value reverts to `group:{emailid}` and the recovered
  /// group retains the role in the binding.
  ///
  ///
  ///
  /// * `domain:{domain}`: The G Suite domain (primary) that represents all the
  /// users of that domain. For example, `google.com` or `example.com`.
  core.List<core.String> members;

  /// Role that is assigned to `members`. For example, `roles/viewer`,
  /// `roles/editor`, or `roles/owner`.
  core.String role;

  Binding();

  Binding.fromJson(core.Map _json) {
    if (_json.containsKey("condition")) {
      condition = new Expr.fromJson(_json["condition"]);
    }
    if (_json.containsKey("members")) {
      members = (_json["members"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("role")) {
      role = _json["role"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (condition != null) {
      _json["condition"] = (condition).toJson();
    }
    if (members != null) {
      _json["members"] = members;
    }
    if (role != null) {
      _json["role"] = role;
    }
    return _json;
  }
}

class CacheInvalidationRule {
  /// If set, this invalidation rule will only apply to requests with a Host
  /// header matching host.
  core.String host;
  core.String path;

  CacheInvalidationRule();

  CacheInvalidationRule.fromJson(core.Map _json) {
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("path")) {
      path = _json["path"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (host != null) {
      _json["host"] = host;
    }
    if (path != null) {
      _json["path"] = path;
    }
    return _json;
  }
}

/// Message containing what to include in the cache key for a request for Cloud
/// CDN.
class CacheKeyPolicy {
  /// If true, requests to different hosts will be cached separately.
  core.bool includeHost;

  /// If true, http and https requests will be cached separately.
  core.bool includeProtocol;

  /// If true, include query string parameters in the cache key according to
  /// query_string_whitelist and query_string_blacklist. If neither is set, the
  /// entire query string will be included. If false, the query string will be
  /// excluded from the cache key entirely.
  core.bool includeQueryString;

  /// Names of query string parameters to exclude in cache keys. All other
  /// parameters will be included. Either specify query_string_whitelist or
  /// query_string_blacklist, not both. '&' and '=' will be percent encoded and
  /// not treated as delimiters.
  core.List<core.String> queryStringBlacklist;

  /// Names of query string parameters to include in cache keys. All other
  /// parameters will be excluded. Either specify query_string_whitelist or
  /// query_string_blacklist, not both. '&' and '=' will be percent encoded and
  /// not treated as delimiters.
  core.List<core.String> queryStringWhitelist;

  CacheKeyPolicy();

  CacheKeyPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("includeHost")) {
      includeHost = _json["includeHost"];
    }
    if (_json.containsKey("includeProtocol")) {
      includeProtocol = _json["includeProtocol"];
    }
    if (_json.containsKey("includeQueryString")) {
      includeQueryString = _json["includeQueryString"];
    }
    if (_json.containsKey("queryStringBlacklist")) {
      queryStringBlacklist =
          (_json["queryStringBlacklist"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("queryStringWhitelist")) {
      queryStringWhitelist =
          (_json["queryStringWhitelist"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (includeHost != null) {
      _json["includeHost"] = includeHost;
    }
    if (includeProtocol != null) {
      _json["includeProtocol"] = includeProtocol;
    }
    if (includeQueryString != null) {
      _json["includeQueryString"] = includeQueryString;
    }
    if (queryStringBlacklist != null) {
      _json["queryStringBlacklist"] = queryStringBlacklist;
    }
    if (queryStringWhitelist != null) {
      _json["queryStringWhitelist"] = queryStringWhitelist;
    }
    return _json;
  }
}

/// Settings controlling the volume of connections to a backend service.
class CircuitBreakers {
  /// The maximum number of connections to the backend service. If not
  /// specified, there is no limit.
  core.int maxConnections;

  /// The maximum number of pending requests allowed to the backend service. If
  /// not specified, there is no limit.
  core.int maxPendingRequests;

  /// The maximum number of parallel requests that allowed to the backend
  /// service. If not specified, there is no limit.
  core.int maxRequests;

  /// Maximum requests for a single connection to the backend service. This
  /// parameter is respected by both the HTTP/1.1 and HTTP/2 implementations. If
  /// not specified, there is no limit. Setting this parameter to 1 will
  /// effectively disable keep alive.
  core.int maxRequestsPerConnection;

  /// The maximum number of parallel retries allowed to the backend cluster. If
  /// not specified, the default is 1.
  core.int maxRetries;

  CircuitBreakers();

  CircuitBreakers.fromJson(core.Map _json) {
    if (_json.containsKey("maxConnections")) {
      maxConnections = _json["maxConnections"];
    }
    if (_json.containsKey("maxPendingRequests")) {
      maxPendingRequests = _json["maxPendingRequests"];
    }
    if (_json.containsKey("maxRequests")) {
      maxRequests = _json["maxRequests"];
    }
    if (_json.containsKey("maxRequestsPerConnection")) {
      maxRequestsPerConnection = _json["maxRequestsPerConnection"];
    }
    if (_json.containsKey("maxRetries")) {
      maxRetries = _json["maxRetries"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (maxConnections != null) {
      _json["maxConnections"] = maxConnections;
    }
    if (maxPendingRequests != null) {
      _json["maxPendingRequests"] = maxPendingRequests;
    }
    if (maxRequests != null) {
      _json["maxRequests"] = maxRequests;
    }
    if (maxRequestsPerConnection != null) {
      _json["maxRequestsPerConnection"] = maxRequestsPerConnection;
    }
    if (maxRetries != null) {
      _json["maxRetries"] = maxRetries;
    }
    return _json;
  }
}

/// Represents a regional Commitment resource.
///
/// Creating a commitment resource means that you are purchasing a committed use
/// contract with an explicit start and end time. You can create commitments
/// based on vCPUs and memory usage and receive discounted rates. For full
/// details, read Signing Up for Committed Use Discounts. (== resource_for
/// {$api_version}.regionCommitments ==)
class Commitment {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Commitment end time in RFC3339 text format.
  core.String endTimestamp;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#commitment for
  /// commitments.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The plan for this commitment, which determines duration and discount rate.
  /// The currently supported plans are TWELVE_MONTH (1 year), and
  /// THIRTY_SIX_MONTH (3 years).
  /// Possible string values are:
  /// - "INVALID"
  /// - "THIRTY_SIX_MONTH"
  /// - "TWELVE_MONTH"
  core.String plan;

  /// [Output Only] URL of the region where this commitment may be used.
  core.String region;

  /// List of reservations in this commitment.
  core.List<Reservation> reservations;

  /// A list of commitment amounts for particular resources. Note that VCPU and
  /// MEMORY resource commitments must occur together.
  core.List<ResourceCommitment> resources;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Commitment start time in RFC3339 text format.
  core.String startTimestamp;

  /// [Output Only] Status of the commitment with regards to eventual expiration
  /// (each commitment has an end date defined). One of the following values:
  /// NOT_YET_ACTIVE, ACTIVE, EXPIRED.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CREATING"
  /// - "EXPIRED"
  /// - "NOT_YET_ACTIVE"
  core.String status;

  /// [Output Only] An optional, human-readable explanation of the status.
  core.String statusMessage;

  Commitment();

  Commitment.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("endTimestamp")) {
      endTimestamp = _json["endTimestamp"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("plan")) {
      plan = _json["plan"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("reservations")) {
      reservations = (_json["reservations"] as core.List)
          .map<Reservation>((value) => new Reservation.fromJson(value))
          .toList();
    }
    if (_json.containsKey("resources")) {
      resources = (_json["resources"] as core.List)
          .map<ResourceCommitment>(
              (value) => new ResourceCommitment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("startTimestamp")) {
      startTimestamp = _json["startTimestamp"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusMessage")) {
      statusMessage = _json["statusMessage"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (endTimestamp != null) {
      _json["endTimestamp"] = endTimestamp;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (plan != null) {
      _json["plan"] = plan;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (reservations != null) {
      _json["reservations"] =
          reservations.map((value) => (value).toJson()).toList();
    }
    if (resources != null) {
      _json["resources"] = resources.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (startTimestamp != null) {
      _json["startTimestamp"] = startTimestamp;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusMessage != null) {
      _json["statusMessage"] = statusMessage;
    }
    return _json;
  }
}

class CommitmentAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentAggregatedListWarningData();

  CommitmentAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class CommitmentAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentAggregatedListWarning();

  CommitmentAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<CommitmentAggregatedListWarningData>((value) =>
              new CommitmentAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class CommitmentAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of CommitmentsScopedList resources.
  core.Map<core.String, CommitmentsScopedList> items;

  /// [Output Only] Type of resource. Always compute#commitmentAggregatedList
  /// for aggregated lists of commitments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  CommitmentAggregatedListWarning warning;

  CommitmentAggregatedList();

  CommitmentAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, CommitmentsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new CommitmentsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new CommitmentAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<CommitmentsScopedList, core.Map<core.String, core.Object>>(
              items, (CommitmentsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class CommitmentListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentListWarningData();

  CommitmentListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class CommitmentListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentListWarning();

  CommitmentListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<CommitmentListWarningData>(
              (value) => new CommitmentListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Commitment resources.
class CommitmentList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Commitment resources.
  core.List<Commitment> items;

  /// [Output Only] Type of resource. Always compute#commitmentList for lists of
  /// commitments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  CommitmentListWarning warning;

  CommitmentList();

  CommitmentList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Commitment>((value) => new Commitment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new CommitmentListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class CommitmentsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentsScopedListWarningData();

  CommitmentsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of commitments
/// when the list is empty.
class CommitmentsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentsScopedListWarning();

  CommitmentsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<CommitmentsScopedListWarningData>(
              (value) => new CommitmentsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class CommitmentsScopedList {
  /// [Output Only] A list of commitments contained in this scope.
  core.List<Commitment> commitments;

  /// [Output Only] Informational warning which replaces the list of commitments
  /// when the list is empty.
  CommitmentsScopedListWarning warning;

  CommitmentsScopedList();

  CommitmentsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("commitments")) {
      commitments = (_json["commitments"] as core.List)
          .map<Commitment>((value) => new Commitment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new CommitmentsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (commitments != null) {
      _json["commitments"] =
          commitments.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A condition to be met.
class Condition {
  /// Trusted attributes supplied by the IAM system.
  /// Possible string values are:
  /// - "APPROVER"
  /// - "ATTRIBUTION"
  /// - "AUTHORITY"
  /// - "CREDENTIALS_TYPE"
  /// - "JUSTIFICATION_TYPE"
  /// - "NO_ATTR"
  /// - "SECURITY_REALM"
  core.String iam;

  /// An operator to apply the subject with.
  /// Possible string values are:
  /// - "DISCHARGED"
  /// - "EQUALS"
  /// - "IN"
  /// - "NOT_EQUALS"
  /// - "NOT_IN"
  /// - "NO_OP"
  core.String op;

  /// Trusted attributes discharged by the service.
  core.String svc;

  /// Trusted attributes supplied by any service that owns resources and uses
  /// the IAM system for access control.
  /// Possible string values are:
  /// - "IP"
  /// - "NAME"
  /// - "NO_ATTR"
  /// - "REGION"
  /// - "SERVICE"
  core.String sys;

  /// The objects of the condition.
  core.List<core.String> values;

  Condition();

  Condition.fromJson(core.Map _json) {
    if (_json.containsKey("iam")) {
      iam = _json["iam"];
    }
    if (_json.containsKey("op")) {
      op = _json["op"];
    }
    if (_json.containsKey("svc")) {
      svc = _json["svc"];
    }
    if (_json.containsKey("sys")) {
      sys = _json["sys"];
    }
    if (_json.containsKey("values")) {
      values = (_json["values"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (iam != null) {
      _json["iam"] = iam;
    }
    if (op != null) {
      _json["op"] = op;
    }
    if (svc != null) {
      _json["svc"] = svc;
    }
    if (sys != null) {
      _json["sys"] = sys;
    }
    if (values != null) {
      _json["values"] = values;
    }
    return _json;
  }
}

/// Message containing connection draining configuration.
class ConnectionDraining {
  /// The amount of time in seconds to allow existing connections to persist
  /// while on unhealthy backend VMs. Only applicable if the protocol is not
  /// UDP. The valid range is [0, 3600].
  core.int drainingTimeoutSec;

  ConnectionDraining();

  ConnectionDraining.fromJson(core.Map _json) {
    if (_json.containsKey("drainingTimeoutSec")) {
      drainingTimeoutSec = _json["drainingTimeoutSec"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (drainingTimeoutSec != null) {
      _json["drainingTimeoutSec"] = drainingTimeoutSec;
    }
    return _json;
  }
}

/// This message defines settings for a consistent hash style load balancer.
class ConsistentHashLoadBalancerSettings {
  /// Hash is based on HTTP Cookie. This field describes a HTTP cookie that will
  /// be used as the hash key for the consistent hash load balancer. If the
  /// cookie is not present, it will be generated. This field is applicable if
  /// the sessionAffinity is set to HTTP_COOKIE.
  ConsistentHashLoadBalancerSettingsHttpCookie httpCookie;

  /// The hash based on the value of the specified header field. This field is
  /// applicable if the sessionAffinity is set to HEADER_FIELD.
  core.String httpHeaderName;

  /// The minimum number of virtual nodes to use for the hash ring. Defaults to
  /// 1024. Larger ring sizes result in more granular load distributions. If the
  /// number of hosts in the load balancing pool is larger than the ring size,
  /// each host will be assigned a single virtual node.
  core.String minimumRingSize;

  ConsistentHashLoadBalancerSettings();

  ConsistentHashLoadBalancerSettings.fromJson(core.Map _json) {
    if (_json.containsKey("httpCookie")) {
      httpCookie = new ConsistentHashLoadBalancerSettingsHttpCookie.fromJson(
          _json["httpCookie"]);
    }
    if (_json.containsKey("httpHeaderName")) {
      httpHeaderName = _json["httpHeaderName"];
    }
    if (_json.containsKey("minimumRingSize")) {
      minimumRingSize = _json["minimumRingSize"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (httpCookie != null) {
      _json["httpCookie"] = (httpCookie).toJson();
    }
    if (httpHeaderName != null) {
      _json["httpHeaderName"] = httpHeaderName;
    }
    if (minimumRingSize != null) {
      _json["minimumRingSize"] = minimumRingSize;
    }
    return _json;
  }
}

/// The information about the HTTP Cookie on which the hash function is based
/// for load balancing policies that use a consistent hash.
class ConsistentHashLoadBalancerSettingsHttpCookie {
  /// Name of the cookie.
  core.String name;

  /// Path to set for the cookie.
  core.String path;

  /// Lifetime of the cookie.
  Duration ttl;

  ConsistentHashLoadBalancerSettingsHttpCookie();

  ConsistentHashLoadBalancerSettingsHttpCookie.fromJson(core.Map _json) {
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("path")) {
      path = _json["path"];
    }
    if (_json.containsKey("ttl")) {
      ttl = new Duration.fromJson(_json["ttl"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (name != null) {
      _json["name"] = name;
    }
    if (path != null) {
      _json["path"] = path;
    }
    if (ttl != null) {
      _json["ttl"] = (ttl).toJson();
    }
    return _json;
  }
}

/// The specification for allowing client side cross-origin requests. Please see
/// W3C Recommendation for Cross Origin Resource Sharing
class CorsPolicy {
  /// In response to a preflight request, setting this to true indicates that
  /// the actual request can include user credentials. This translates to the
  /// Access-Control-Allow-Credentials header.
  /// Default is false.
  core.bool allowCredentials;

  /// Specifies the content for the Access-Control-Allow-Headers header.
  core.List<core.String> allowHeaders;

  /// Specifies the content for the Access-Control-Allow-Methods header.
  core.List<core.String> allowMethods;

  /// Specifies the regualar expression patterns that match allowed origins. For
  /// regular expression grammar please see
  /// en.cppreference.com/w/cpp/regex/ecmascript
  /// An origin is allowed if it matches either allow_origins or
  /// allow_origin_regex.
  core.List<core.String> allowOriginRegexes;

  /// Specifies the list of origins that will be allowed to do CORS requests.
  /// An origin is allowed if it matches either allow_origins or
  /// allow_origin_regex.
  core.List<core.String> allowOrigins;

  /// If true, specifies the CORS policy is disabled. The default value of
  /// false, which indicates that the CORS policy is in effect.
  core.bool disabled;

  /// Specifies the content for the Access-Control-Expose-Headers header.
  core.List<core.String> exposeHeaders;

  /// Specifies how long results of a preflight request can be cached in
  /// seconds. This translates to the Access-Control-Max-Age header.
  core.int maxAge;

  CorsPolicy();

  CorsPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("allowCredentials")) {
      allowCredentials = _json["allowCredentials"];
    }
    if (_json.containsKey("allowHeaders")) {
      allowHeaders = (_json["allowHeaders"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("allowMethods")) {
      allowMethods = (_json["allowMethods"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("allowOriginRegexes")) {
      allowOriginRegexes =
          (_json["allowOriginRegexes"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("allowOrigins")) {
      allowOrigins = (_json["allowOrigins"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("disabled")) {
      disabled = _json["disabled"];
    }
    if (_json.containsKey("exposeHeaders")) {
      exposeHeaders = (_json["exposeHeaders"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("maxAge")) {
      maxAge = _json["maxAge"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (allowCredentials != null) {
      _json["allowCredentials"] = allowCredentials;
    }
    if (allowHeaders != null) {
      _json["allowHeaders"] = allowHeaders;
    }
    if (allowMethods != null) {
      _json["allowMethods"] = allowMethods;
    }
    if (allowOriginRegexes != null) {
      _json["allowOriginRegexes"] = allowOriginRegexes;
    }
    if (allowOrigins != null) {
      _json["allowOrigins"] = allowOrigins;
    }
    if (disabled != null) {
      _json["disabled"] = disabled;
    }
    if (exposeHeaders != null) {
      _json["exposeHeaders"] = exposeHeaders;
    }
    if (maxAge != null) {
      _json["maxAge"] = maxAge;
    }
    return _json;
  }
}

/// Represents a customer-supplied encryption key
class CustomerEncryptionKey {
  /// The name of the encryption key that is stored in Google Cloud KMS.
  core.String kmsKeyName;

  /// The service account being used for the encryption request for the given
  /// KMS key. If absent, the Compute Engine default service account is used.
  core.String kmsKeyServiceAccount;

  /// Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648
  /// base64 to either encrypt or decrypt this resource.
  core.String rawKey;

  /// [Output only] The RFC 4648 base64 encoded SHA-256 hash of the
  /// customer-supplied encryption key that protects this resource.
  core.String sha256;

  CustomerEncryptionKey();

  CustomerEncryptionKey.fromJson(core.Map _json) {
    if (_json.containsKey("kmsKeyName")) {
      kmsKeyName = _json["kmsKeyName"];
    }
    if (_json.containsKey("kmsKeyServiceAccount")) {
      kmsKeyServiceAccount = _json["kmsKeyServiceAccount"];
    }
    if (_json.containsKey("rawKey")) {
      rawKey = _json["rawKey"];
    }
    if (_json.containsKey("sha256")) {
      sha256 = _json["sha256"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kmsKeyName != null) {
      _json["kmsKeyName"] = kmsKeyName;
    }
    if (kmsKeyServiceAccount != null) {
      _json["kmsKeyServiceAccount"] = kmsKeyServiceAccount;
    }
    if (rawKey != null) {
      _json["rawKey"] = rawKey;
    }
    if (sha256 != null) {
      _json["sha256"] = sha256;
    }
    return _json;
  }
}

class CustomerEncryptionKeyProtectedDisk {
  /// Decrypts data associated with the disk with a customer-supplied encryption
  /// key.
  CustomerEncryptionKey diskEncryptionKey;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource. This field is only applicable for persistent disks.
  core.String source;

  CustomerEncryptionKeyProtectedDisk();

  CustomerEncryptionKeyProtectedDisk.fromJson(core.Map _json) {
    if (_json.containsKey("diskEncryptionKey")) {
      diskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["diskEncryptionKey"]);
    }
    if (_json.containsKey("source")) {
      source = _json["source"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskEncryptionKey != null) {
      _json["diskEncryptionKey"] = (diskEncryptionKey).toJson();
    }
    if (source != null) {
      _json["source"] = source;
    }
    return _json;
  }
}

/// Deprecation status for a public resource.
class DeprecationStatus {
  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DELETED. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String deleted;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DEPRECATED. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String deprecated;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to OBSOLETE. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String obsolete;

  /// The URL of the suggested replacement for a deprecated resource. The
  /// suggested replacement resource must be the same kind of resource as the
  /// deprecated resource.
  core.String replacement;

  /// The deprecation state of this resource. This can be ACTIVE, DEPRECATED,
  /// OBSOLETE, or DELETED. Operations which communicate the end of life date
  /// for an image, can use ACTIVE. Operations which create a new resource using
  /// a DEPRECATED resource will return successfully, but with a warning
  /// indicating the deprecated resource and recommending its replacement.
  /// Operations which use OBSOLETE or DELETED resources will be rejected and
  /// result in an error.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DELETED"
  /// - "DEPRECATED"
  /// - "OBSOLETE"
  core.String state;

  DeprecationStatus();

  DeprecationStatus.fromJson(core.Map _json) {
    if (_json.containsKey("deleted")) {
      deleted = _json["deleted"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = _json["deprecated"];
    }
    if (_json.containsKey("obsolete")) {
      obsolete = _json["obsolete"];
    }
    if (_json.containsKey("replacement")) {
      replacement = _json["replacement"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (deleted != null) {
      _json["deleted"] = deleted;
    }
    if (deprecated != null) {
      _json["deprecated"] = deprecated;
    }
    if (obsolete != null) {
      _json["obsolete"] = obsolete;
    }
    if (replacement != null) {
      _json["replacement"] = replacement;
    }
    if (state != null) {
      _json["state"] = state;
    }
    return _json;
  }
}

/// Represents a Persistent Disk resource.
///
/// Google Compute Engine has two Disk resources:
///
/// * [Zonal](/compute/docs/reference/rest/{$api_version}/disks) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionDisks)
///
/// Persistent disks are required for running your VM instances. Create both
/// boot and non-boot (data) persistent disks. For more information, read
/// Persistent Disks. For more storage options, read Storage options.
///
/// The disks resource represents a zonal persistent disk. For more information,
/// read Zonal persistent disks.
///
/// The regionDisks resource represents a regional persistent disk. For more
/// information, read  Regional resources. (== resource_for {$api_version}.disks
/// ==) (== resource_for {$api_version}.regionDisks ==)
class Disk {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Encrypts the disk using a customer-supplied encryption key.
  ///
  /// After you encrypt a disk with a customer-supplied key, you must provide
  /// the same key if you use the disk later (e.g. to create a disk snapshot, to
  /// create a disk image, to create a machine image, or to attach the disk to a
  /// virtual machine).
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the disk, then the
  /// disk will be encrypted using an automatically generated key and you do not
  /// need to provide a key to use the disk later.
  CustomerEncryptionKey diskEncryptionKey;

  /// A list of features to enable on the guest operating system. Applicable
  /// only for bootable images. Read  Enabling guest operating system features
  /// to see a list of available options.
  core.List<GuestOsFeature> guestOsFeatures;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#disk for disks.
  core.String kind;

  /// A fingerprint for the labels being applied to this disk, which is
  /// essentially a hash of the labels set used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a disk.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels to apply to this disk. These can be later modified by the setLabels
  /// method.
  core.Map<core.String, core.String> labels;

  /// [Output Only] Last attach timestamp in RFC3339 text format.
  core.String lastAttachTimestamp;

  /// [Output Only] Last detach timestamp in RFC3339 text format.
  core.String lastDetachTimestamp;

  /// Integer license codes indicating which licenses are attached to this disk.
  core.List<core.String> licenseCodes;

  /// A list of publicly visible licenses. Reserved for Google's use.
  core.List<core.String> licenses;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Internal use only.
  core.String options;

  /// Physical block size of the persistent disk, in bytes. If not present in a
  /// request, a default value is used. Currently supported sizes are 4096 and
  /// 16384, other sizes may be added in the future. If an unsupported value is
  /// requested, the error message will list the supported values for the
  /// caller's project.
  core.String physicalBlockSizeBytes;

  /// [Output Only] URL of the region where the disk resides. Only applicable
  /// for regional resources. You must specify this field as part of the HTTP
  /// request URL. It is not settable as a field in the request body.
  core.String region;

  /// URLs of the zones where the disk should be replicated to. Only applicable
  /// for regional resources.
  core.List<core.String> replicaZones;

  /// Resource policies applied to this disk for automatic snapshot creations.
  core.List<core.String> resourcePolicies;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// Size of the persistent disk, specified in GB. You can specify this field
  /// when creating a persistent disk using the sourceImage or sourceSnapshot
  /// parameter, or specify it alone to create an empty persistent disk.
  ///
  /// If you specify this field along with sourceImage or sourceSnapshot, the
  /// value of sizeGb must not be less than the size of the sourceImage or the
  /// size of the snapshot. Acceptable values are 1 to 65536, inclusive.
  core.String sizeGb;

  /// The source image used to create this disk. If the source image is deleted,
  /// this field will not be set.
  ///
  /// To create a disk with one of the public operating system images, specify
  /// the image by its family name. For example, specify family/debian-9 to use
  /// the latest Debian 9 image:
  /// projects/debian-cloud/global/images/family/debian-9
  ///
  ///
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD
  ///
  ///
  /// To create a disk with a custom image that you created, specify the image
  /// name in the following format:
  /// global/images/my-custom-image
  ///
  ///
  /// You can also specify a custom image by its image family, which returns the
  /// latest version of the image in that family. Replace the image name with
  /// family/family-name:
  /// global/images/family/my-image-family
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceImageEncryptionKey;

  /// [Output Only] The ID value of the image used to create this disk. This
  /// value identifies the exact image that was used to create this persistent
  /// disk. For example, if you created the persistent disk from an image that
  /// was later deleted and recreated under the same name, the source image ID
  /// would identify the exact version of the image that was used.
  core.String sourceImageId;

  /// The source snapshot used to create this disk. You can provide this as a
  /// partial or full URL to the resource. For example, the following are valid
  /// values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/snapshots/snapshot
  /// - projects/project/global/snapshots/snapshot
  /// - global/snapshots/snapshot
  core.String sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot. Required if
  /// the source snapshot is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceSnapshotEncryptionKey;

  /// [Output Only] The unique ID of the snapshot used to create this disk. This
  /// value identifies the exact snapshot that was used to create this
  /// persistent disk. For example, if you created the persistent disk from a
  /// snapshot that was later deleted and recreated under the same name, the
  /// source snapshot ID would identify the exact version of the snapshot that
  /// was used.
  core.String sourceSnapshotId;

  /// [Output Only] The status of disk creation. CREATING: Disk is provisioning.
  /// RESTORING: Source data is being copied into the disk. FAILED: Disk
  /// creation failed. READY: Disk is ready for use. DELETING: Disk is deleting.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  /// - "RESTORING"
  core.String status;

  /// URL of the disk type resource describing which disk type to use to create
  /// the disk. Provide this when creating the disk. For example:
  /// projects/project/zones/zone/diskTypes/pd-standard or pd-ssd
  core.String type;

  /// [Output Only] Links to the users of the disk (attached instances) in form:
  /// projects/project/zones/zone/instances/instance
  core.List<core.String> users;

  /// [Output Only] URL of the zone where the disk resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String zone;

  Disk();

  Disk.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("diskEncryptionKey")) {
      diskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["diskEncryptionKey"]);
    }
    if (_json.containsKey("guestOsFeatures")) {
      guestOsFeatures = (_json["guestOsFeatures"] as core.List)
          .map<GuestOsFeature>((value) => new GuestOsFeature.fromJson(value))
          .toList();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("lastAttachTimestamp")) {
      lastAttachTimestamp = _json["lastAttachTimestamp"];
    }
    if (_json.containsKey("lastDetachTimestamp")) {
      lastDetachTimestamp = _json["lastDetachTimestamp"];
    }
    if (_json.containsKey("licenseCodes")) {
      licenseCodes = (_json["licenseCodes"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("licenses")) {
      licenses = (_json["licenses"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("options")) {
      options = _json["options"];
    }
    if (_json.containsKey("physicalBlockSizeBytes")) {
      physicalBlockSizeBytes = _json["physicalBlockSizeBytes"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("replicaZones")) {
      replicaZones = (_json["replicaZones"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sizeGb")) {
      sizeGb = _json["sizeGb"];
    }
    if (_json.containsKey("sourceImage")) {
      sourceImage = _json["sourceImage"];
    }
    if (_json.containsKey("sourceImageEncryptionKey")) {
      sourceImageEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceImageEncryptionKey"]);
    }
    if (_json.containsKey("sourceImageId")) {
      sourceImageId = _json["sourceImageId"];
    }
    if (_json.containsKey("sourceSnapshot")) {
      sourceSnapshot = _json["sourceSnapshot"];
    }
    if (_json.containsKey("sourceSnapshotEncryptionKey")) {
      sourceSnapshotEncryptionKey = new CustomerEncryptionKey.fromJson(
          _json["sourceSnapshotEncryptionKey"]);
    }
    if (_json.containsKey("sourceSnapshotId")) {
      sourceSnapshotId = _json["sourceSnapshotId"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
    if (_json.containsKey("users")) {
      users = (_json["users"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (diskEncryptionKey != null) {
      _json["diskEncryptionKey"] = (diskEncryptionKey).toJson();
    }
    if (guestOsFeatures != null) {
      _json["guestOsFeatures"] =
          guestOsFeatures.map((value) => (value).toJson()).toList();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (lastAttachTimestamp != null) {
      _json["lastAttachTimestamp"] = lastAttachTimestamp;
    }
    if (lastDetachTimestamp != null) {
      _json["lastDetachTimestamp"] = lastDetachTimestamp;
    }
    if (licenseCodes != null) {
      _json["licenseCodes"] = licenseCodes;
    }
    if (licenses != null) {
      _json["licenses"] = licenses;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (options != null) {
      _json["options"] = options;
    }
    if (physicalBlockSizeBytes != null) {
      _json["physicalBlockSizeBytes"] = physicalBlockSizeBytes;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (replicaZones != null) {
      _json["replicaZones"] = replicaZones;
    }
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sizeGb != null) {
      _json["sizeGb"] = sizeGb;
    }
    if (sourceImage != null) {
      _json["sourceImage"] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json["sourceImageEncryptionKey"] = (sourceImageEncryptionKey).toJson();
    }
    if (sourceImageId != null) {
      _json["sourceImageId"] = sourceImageId;
    }
    if (sourceSnapshot != null) {
      _json["sourceSnapshot"] = sourceSnapshot;
    }
    if (sourceSnapshotEncryptionKey != null) {
      _json["sourceSnapshotEncryptionKey"] =
          (sourceSnapshotEncryptionKey).toJson();
    }
    if (sourceSnapshotId != null) {
      _json["sourceSnapshotId"] = sourceSnapshotId;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (type != null) {
      _json["type"] = type;
    }
    if (users != null) {
      _json["users"] = users;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class DiskAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskAggregatedListWarningData();

  DiskAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskAggregatedListWarning();

  DiskAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<DiskAggregatedListWarningData>(
              (value) => new DiskAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class DiskAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DisksScopedList resources.
  core.Map<core.String, DisksScopedList> items;

  /// [Output Only] Type of resource. Always compute#diskAggregatedList for
  /// aggregated lists of persistent disks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskAggregatedListWarning warning;

  DiskAggregatedList();

  DiskAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, DisksScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new DisksScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new DiskAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] =
          commons.mapMap<DisksScopedList, core.Map<core.String, core.Object>>(
              items, (DisksScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A specification of the desired way to instantiate a disk in the instance
/// template when its created from a source instance.
class DiskInstantiationConfig {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool autoDelete;

  /// The custom source image to be used to restore this disk when instantiating
  /// this instance template.
  core.String customImage;

  /// Specifies the device name of the disk to which the configurations apply
  /// to.
  core.String deviceName;

  /// Specifies whether to include the disk and what image to use. Possible
  /// values are:
  /// - source-image: to use the same image that was used to create the source
  /// instance's corresponding disk. Applicable to the boot disk and additional
  /// read-write disks.
  /// - source-image-family: to use the same image family that was used to
  /// create the source instance's corresponding disk. Applicable to the boot
  /// disk and additional read-write disks.
  /// - custom-image: to use a user-provided image url for disk creation.
  /// Applicable to the boot disk and additional read-write disks.
  /// - attach-read-only: to attach a read-only disk. Applicable to read-only
  /// disks.
  /// - do-not-include: to exclude a disk from the template. Applicable to
  /// additional read-write disks, local SSDs, and read-only disks.
  /// Possible string values are:
  /// - "ATTACH_READ_ONLY"
  /// - "BLANK"
  /// - "CUSTOM_IMAGE"
  /// - "DEFAULT"
  /// - "DO_NOT_INCLUDE"
  /// - "SOURCE_IMAGE"
  /// - "SOURCE_IMAGE_FAMILY"
  core.String instantiateFrom;

  DiskInstantiationConfig();

  DiskInstantiationConfig.fromJson(core.Map _json) {
    if (_json.containsKey("autoDelete")) {
      autoDelete = _json["autoDelete"];
    }
    if (_json.containsKey("customImage")) {
      customImage = _json["customImage"];
    }
    if (_json.containsKey("deviceName")) {
      deviceName = _json["deviceName"];
    }
    if (_json.containsKey("instantiateFrom")) {
      instantiateFrom = _json["instantiateFrom"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoDelete != null) {
      _json["autoDelete"] = autoDelete;
    }
    if (customImage != null) {
      _json["customImage"] = customImage;
    }
    if (deviceName != null) {
      _json["deviceName"] = deviceName;
    }
    if (instantiateFrom != null) {
      _json["instantiateFrom"] = instantiateFrom;
    }
    return _json;
  }
}

class DiskListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskListWarningData();

  DiskListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskListWarning();

  DiskListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<DiskListWarningData>(
              (value) => new DiskListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// A list of Disk resources.
class DiskList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Disk resources.
  core.List<Disk> items;

  /// [Output Only] Type of resource. Always compute#diskList for lists of
  /// disks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskListWarning warning;

  DiskList();

  DiskList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Disk>((value) => new Disk.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new DiskListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DiskMoveRequest {
  /// The URL of the destination zone to move the disk. This can be a full or
  /// partial URL. For example, the following are all valid URLs to a zone:
  /// - https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// - projects/project/zones/zone
  /// - zones/zone
  core.String destinationZone;

  /// The URL of the target disk to move. This can be a full or partial URL. For
  /// example, the following are all valid URLs to a disk:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String targetDisk;

  DiskMoveRequest();

  DiskMoveRequest.fromJson(core.Map _json) {
    if (_json.containsKey("destinationZone")) {
      destinationZone = _json["destinationZone"];
    }
    if (_json.containsKey("targetDisk")) {
      targetDisk = _json["targetDisk"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (destinationZone != null) {
      _json["destinationZone"] = destinationZone;
    }
    if (targetDisk != null) {
      _json["targetDisk"] = targetDisk;
    }
    return _json;
  }
}

/// Represents a Disk Type resource.
///
/// Google Compute Engine has two Disk Type resources:
///
/// * [Regional](/compute/docs/reference/rest/{$api_version}/regionDiskTypes) *
/// [Zonal](/compute/docs/reference/rest/{$api_version}/diskTypes)
///
/// You can choose from a variety of disk types based on your needs. For more
/// information, read Storage options.
///
/// The diskTypes resource represents disk types for a zonal persistent disk.
/// For more information, read Zonal persistent disks.
///
/// The regionDiskTypes resource represents disk types for a regional persistent
/// disk. For more information, read Regional persistent disks. (== resource_for
/// {$api_version}.diskTypes ==) (== resource_for {$api_version}.regionDiskTypes
/// ==)
class DiskType {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] Server-defined default disk size in GB.
  core.String defaultDiskSizeGb;

  /// [Output Only] The deprecation status associated with this disk type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional description of this resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#diskType for disk
  /// types.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] URL of the region where the disk type resides. Only
  /// applicable for regional resources. You must specify this field as part of
  /// the HTTP request URL. It is not settable as a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] An optional textual description of the valid disk size, such
  /// as "10GB-10TB".
  core.String validDiskSize;

  /// [Output Only] URL of the zone where the disk type resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String zone;

  DiskType();

  DiskType.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("defaultDiskSizeGb")) {
      defaultDiskSizeGb = _json["defaultDiskSizeGb"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("validDiskSize")) {
      validDiskSize = _json["validDiskSize"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (defaultDiskSizeGb != null) {
      _json["defaultDiskSizeGb"] = defaultDiskSizeGb;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (validDiskSize != null) {
      _json["validDiskSize"] = validDiskSize;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class DiskTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypeAggregatedListWarningData();

  DiskTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypeAggregatedListWarning();

  DiskTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<DiskTypeAggregatedListWarningData>(
              (value) => new DiskTypeAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class DiskTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DiskTypesScopedList resources.
  core.Map<core.String, DiskTypesScopedList> items;

  /// [Output Only] Type of resource. Always compute#diskTypeAggregatedList.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskTypeAggregatedListWarning warning;

  DiskTypeAggregatedList();

  DiskTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, DiskTypesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new DiskTypesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new DiskTypeAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<DiskTypesScopedList, core.Map<core.String, core.Object>>(
              items, (DiskTypesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DiskTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypeListWarningData();

  DiskTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypeListWarning();

  DiskTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<DiskTypeListWarningData>(
              (value) => new DiskTypeListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of disk types.
class DiskTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DiskType resources.
  core.List<DiskType> items;

  /// [Output Only] Type of resource. Always compute#diskTypeList for disk
  /// types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskTypeListWarning warning;

  DiskTypeList();

  DiskTypeList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<DiskType>((value) => new DiskType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new DiskTypeListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DiskTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypesScopedListWarningData();

  DiskTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of disk types
/// when the list is empty.
class DiskTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypesScopedListWarning();

  DiskTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<DiskTypesScopedListWarningData>(
              (value) => new DiskTypesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class DiskTypesScopedList {
  /// [Output Only] A list of disk types contained in this scope.
  core.List<DiskType> diskTypes;

  /// [Output Only] Informational warning which replaces the list of disk types
  /// when the list is empty.
  DiskTypesScopedListWarning warning;

  DiskTypesScopedList();

  DiskTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("diskTypes")) {
      diskTypes = (_json["diskTypes"] as core.List)
          .map<DiskType>((value) => new DiskType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new DiskTypesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskTypes != null) {
      _json["diskTypes"] = diskTypes.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class DisksAddResourcePoliciesRequest {
  /// Resource policies to be added to this disk. Currently you can only specify
  /// one policy here.
  core.List<core.String> resourcePolicies;

  DisksAddResourcePoliciesRequest();

  DisksAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    return _json;
  }
}

class DisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String> resourcePolicies;

  DisksRemoveResourcePoliciesRequest();

  DisksRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    return _json;
  }
}

class DisksResizeRequest {
  /// The new size of the persistent disk, which is specified in GB.
  core.String sizeGb;

  DisksResizeRequest();

  DisksResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey("sizeGb")) {
      sizeGb = _json["sizeGb"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sizeGb != null) {
      _json["sizeGb"] = sizeGb;
    }
    return _json;
  }
}

class DisksScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DisksScopedListWarningData();

  DisksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of disks when
/// the list is empty.
class DisksScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DisksScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DisksScopedListWarning();

  DisksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<DisksScopedListWarningData>(
              (value) => new DisksScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class DisksScopedList {
  /// [Output Only] A list of disks contained in this scope.
  core.List<Disk> disks;

  /// [Output Only] Informational warning which replaces the list of disks when
  /// the list is empty.
  DisksScopedListWarning warning;

  DisksScopedList();

  DisksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("disks")) {
      disks = (_json["disks"] as core.List)
          .map<Disk>((value) => new Disk.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new DisksScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (disks != null) {
      _json["disks"] = disks.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A set of Display Device options
class DisplayDevice {
  /// Defines whether the instance has Display enabled.
  core.bool enableDisplay;

  DisplayDevice();

  DisplayDevice.fromJson(core.Map _json) {
    if (_json.containsKey("enableDisplay")) {
      enableDisplay = _json["enableDisplay"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (enableDisplay != null) {
      _json["enableDisplay"] = enableDisplay;
    }
    return _json;
  }
}

class DistributionPolicy {
  /// Zones where the regional managed instance group will create and manage
  /// instances.
  core.List<DistributionPolicyZoneConfiguration> zones;

  DistributionPolicy();

  DistributionPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("zones")) {
      zones = (_json["zones"] as core.List)
          .map<DistributionPolicyZoneConfiguration>((value) =>
              new DistributionPolicyZoneConfiguration.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (zones != null) {
      _json["zones"] = zones.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class DistributionPolicyZoneConfiguration {
  /// The URL of the zone. The zone must exist in the region where the managed
  /// instance group is located.
  core.String zone;

  DistributionPolicyZoneConfiguration();

  DistributionPolicyZoneConfiguration.fromJson(core.Map _json) {
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

/// A Duration represents a fixed-length span of time represented as a count of
/// seconds and fractions of seconds at nanosecond resolution. It is independent
/// of any calendar and concepts like "day" or "month". Range is approximately
/// 10,000 years.
class Duration {
  /// Span of time that's a fraction of a second at nanosecond resolution.
  /// Durations less than one second are represented with a 0 `seconds` field
  /// and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
  core.int nanos;

  /// Span of time at a resolution of a second. Must be from 0 to
  /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
  /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
  core.String seconds;

  Duration();

  Duration.fromJson(core.Map _json) {
    if (_json.containsKey("nanos")) {
      nanos = _json["nanos"];
    }
    if (_json.containsKey("seconds")) {
      seconds = _json["seconds"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (nanos != null) {
      _json["nanos"] = nanos;
    }
    if (seconds != null) {
      _json["seconds"] = seconds;
    }
    return _json;
  }
}

class ExchangedPeeringRoute {
  /// The destination range of the route.
  core.String destRange;

  /// True if the peering route has been imported from a peer. The actual import
  /// happens if the field networkPeering.importCustomRoutes is true for this
  /// network, and networkPeering.exportCustomRoutes is true for the peer
  /// network, and the import does not result in a route conflict.
  core.bool imported;

  /// The region of peering route next hop, only applies to dynamic routes.
  core.String nextHopRegion;

  /// The priority of the peering route.
  core.int priority;

  /// The type of the peering route.
  /// Possible string values are:
  /// - "DYNAMIC_PEERING_ROUTE"
  /// - "STATIC_PEERING_ROUTE"
  /// - "SUBNET_PEERING_ROUTE"
  core.String type;

  ExchangedPeeringRoute();

  ExchangedPeeringRoute.fromJson(core.Map _json) {
    if (_json.containsKey("destRange")) {
      destRange = _json["destRange"];
    }
    if (_json.containsKey("imported")) {
      imported = _json["imported"];
    }
    if (_json.containsKey("nextHopRegion")) {
      nextHopRegion = _json["nextHopRegion"];
    }
    if (_json.containsKey("priority")) {
      priority = _json["priority"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (destRange != null) {
      _json["destRange"] = destRange;
    }
    if (imported != null) {
      _json["imported"] = imported;
    }
    if (nextHopRegion != null) {
      _json["nextHopRegion"] = nextHopRegion;
    }
    if (priority != null) {
      _json["priority"] = priority;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class ExchangedPeeringRoutesListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ExchangedPeeringRoutesListWarningData();

  ExchangedPeeringRoutesListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ExchangedPeeringRoutesListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ExchangedPeeringRoutesListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ExchangedPeeringRoutesListWarning();

  ExchangedPeeringRoutesListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ExchangedPeeringRoutesListWarningData>((value) =>
              new ExchangedPeeringRoutesListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ExchangedPeeringRoutesList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ExchangedPeeringRoute resources.
  core.List<ExchangedPeeringRoute> items;

  /// [Output Only] Type of resource. Always compute#exchangedPeeringRoutesList
  /// for exchanged peering routes lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ExchangedPeeringRoutesListWarning warning;

  ExchangedPeeringRoutesList();

  ExchangedPeeringRoutesList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<ExchangedPeeringRoute>(
              (value) => new ExchangedPeeringRoute.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new ExchangedPeeringRoutesListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax. CEL is a C-like expression language. The syntax and semantics of CEL
/// are documented at https://github.com/google/cel-spec.
///
/// Example (Comparison):
///
/// title: "Summary size limit" description: "Determines if a summary is less
/// than 100 chars" expression: "document.summary.size() < 100"
///
/// Example (Equality):
///
/// title: "Requestor is owner" description: "Determines if requestor is the
/// document owner" expression: "document.owner == request.auth.claims.email"
///
/// Example (Logic):
///
/// title: "Public documents" description: "Determine whether the document
/// should be publicly visible" expression: "document.type != 'private' &&
/// document.type != 'internal'"
///
/// Example (Data Manipulation):
///
/// title: "Notification string" description: "Create a notification string with
/// a timestamp." expression: "'New message received at ' +
/// string(document.create_time)"
///
/// The exact variables and functions that may be referenced within an
/// expression are determined by the service that evaluates it. See the service
/// documentation for additional information.
class Expr {
  /// Optional. Description of the expression. This is a longer text which
  /// describes the expression, e.g. when hovered over it in a UI.
  core.String description;

  /// Textual representation of an expression in Common Expression Language
  /// syntax.
  core.String expression;

  /// Optional. String indicating the location of the expression for error
  /// reporting, e.g. a file name and a position in the file.
  core.String location;

  /// Optional. Title for the expression, i.e. a short string describing its
  /// purpose. This can be used e.g. in UIs which allow to enter the expression.
  core.String title;

  Expr();

  Expr.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("expression")) {
      expression = _json["expression"];
    }
    if (_json.containsKey("location")) {
      location = _json["location"];
    }
    if (_json.containsKey("title")) {
      title = _json["title"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (expression != null) {
      _json["expression"] = expression;
    }
    if (location != null) {
      _json["location"] = location;
    }
    if (title != null) {
      _json["title"] = title;
    }
    return _json;
  }
}

/// External VPN gateway is the on-premises VPN gateway(s) or another cloud
/// provider's VPN gateway that connects to your Google Cloud VPN gateway. To
/// create a highly available VPN from Google Cloud to your on-premises side or
/// another Cloud provider's VPN gateway, you must create a external VPN gateway
/// resource in GCP, which provides the information to GCP about your external
/// VPN gateway.
class ExternalVpnGateway {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// List of interfaces for this external VPN gateway.
  core.List<ExternalVpnGatewayInterface> interfaces;

  /// [Output Only] Type of the resource. Always compute#externalVpnGateway for
  /// externalVpnGateways.
  core.String kind;

  /// A fingerprint for the labels being applied to this ExternalVpnGateway,
  /// which is essentially a hash of the labels set used for optimistic locking.
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// ExternalVpnGateway.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels for this resource. These can only be added or modified by the
  /// setLabels method. Each label key/value pair must comply with RFC1035.
  /// Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Indicates the user-supplied redundancy type of this external VPN gateway.
  /// Possible string values are:
  /// - "FOUR_IPS_REDUNDANCY"
  /// - "SINGLE_IP_INTERNALLY_REDUNDANT"
  /// - "TWO_IPS_REDUNDANCY"
  core.String redundancyType;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  ExternalVpnGateway();

  ExternalVpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("interfaces")) {
      interfaces = (_json["interfaces"] as core.List)
          .map<ExternalVpnGatewayInterface>(
              (value) => new ExternalVpnGatewayInterface.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("redundancyType")) {
      redundancyType = _json["redundancyType"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (interfaces != null) {
      _json["interfaces"] =
          interfaces.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (redundancyType != null) {
      _json["redundancyType"] = redundancyType;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

/// The interface for the external VPN gateway.
class ExternalVpnGatewayInterface {
  /// The numeric ID of this interface. The allowed input values for this id for
  /// different redundancy types of external VPN gateway:
  /// SINGLE_IP_INTERNALLY_REDUNDANT - 0 TWO_IPS_REDUNDANCY - 0, 1
  /// FOUR_IPS_REDUNDANCY - 0, 1, 2, 3
  core.int id;

  /// IP address of the interface in the external VPN gateway. Only IPv4 is
  /// supported. This IP address can be either from your on-premise gateway or
  /// another Cloud provider's VPN gateway, it cannot be an IP address from
  /// Google Compute Engine.
  core.String ipAddress;

  ExternalVpnGatewayInterface();

  ExternalVpnGatewayInterface.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    return _json;
  }
}

class ExternalVpnGatewayListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ExternalVpnGatewayListWarningData();

  ExternalVpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ExternalVpnGatewayListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ExternalVpnGatewayListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ExternalVpnGatewayListWarning();

  ExternalVpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ExternalVpnGatewayListWarningData>(
              (value) => new ExternalVpnGatewayListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of externalVpnGateways.
class ExternalVpnGatewayList {
  core.String etag;

  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ExternalVpnGateway resources.
  core.List<ExternalVpnGateway> items;

  /// [Output Only] Type of resource. Always compute#externalVpnGatewayList  for
  /// lists of externalVpnGateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ExternalVpnGatewayListWarning warning;

  ExternalVpnGatewayList();

  ExternalVpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey("etag")) {
      etag = _json["etag"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<ExternalVpnGateway>(
              (value) => new ExternalVpnGateway.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ExternalVpnGatewayListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (etag != null) {
      _json["etag"] = etag;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class FileContentBuffer {
  /// The raw content in the secure keys file.
  core.String content;
  core.List<core.int> get contentAsBytes {
    return convert.base64.decode(content);
  }

  set contentAsBytes(core.List<core.int> _bytes) {
    content =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  ///
  /// Possible string values are:
  /// - "BIN"
  /// - "UNDEFINED"
  /// - "X509"
  core.String fileType;

  FileContentBuffer();

  FileContentBuffer.fromJson(core.Map _json) {
    if (_json.containsKey("content")) {
      content = _json["content"];
    }
    if (_json.containsKey("fileType")) {
      fileType = _json["fileType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (content != null) {
      _json["content"] = content;
    }
    if (fileType != null) {
      _json["fileType"] = fileType;
    }
    return _json;
  }
}

class FirewallAllowed {
  /// The IP protocol to which this rule applies. The protocol type is required
  /// when creating a firewall rule. This value can either be one of the
  /// following well known protocol strings (tcp, udp, icmp, esp, ah, ipip,
  /// sctp) or the IP protocol number.
  core.String IPProtocol;

  /// An optional list of ports to which this rule applies. This field is only
  /// applicable for the UDP or TCP protocol. Each entry must be either an
  /// integer or a range. If not specified, this rule applies to connections
  /// through any port.
  ///
  /// Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
  core.List<core.String> ports;

  FirewallAllowed();

  FirewallAllowed.fromJson(core.Map _json) {
    if (_json.containsKey("IPProtocol")) {
      IPProtocol = _json["IPProtocol"];
    }
    if (_json.containsKey("ports")) {
      ports = (_json["ports"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPProtocol != null) {
      _json["IPProtocol"] = IPProtocol;
    }
    if (ports != null) {
      _json["ports"] = ports;
    }
    return _json;
  }
}

class FirewallDenied {
  /// The IP protocol to which this rule applies. The protocol type is required
  /// when creating a firewall rule. This value can either be one of the
  /// following well known protocol strings (tcp, udp, icmp, esp, ah, ipip,
  /// sctp) or the IP protocol number.
  core.String IPProtocol;

  /// An optional list of ports to which this rule applies. This field is only
  /// applicable for the UDP or TCP protocol. Each entry must be either an
  /// integer or a range. If not specified, this rule applies to connections
  /// through any port.
  ///
  /// Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
  core.List<core.String> ports;

  FirewallDenied();

  FirewallDenied.fromJson(core.Map _json) {
    if (_json.containsKey("IPProtocol")) {
      IPProtocol = _json["IPProtocol"];
    }
    if (_json.containsKey("ports")) {
      ports = (_json["ports"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPProtocol != null) {
      _json["IPProtocol"] = IPProtocol;
    }
    if (ports != null) {
      _json["ports"] = ports;
    }
    return _json;
  }
}

/// Represents a Firewall Rule resource.
///
/// Firewall rules allow or deny ingress traffic to, and egress traffic from
/// your instances. For more information, read Firewall rules.
class Firewall {
  /// The list of ALLOW rules specified by this firewall. Each rule specifies a
  /// protocol and port-range tuple that describes a permitted connection.
  core.List<FirewallAllowed> allowed;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The list of DENY rules specified by this firewall. Each rule specifies a
  /// protocol and port-range tuple that describes a denied connection.
  core.List<FirewallDenied> denied;

  /// An optional description of this resource. Provide this field when you
  /// create the resource.
  core.String description;

  /// If destination ranges are specified, the firewall rule applies only to
  /// traffic that has destination IP address in these ranges. These ranges must
  /// be expressed in CIDR format. Only IPv4 is supported.
  core.List<core.String> destinationRanges;

  /// Direction of traffic to which this firewall applies, either `INGRESS` or
  /// `EGRESS`. The default is `INGRESS`. For `INGRESS` traffic, you cannot
  /// specify the destinationRanges field, and for `EGRESS` traffic, you cannot
  /// specify the sourceRanges or sourceTags fields.
  /// Possible string values are:
  /// - "EGRESS"
  /// - "INGRESS"
  core.String direction;

  /// Denotes whether the firewall rule is disabled. When set to true, the
  /// firewall rule is not enforced and the network behaves as if it did not
  /// exist. If this is unspecified, the firewall rule will be enabled.
  core.bool disabled;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#firewall for firewall
  /// rules.
  core.String kind;

  /// This field denotes the logging options for a particular firewall rule. If
  /// logging is enabled, logs will be exported to Stackdriver.
  FirewallLogConfig logConfig;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?. The first character must be a
  /// lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String name;

  /// URL of the network resource for this firewall rule. If not specified when
  /// creating a firewall rule, the default network is used:
  /// global/networks/default
  /// If you choose to specify this field, you can specify the network as a full
  /// or partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network
  /// - projects/myproject/global/networks/my-network
  /// - global/networks/default
  core.String network;

  /// Priority for this rule. This is an integer between `0` and `65535`, both
  /// inclusive. The default value is `1000`. Relative priorities determine
  /// which rule takes effect if multiple rules apply. Lower values indicate
  /// higher priority. For example, a rule with priority `0` has higher
  /// precedence than a rule with priority `1`. DENY rules take precedence over
  /// ALLOW rules if they have equal priority. Note that VPC networks have
  /// implied rules with a priority of `65535`. To avoid conflicts with the
  /// implied rules, use a priority number less than `65535`.
  core.int priority;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// If source ranges are specified, the firewall rule applies only to traffic
  /// that has a source IP address in these ranges. These ranges must be
  /// expressed in CIDR format. One or both of sourceRanges and sourceTags may
  /// be set. If both fields are set, the rule applies to traffic that has a
  /// source IP address within sourceRanges OR a source IP from a resource with
  /// a matching tag listed in the sourceTags field. The connection does not
  /// need to match both fields for the rule to apply. Only IPv4 is supported.
  core.List<core.String> sourceRanges;

  /// If source service accounts are specified, the firewall rules apply only to
  /// traffic originating from an instance with a service account in this list.
  /// Source service accounts cannot be used to control traffic to an instance's
  /// external IP address because service accounts are associated with an
  /// instance, not an IP address. sourceRanges can be set at the same time as
  /// sourceServiceAccounts. If both are set, the firewall applies to traffic
  /// that has a source IP address within the sourceRanges OR a source IP that
  /// belongs to an instance with service account listed in
  /// sourceServiceAccount. The connection does not need to match both fields
  /// for the firewall to apply. sourceServiceAccounts cannot be used at the
  /// same time as sourceTags or targetTags.
  core.List<core.String> sourceServiceAccounts;

  /// If source tags are specified, the firewall rule applies only to traffic
  /// with source IPs that match the primary network interfaces of VM instances
  /// that have the tag and are in the same VPC network. Source tags cannot be
  /// used to control traffic to an instance's external IP address, it only
  /// applies to traffic between instances in the same virtual network. Because
  /// tags are associated with instances, not IP addresses. One or both of
  /// sourceRanges and sourceTags may be set. If both fields are set, the
  /// firewall applies to traffic that has a source IP address within
  /// sourceRanges OR a source IP from a resource with a matching tag listed in
  /// the sourceTags field. The connection does not need to match both fields
  /// for the firewall to apply.
  core.List<core.String> sourceTags;

  /// A list of service accounts indicating sets of instances located in the
  /// network that may make network connections as specified in allowed[].
  /// targetServiceAccounts cannot be used at the same time as targetTags or
  /// sourceTags. If neither targetServiceAccounts nor targetTags are specified,
  /// the firewall rule applies to all instances on the specified network.
  core.List<core.String> targetServiceAccounts;

  /// A list of tags that controls which instances the firewall rule applies to.
  /// If targetTags are specified, then the firewall rule applies only to
  /// instances in the VPC network that have one of those tags. If no targetTags
  /// are specified, the firewall rule applies to all instances on the specified
  /// network.
  core.List<core.String> targetTags;

  Firewall();

  Firewall.fromJson(core.Map _json) {
    if (_json.containsKey("allowed")) {
      allowed = (_json["allowed"] as core.List)
          .map<FirewallAllowed>((value) => new FirewallAllowed.fromJson(value))
          .toList();
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("denied")) {
      denied = (_json["denied"] as core.List)
          .map<FirewallDenied>((value) => new FirewallDenied.fromJson(value))
          .toList();
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("destinationRanges")) {
      destinationRanges =
          (_json["destinationRanges"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("direction")) {
      direction = _json["direction"];
    }
    if (_json.containsKey("disabled")) {
      disabled = _json["disabled"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("logConfig")) {
      logConfig = new FirewallLogConfig.fromJson(_json["logConfig"]);
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("priority")) {
      priority = _json["priority"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sourceRanges")) {
      sourceRanges = (_json["sourceRanges"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("sourceServiceAccounts")) {
      sourceServiceAccounts =
          (_json["sourceServiceAccounts"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("sourceTags")) {
      sourceTags = (_json["sourceTags"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("targetServiceAccounts")) {
      targetServiceAccounts =
          (_json["targetServiceAccounts"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("targetTags")) {
      targetTags = (_json["targetTags"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (allowed != null) {
      _json["allowed"] = allowed.map((value) => (value).toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (denied != null) {
      _json["denied"] = denied.map((value) => (value).toJson()).toList();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (destinationRanges != null) {
      _json["destinationRanges"] = destinationRanges;
    }
    if (direction != null) {
      _json["direction"] = direction;
    }
    if (disabled != null) {
      _json["disabled"] = disabled;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (logConfig != null) {
      _json["logConfig"] = (logConfig).toJson();
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (priority != null) {
      _json["priority"] = priority;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sourceRanges != null) {
      _json["sourceRanges"] = sourceRanges;
    }
    if (sourceServiceAccounts != null) {
      _json["sourceServiceAccounts"] = sourceServiceAccounts;
    }
    if (sourceTags != null) {
      _json["sourceTags"] = sourceTags;
    }
    if (targetServiceAccounts != null) {
      _json["targetServiceAccounts"] = targetServiceAccounts;
    }
    if (targetTags != null) {
      _json["targetTags"] = targetTags;
    }
    return _json;
  }
}

class FirewallListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  FirewallListWarningData();

  FirewallListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class FirewallListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<FirewallListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  FirewallListWarning();

  FirewallListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<FirewallListWarningData>(
              (value) => new FirewallListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of firewalls.
class FirewallList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Firewall resources.
  core.List<Firewall> items;

  /// [Output Only] Type of resource. Always compute#firewallList for lists of
  /// firewalls.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  FirewallListWarning warning;

  FirewallList();

  FirewallList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Firewall>((value) => new Firewall.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new FirewallListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// The available logging options for a firewall rule.
class FirewallLogConfig {
  /// This field denotes whether to enable logging for a particular firewall
  /// rule.
  core.bool enable;

  FirewallLogConfig();

  FirewallLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey("enable")) {
      enable = _json["enable"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (enable != null) {
      _json["enable"] = enable;
    }
    return _json;
  }
}

/// Encapsulates numeric value that can be either absolute or relative.
class FixedOrPercent {
  /// [Output Only] Absolute value of VM instances calculated based on the
  /// specific mode.
  ///
  ///
  /// - If the value is fixed, then the calculated value is equal to the fixed
  /// value.
  /// - If the value is a percent, then the calculated value is percent/100 *
  /// targetSize. For example, the calculated value of a 80% of a managed
  /// instance group with 150 instances would be (80/100 * 150) = 120 VM
  /// instances. If there is a remainder, the number is rounded up.
  core.int calculated;

  /// Specifies a fixed number of VM instances. This must be a positive integer.
  core.int fixed;

  /// Specifies a percentage of instances between 0 to 100%, inclusive. For
  /// example, specify 80 for 80%.
  core.int percent;

  FixedOrPercent();

  FixedOrPercent.fromJson(core.Map _json) {
    if (_json.containsKey("calculated")) {
      calculated = _json["calculated"];
    }
    if (_json.containsKey("fixed")) {
      fixed = _json["fixed"];
    }
    if (_json.containsKey("percent")) {
      percent = _json["percent"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (calculated != null) {
      _json["calculated"] = calculated;
    }
    if (fixed != null) {
      _json["fixed"] = fixed;
    }
    if (percent != null) {
      _json["percent"] = percent;
    }
    return _json;
  }
}

/// Represents a Forwarding Rule resource.
///
/// Forwarding rule resources in GCP can be either regional or global in scope:
///
/// *
/// [Global](/compute/docs/reference/rest/{$api_version}/globalForwardingRules)
/// * [Regional](/compute/docs/reference/rest/{$api_version}/forwardingRules)
///
/// A forwarding rule and its corresponding IP address represent the frontend
/// configuration of a Google Cloud Platform load balancer. Forwarding rules can
/// also reference target instances and Cloud VPN Classic gateways
/// (targetVpnGateway).
///
/// For more information, read Forwarding rule concepts and Using protocol
/// forwarding.
///
/// (== resource_for {$api_version}.forwardingRules ==) (== resource_for
/// {$api_version}.globalForwardingRules ==) (== resource_for
/// {$api_version}.regionForwardingRules ==)
class ForwardingRule {
  /// IP address that this forwarding rule serves. When a client sends traffic
  /// to this IP address, the forwarding rule directs the traffic to the target
  /// that you specify in the forwarding rule.
  ///
  /// If you don't specify a reserved IP address, an ephemeral IP address is
  /// assigned. Methods for specifying an IP address:
  ///
  /// * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in
  /// https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name
  /// * Partial URL or by name, as in: *
  /// projects/project_id/regions/region/addresses/address-name *
  /// regions/region/addresses/address-name * global/addresses/address-name *
  /// address-name
  ///
  /// The loadBalancingScheme and the forwarding rule's target determine the
  /// type of IP address that you can use. For detailed information, refer to
  /// [IP address
  /// specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
  core.String IPAddress;

  /// The IP protocol to which this rule applies. For protocol forwarding, valid
  /// options are TCP, UDP, ESP, AH, SCTP or ICMP.
  ///
  /// For Internal TCP/UDP Load Balancing, the load balancing scheme is
  /// INTERNAL, and one of TCP or UDP are valid. For Traffic Director, the load
  /// balancing scheme is INTERNAL_SELF_MANAGED, and only TCPis valid. For
  /// Internal HTTP(S) Load Balancing, the load balancing scheme is
  /// INTERNAL_MANAGED, and only TCP is valid. For HTTP(S), SSL Proxy, and TCP
  /// Proxy Load Balancing, the load balancing scheme is EXTERNAL and only TCP
  /// is valid. For Network TCP/UDP Load Balancing, the load balancing scheme is
  /// EXTERNAL, and one of TCP or UDP is valid.
  /// Possible string values are:
  /// - "AH"
  /// - "ESP"
  /// - "ICMP"
  /// - "SCTP"
  /// - "TCP"
  /// - "UDP"
  core.String IPProtocol;

  /// This field is used along with the backend_service field for internal load
  /// balancing or with the target field for internal TargetInstance. This field
  /// cannot be used with port or portRange fields.
  ///
  /// When the load balancing scheme is INTERNAL and protocol is TCP/UDP,
  /// specify this field to allow packets addressed to any ports will be
  /// forwarded to the backends configured with this forwarding rule.
  core.bool allPorts;

  /// This field is used along with the backend_service field for internal load
  /// balancing or with the target field for internal TargetInstance. If the
  /// field is set to TRUE, clients can access ILB from all regions. Otherwise
  /// only allows access from clients in the same region as the internal load
  /// balancer.
  core.bool allowGlobalAccess;

  /// This field is only used for INTERNAL load balancing.
  ///
  /// For internal load balancing, this field identifies the BackendService
  /// resource to receive the matched traffic.
  core.String backendService;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a ForwardingRule. Include the fingerprint in patch
  /// request to ensure that you do not overwrite changes that were applied from
  /// another concurrent request.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// ForwardingRule.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The IP Version that will be used by this forwarding rule. Valid options
  /// are IPV4 or IPV6. This can only be specified for an external global
  /// forwarding rule.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String ipVersion;

  /// Indicates whether or not this load balancer can be used as a collector for
  /// packet mirroring. To prevent mirroring loops, instances behind this load
  /// balancer will not have their traffic mirrored even if a PacketMirroring
  /// rule applies to them. This can only be set to true for load balancers that
  /// have their loadBalancingScheme set to INTERNAL.
  core.bool isMirroringCollector;

  /// [Output Only] Type of the resource. Always compute#forwardingRule for
  /// Forwarding Rule resources.
  core.String kind;

  /// Specifies the forwarding rule type.
  ///
  ///
  /// - EXTERNAL is used for:
  /// - Classic Cloud VPN gateways
  /// - Protocol forwarding to VMs from an external IP address
  /// - The following load balancers: HTTP(S), SSL Proxy, TCP Proxy, and Network
  /// TCP/UDP
  /// - INTERNAL is used for:
  /// - Protocol forwarding to VMs from an internal IP address
  /// - Internal TCP/UDP load balancers
  /// - INTERNAL_MANAGED is used for:
  /// - Internal HTTP(S) load balancers
  /// - INTERNAL_SELF_MANAGED is used for:
  /// - Traffic Director
  ///
  /// For more information about forwarding rules, refer to Forwarding rule
  /// concepts.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INTERNAL_MANAGED"
  /// - "INTERNAL_SELF_MANAGED"
  /// - "INVALID"
  core.String loadBalancingScheme;

  /// Opaque filter criteria used by Loadbalancer to restrict routing
  /// configuration to a limited set of xDS compliant clients. In their xDS
  /// requests to Loadbalancer, xDS clients present node metadata. If a match
  /// takes place, the relevant configuration is made available to those
  /// proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap)
  /// referenced by the ForwardingRule will not be visible to those proxies.
  /// For each metadataFilter in this list, if its filterMatchCriteria is set to
  /// MATCH_ANY, at least one of the filterLabels must match the corresponding
  /// label provided in the metadata. If its filterMatchCriteria is set to
  /// MATCH_ALL, then all of its filterLabels must match with corresponding
  /// labels provided in the metadata.
  /// metadataFilters specified here will be applifed before those specified in
  /// the UrlMap that this ForwardingRule references.
  /// metadataFilters only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.List<MetadataFilter> metadataFilters;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// This field is not used for external load balancing.
  ///
  /// For INTERNAL and INTERNAL_SELF_MANAGED load balancing, this field
  /// identifies the network that the load balanced IP should belong to for this
  /// Forwarding Rule. If this field is not specified, the default network will
  /// be used.
  core.String network;

  /// This signifies the networking tier used for configuring this load balancer
  /// and can only take the following values: PREMIUM, STANDARD.
  ///
  /// For regional ForwardingRule, the valid values are PREMIUM and STANDARD.
  /// For GlobalForwardingRule, the valid value is PREMIUM.
  ///
  /// If this field is not specified, it is assumed to be PREMIUM. If IPAddress
  /// is specified, this value must be equal to the networkTier of the Address.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String networkTier;

  /// When the load balancing scheme is EXTERNAL, INTERNAL_SELF_MANAGED and
  /// INTERNAL_MANAGED, you can specify a port_range. Use with a forwarding rule
  /// that points to a target proxy or a target pool. Do not use with a
  /// forwarding rule that points to a backend service. This field is used along
  /// with the target field for TargetHttpProxy, TargetHttpsProxy,
  /// TargetSslProxy, TargetTcpProxy, TargetVpnGateway, TargetPool,
  /// TargetInstance.
  ///
  /// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
  /// addressed to ports in the specified range will be forwarded to target.
  /// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
  /// disjoint port ranges.
  ///
  /// Some types of forwarding target have constraints on the acceptable ports:
  /// - TargetHttpProxy: 80, 8080
  /// - TargetHttpsProxy: 443
  /// - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
  /// 1688, 1883, 5222
  /// - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
  /// 1688, 1883, 5222
  /// - TargetVpnGateway: 500, 4500
  core.String portRange;

  /// This field is used along with the backend_service field for internal load
  /// balancing.
  ///
  /// When the load balancing scheme is INTERNAL, a list of ports can be
  /// configured, for example, ['80'], ['8000','9000']. Only packets addressed
  /// to these ports are forwarded to the backends configured with the
  /// forwarding rule.
  ///
  /// If the forwarding rule's loadBalancingScheme is INTERNAL, you can specify
  /// ports in one of the following ways:
  ///
  /// * A list of up to five ports, which can be non-contiguous * Keyword ALL,
  /// which causes the forwarding rule to forward traffic on any port of the
  /// forwarding rule's protocol.
  core.List<core.String> ports;

  /// [Output Only] URL of the region where the regional forwarding rule
  /// resides. This field is not applicable to global forwarding rules. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// An optional prefix to the service name for this Forwarding Rule. If
  /// specified, the prefix is the first label of the fully qualified service
  /// name.
  ///
  /// The label must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the label must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  ///
  /// This field is only used for internal load balancing.
  core.String serviceLabel;

  /// [Output Only] The internal fully qualified service name for this
  /// Forwarding Rule.
  ///
  /// This field is only used for internal load balancing.
  core.String serviceName;

  /// This field is only used for INTERNAL load balancing.
  ///
  /// For internal load balancing, this field identifies the subnetwork that the
  /// load balanced IP should belong to for this Forwarding Rule.
  ///
  /// If the network specified is in auto subnet mode, this field is optional.
  /// However, if the network is in custom subnet mode, a subnetwork must be
  /// specified.
  core.String subnetwork;

  /// The URL of the target resource to receive the matched traffic. For
  /// regional forwarding rules, this target must live in the same region as the
  /// forwarding rule. For global forwarding rules, this target must be a global
  /// load balancing resource. The forwarded traffic must be of a type
  /// appropriate to the target object. For INTERNAL_SELF_MANAGED load
  /// balancing, only targetHttpProxy is valid, not targetHttpsProxy.
  core.String target;

  ForwardingRule();

  ForwardingRule.fromJson(core.Map _json) {
    if (_json.containsKey("IPAddress")) {
      IPAddress = _json["IPAddress"];
    }
    if (_json.containsKey("IPProtocol")) {
      IPProtocol = _json["IPProtocol"];
    }
    if (_json.containsKey("allPorts")) {
      allPorts = _json["allPorts"];
    }
    if (_json.containsKey("allowGlobalAccess")) {
      allowGlobalAccess = _json["allowGlobalAccess"];
    }
    if (_json.containsKey("backendService")) {
      backendService = _json["backendService"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ipVersion")) {
      ipVersion = _json["ipVersion"];
    }
    if (_json.containsKey("isMirroringCollector")) {
      isMirroringCollector = _json["isMirroringCollector"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("loadBalancingScheme")) {
      loadBalancingScheme = _json["loadBalancingScheme"];
    }
    if (_json.containsKey("metadataFilters")) {
      metadataFilters = (_json["metadataFilters"] as core.List)
          .map<MetadataFilter>((value) => new MetadataFilter.fromJson(value))
          .toList();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("networkTier")) {
      networkTier = _json["networkTier"];
    }
    if (_json.containsKey("portRange")) {
      portRange = _json["portRange"];
    }
    if (_json.containsKey("ports")) {
      ports = (_json["ports"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("serviceLabel")) {
      serviceLabel = _json["serviceLabel"];
    }
    if (_json.containsKey("serviceName")) {
      serviceName = _json["serviceName"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
    if (_json.containsKey("target")) {
      target = _json["target"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPAddress != null) {
      _json["IPAddress"] = IPAddress;
    }
    if (IPProtocol != null) {
      _json["IPProtocol"] = IPProtocol;
    }
    if (allPorts != null) {
      _json["allPorts"] = allPorts;
    }
    if (allowGlobalAccess != null) {
      _json["allowGlobalAccess"] = allowGlobalAccess;
    }
    if (backendService != null) {
      _json["backendService"] = backendService;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (ipVersion != null) {
      _json["ipVersion"] = ipVersion;
    }
    if (isMirroringCollector != null) {
      _json["isMirroringCollector"] = isMirroringCollector;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (loadBalancingScheme != null) {
      _json["loadBalancingScheme"] = loadBalancingScheme;
    }
    if (metadataFilters != null) {
      _json["metadataFilters"] =
          metadataFilters.map((value) => (value).toJson()).toList();
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (networkTier != null) {
      _json["networkTier"] = networkTier;
    }
    if (portRange != null) {
      _json["portRange"] = portRange;
    }
    if (ports != null) {
      _json["ports"] = ports;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (serviceLabel != null) {
      _json["serviceLabel"] = serviceLabel;
    }
    if (serviceName != null) {
      _json["serviceName"] = serviceName;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    if (target != null) {
      _json["target"] = target;
    }
    return _json;
  }
}

class ForwardingRuleAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRuleAggregatedListWarningData();

  ForwardingRuleAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ForwardingRuleAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRuleAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRuleAggregatedListWarning();

  ForwardingRuleAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ForwardingRuleAggregatedListWarningData>((value) =>
              new ForwardingRuleAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ForwardingRuleAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ForwardingRulesScopedList resources.
  core.Map<core.String, ForwardingRulesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#forwardingRuleAggregatedList for lists of forwarding rules.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ForwardingRuleAggregatedListWarning warning;

  ForwardingRuleAggregatedList();

  ForwardingRuleAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, ForwardingRulesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new ForwardingRulesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new ForwardingRuleAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<ForwardingRulesScopedList,
              core.Map<core.String, core.Object>>(
          items, (ForwardingRulesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ForwardingRuleListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRuleListWarningData();

  ForwardingRuleListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ForwardingRuleListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRuleListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRuleListWarning();

  ForwardingRuleListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ForwardingRuleListWarningData>(
              (value) => new ForwardingRuleListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of ForwardingRule resources.
class ForwardingRuleList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ForwardingRule resources.
  core.List<ForwardingRule> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ForwardingRuleListWarning warning;

  ForwardingRuleList();

  ForwardingRuleList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<ForwardingRule>((value) => new ForwardingRule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ForwardingRuleListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ForwardingRuleReference {
  core.String forwardingRule;

  ForwardingRuleReference();

  ForwardingRuleReference.fromJson(core.Map _json) {
    if (_json.containsKey("forwardingRule")) {
      forwardingRule = _json["forwardingRule"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (forwardingRule != null) {
      _json["forwardingRule"] = forwardingRule;
    }
    return _json;
  }
}

class ForwardingRulesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRulesScopedListWarningData();

  ForwardingRulesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of forwarding rules when the
/// list is empty.
class ForwardingRulesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRulesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRulesScopedListWarning();

  ForwardingRulesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ForwardingRulesScopedListWarningData>((value) =>
              new ForwardingRulesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ForwardingRulesScopedList {
  /// A list of forwarding rules contained in this scope.
  core.List<ForwardingRule> forwardingRules;

  /// Informational warning which replaces the list of forwarding rules when the
  /// list is empty.
  ForwardingRulesScopedListWarning warning;

  ForwardingRulesScopedList();

  ForwardingRulesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("forwardingRules")) {
      forwardingRules = (_json["forwardingRules"] as core.List)
          .map<ForwardingRule>((value) => new ForwardingRule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new ForwardingRulesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (forwardingRules != null) {
      _json["forwardingRules"] =
          forwardingRules.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class GlobalNetworkEndpointGroupsAttachEndpointsRequest {
  /// The list of network endpoints to be attached.
  core.List<NetworkEndpoint> networkEndpoints;

  GlobalNetworkEndpointGroupsAttachEndpointsRequest();

  GlobalNetworkEndpointGroupsAttachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("networkEndpoints")) {
      networkEndpoints = (_json["networkEndpoints"] as core.List)
          .map<NetworkEndpoint>((value) => new NetworkEndpoint.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (networkEndpoints != null) {
      _json["networkEndpoints"] =
          networkEndpoints.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class GlobalNetworkEndpointGroupsDetachEndpointsRequest {
  /// The list of network endpoints to be detached.
  core.List<NetworkEndpoint> networkEndpoints;

  GlobalNetworkEndpointGroupsDetachEndpointsRequest();

  GlobalNetworkEndpointGroupsDetachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("networkEndpoints")) {
      networkEndpoints = (_json["networkEndpoints"] as core.List)
          .map<NetworkEndpoint>((value) => new NetworkEndpoint.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (networkEndpoints != null) {
      _json["networkEndpoints"] =
          networkEndpoints.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class GlobalSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts. The fingerprint is initially generated by Compute Engine
  /// and changes after every request to modify or update labels. You must
  /// always provide an up-to-date fingerprint hash when updating or changing
  /// labels, otherwise the request will fail with error 412 conditionNotMet.
  /// Make a get() request to the resource to get the latest fingerprint.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// A list of labels to apply for this resource. Each label key & value must
  /// comply with RFC1035. Specifically, the name must be 1-63 characters long
  /// and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
  /// the first character must be a lowercase letter, and all following
  /// characters must be a dash, lowercase letter, or digit, except the last
  /// character, which cannot be a dash. For example, "webserver-frontend":
  /// "images". A label value can also be empty (e.g. "my-label": "").
  core.Map<core.String, core.String> labels;

  GlobalSetLabelsRequest();

  GlobalSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    return _json;
  }
}

class GlobalSetPolicyRequest {
  /// Flatten Policy to create a backward compatible wire-format. Deprecated.
  /// Use 'policy' to specify bindings.
  core.List<Binding> bindings;

  /// Flatten Policy to create a backward compatible wire-format. Deprecated.
  /// Use 'policy' to specify the etag.
  core.String etag;
  core.List<core.int> get etagAsBytes {
    return convert.base64.decode(etag);
  }

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'. The size of
  /// the policy is limited to a few 10s of KB. An empty policy is in general a
  /// valid policy but certain services (like Projects) might reject them.
  Policy policy;

  GlobalSetPolicyRequest();

  GlobalSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey("bindings")) {
      bindings = (_json["bindings"] as core.List)
          .map<Binding>((value) => new Binding.fromJson(value))
          .toList();
    }
    if (_json.containsKey("etag")) {
      etag = _json["etag"];
    }
    if (_json.containsKey("policy")) {
      policy = new Policy.fromJson(_json["policy"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bindings != null) {
      _json["bindings"] = bindings.map((value) => (value).toJson()).toList();
    }
    if (etag != null) {
      _json["etag"] = etag;
    }
    if (policy != null) {
      _json["policy"] = (policy).toJson();
    }
    return _json;
  }
}

/// A guest attributes entry.
class GuestAttributes {
  /// [Output Only] Type of the resource. Always compute#guestAttributes for
  /// guest attributes entry.
  core.String kind;

  /// The path to be queried. This can be the default namespace ('/') or a
  /// nested namespace ('/\/') or a specified key ('/\/\')
  core.String queryPath;

  /// [Output Only] The value of the requested queried path.
  GuestAttributesValue queryValue;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// The key to search for.
  core.String variableKey;

  /// [Output Only] The value found for the requested key.
  core.String variableValue;

  GuestAttributes();

  GuestAttributes.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("queryPath")) {
      queryPath = _json["queryPath"];
    }
    if (_json.containsKey("queryValue")) {
      queryValue = new GuestAttributesValue.fromJson(_json["queryValue"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("variableKey")) {
      variableKey = _json["variableKey"];
    }
    if (_json.containsKey("variableValue")) {
      variableValue = _json["variableValue"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (queryPath != null) {
      _json["queryPath"] = queryPath;
    }
    if (queryValue != null) {
      _json["queryValue"] = (queryValue).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (variableKey != null) {
      _json["variableKey"] = variableKey;
    }
    if (variableValue != null) {
      _json["variableValue"] = variableValue;
    }
    return _json;
  }
}

/// A guest attributes namespace/key/value entry.
class GuestAttributesEntry {
  /// Key for the guest attribute entry.
  core.String key;

  /// Namespace for the guest attribute entry.
  core.String namespace;

  /// Value for the guest attribute entry.
  core.String value;

  GuestAttributesEntry();

  GuestAttributesEntry.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("namespace")) {
      namespace = _json["namespace"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (namespace != null) {
      _json["namespace"] = namespace;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Array of guest attribute namespace/key/value tuples.
class GuestAttributesValue {
  core.List<GuestAttributesEntry> items;

  GuestAttributesValue();

  GuestAttributesValue.fromJson(core.Map _json) {
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<GuestAttributesEntry>(
              (value) => new GuestAttributesEntry.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// Guest OS features.
class GuestOsFeature {
  /// The ID of a supported feature. Read  Enabling guest operating system
  /// features to see a list of available options.
  /// Possible string values are:
  /// - "FEATURE_TYPE_UNSPECIFIED"
  /// - "MULTI_IP_SUBNET"
  /// - "SECURE_BOOT"
  /// - "UEFI_COMPATIBLE"
  /// - "VIRTIO_SCSI_MULTIQUEUE"
  /// - "WINDOWS"
  core.String type;

  GuestOsFeature();

  GuestOsFeature.fromJson(core.Map _json) {
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class HTTP2HealthCheck {
  /// The value of the host header in the HTTP/2 health check request. If left
  /// empty (default value), the IP on behalf of which this health check is
  /// performed will be used.
  core.String host;

  /// The TCP port number for the health check request. The default value is
  /// 443. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, HTTP2 health check follows behavior specified in port
  /// and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The request path of the HTTP/2 health check request. The default value is
  /// /.
  core.String requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String response;

  HTTP2HealthCheck();

  HTTP2HealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("portSpecification")) {
      portSpecification = _json["portSpecification"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
    if (_json.containsKey("response")) {
      response = _json["response"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (host != null) {
      _json["host"] = host;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (portSpecification != null) {
      _json["portSpecification"] = portSpecification;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    if (response != null) {
      _json["response"] = response;
    }
    return _json;
  }
}

class HTTPHealthCheck {
  /// The value of the host header in the HTTP health check request. If left
  /// empty (default value), the IP on behalf of which this health check is
  /// performed will be used.
  core.String host;

  /// The TCP port number for the health check request. The default value is 80.
  /// Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, HTTP health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The request path of the HTTP health check request. The default value is /.
  core.String requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String response;

  HTTPHealthCheck();

  HTTPHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("portSpecification")) {
      portSpecification = _json["portSpecification"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
    if (_json.containsKey("response")) {
      response = _json["response"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (host != null) {
      _json["host"] = host;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (portSpecification != null) {
      _json["portSpecification"] = portSpecification;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    if (response != null) {
      _json["response"] = response;
    }
    return _json;
  }
}

class HTTPSHealthCheck {
  /// The value of the host header in the HTTPS health check request. If left
  /// empty (default value), the IP on behalf of which this health check is
  /// performed will be used.
  core.String host;

  /// The TCP port number for the health check request. The default value is
  /// 443. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, HTTPS health check follows behavior specified in port
  /// and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The request path of the HTTPS health check request. The default value is
  /// /.
  core.String requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String response;

  HTTPSHealthCheck();

  HTTPSHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("portSpecification")) {
      portSpecification = _json["portSpecification"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
    if (_json.containsKey("response")) {
      response = _json["response"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (host != null) {
      _json["host"] = host;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (portSpecification != null) {
      _json["portSpecification"] = portSpecification;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    if (response != null) {
      _json["response"] = response;
    }
    return _json;
  }
}

/// Represents a Health Check resource.
///
/// Google Compute Engine has two Health Check resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/healthChecks) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionHealthChecks)
///
/// Internal HTTP(S) load balancers use regional health checks. All other types
/// of GCP load balancers and managed instance group auto-healing use global
/// health checks. For more information, read Health Check Concepts.
///
/// To perform health checks on network load balancers, you must use either
/// httpHealthChecks or httpsHealthChecks.
class HealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in 3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;
  HTTP2HealthCheck http2HealthCheck;
  HTTPHealthCheck httpHealthCheck;
  HTTPSHealthCheck httpsHealthCheck;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Region where the health check resides. Not applicable to
  /// global health checks.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;
  SSLHealthCheck sslHealthCheck;
  TCPHealthCheck tcpHealthCheck;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or
  /// HTTP2. If not specified, the default is TCP. Exactly one of the
  /// protocol-specific health check field must be specified, which must match
  /// type field.
  /// Possible string values are:
  /// - "HTTP"
  /// - "HTTP2"
  /// - "HTTPS"
  /// - "INVALID"
  /// - "SSL"
  /// - "TCP"
  core.String type;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HealthCheck();

  HealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("checkIntervalSec")) {
      checkIntervalSec = _json["checkIntervalSec"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("healthyThreshold")) {
      healthyThreshold = _json["healthyThreshold"];
    }
    if (_json.containsKey("http2HealthCheck")) {
      http2HealthCheck =
          new HTTP2HealthCheck.fromJson(_json["http2HealthCheck"]);
    }
    if (_json.containsKey("httpHealthCheck")) {
      httpHealthCheck = new HTTPHealthCheck.fromJson(_json["httpHealthCheck"]);
    }
    if (_json.containsKey("httpsHealthCheck")) {
      httpsHealthCheck =
          new HTTPSHealthCheck.fromJson(_json["httpsHealthCheck"]);
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sslHealthCheck")) {
      sslHealthCheck = new SSLHealthCheck.fromJson(_json["sslHealthCheck"]);
    }
    if (_json.containsKey("tcpHealthCheck")) {
      tcpHealthCheck = new TCPHealthCheck.fromJson(_json["tcpHealthCheck"]);
    }
    if (_json.containsKey("timeoutSec")) {
      timeoutSec = _json["timeoutSec"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
    if (_json.containsKey("unhealthyThreshold")) {
      unhealthyThreshold = _json["unhealthyThreshold"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (checkIntervalSec != null) {
      _json["checkIntervalSec"] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (healthyThreshold != null) {
      _json["healthyThreshold"] = healthyThreshold;
    }
    if (http2HealthCheck != null) {
      _json["http2HealthCheck"] = (http2HealthCheck).toJson();
    }
    if (httpHealthCheck != null) {
      _json["httpHealthCheck"] = (httpHealthCheck).toJson();
    }
    if (httpsHealthCheck != null) {
      _json["httpsHealthCheck"] = (httpsHealthCheck).toJson();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sslHealthCheck != null) {
      _json["sslHealthCheck"] = (sslHealthCheck).toJson();
    }
    if (tcpHealthCheck != null) {
      _json["tcpHealthCheck"] = (tcpHealthCheck).toJson();
    }
    if (timeoutSec != null) {
      _json["timeoutSec"] = timeoutSec;
    }
    if (type != null) {
      _json["type"] = type;
    }
    if (unhealthyThreshold != null) {
      _json["unhealthyThreshold"] = unhealthyThreshold;
    }
    return _json;
  }
}

class HealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HealthCheckListWarningData();

  HealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HealthCheckListWarning();

  HealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<HealthCheckListWarningData>(
              (value) => new HealthCheckListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of HealthCheck resources.
class HealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HealthCheck resources.
  core.List<HealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HealthCheckListWarning warning;

  HealthCheckList();

  HealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<HealthCheck>((value) => new HealthCheck.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new HealthCheckListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A full or valid partial URL to a health check. For example, the following
/// are valid URLs:
/// -
/// https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check
/// - projects/project-id/global/httpHealthChecks/health-check
/// - global/httpHealthChecks/health-check
class HealthCheckReference {
  core.String healthCheck;

  HealthCheckReference();

  HealthCheckReference.fromJson(core.Map _json) {
    if (_json.containsKey("healthCheck")) {
      healthCheck = _json["healthCheck"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthCheck != null) {
      _json["healthCheck"] = healthCheck;
    }
    return _json;
  }
}

class HealthChecksAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HealthChecksAggregatedListWarningData();

  HealthChecksAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HealthChecksAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HealthChecksAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HealthChecksAggregatedListWarning();

  HealthChecksAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<HealthChecksAggregatedListWarningData>((value) =>
              new HealthChecksAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class HealthChecksAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HealthChecksScopedList resources.
  core.Map<core.String, HealthChecksScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HealthChecksAggregatedListWarning warning;

  HealthChecksAggregatedList();

  HealthChecksAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, HealthChecksScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new HealthChecksScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new HealthChecksAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<HealthChecksScopedList, core.Map<core.String, core.Object>>(
              items, (HealthChecksScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class HealthChecksScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HealthChecksScopedListWarningData();

  HealthChecksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class HealthChecksScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HealthChecksScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HealthChecksScopedListWarning();

  HealthChecksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<HealthChecksScopedListWarningData>(
              (value) => new HealthChecksScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class HealthChecksScopedList {
  /// A list of HealthChecks contained in this scope.
  core.List<HealthCheck> healthChecks;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  HealthChecksScopedListWarning warning;

  HealthChecksScopedList();

  HealthChecksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("healthChecks")) {
      healthChecks = (_json["healthChecks"] as core.List)
          .map<HealthCheck>((value) => new HealthCheck.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new HealthChecksScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthChecks != null) {
      _json["healthChecks"] =
          healthChecks.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class HealthStatus {
  /// Health state of the instance.
  /// Possible string values are:
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  core.String healthState;

  /// URL of the instance resource.
  core.String instance;

  /// A forwarding rule IP address assigned to this instance.
  core.String ipAddress;

  /// The named port of the instance group, not necessarily the port that is
  /// health-checked.
  core.int port;

  HealthStatus();

  HealthStatus.fromJson(core.Map _json) {
    if (_json.containsKey("healthState")) {
      healthState = _json["healthState"];
    }
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthState != null) {
      _json["healthState"] = healthState;
    }
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    if (port != null) {
      _json["port"] = port;
    }
    return _json;
  }
}

class HealthStatusForNetworkEndpoint {
  /// URL of the backend service associated with the health state of the network
  /// endpoint.
  BackendServiceReference backendService;

  /// URL of the forwarding rule associated with the health state of the network
  /// endpoint.
  ForwardingRuleReference forwardingRule;

  /// URL of the health check associated with the health state of the network
  /// endpoint.
  HealthCheckReference healthCheck;

  /// Health state of the network endpoint determined based on the health checks
  /// configured.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  /// - "UNKNOWN"
  core.String healthState;

  HealthStatusForNetworkEndpoint();

  HealthStatusForNetworkEndpoint.fromJson(core.Map _json) {
    if (_json.containsKey("backendService")) {
      backendService =
          new BackendServiceReference.fromJson(_json["backendService"]);
    }
    if (_json.containsKey("forwardingRule")) {
      forwardingRule =
          new ForwardingRuleReference.fromJson(_json["forwardingRule"]);
    }
    if (_json.containsKey("healthCheck")) {
      healthCheck = new HealthCheckReference.fromJson(_json["healthCheck"]);
    }
    if (_json.containsKey("healthState")) {
      healthState = _json["healthState"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (backendService != null) {
      _json["backendService"] = (backendService).toJson();
    }
    if (forwardingRule != null) {
      _json["forwardingRule"] = (forwardingRule).toJson();
    }
    if (healthCheck != null) {
      _json["healthCheck"] = (healthCheck).toJson();
    }
    if (healthState != null) {
      _json["healthState"] = healthState;
    }
    return _json;
  }
}

/// UrlMaps A host-matching rule for a URL. If matched, will use the named
/// PathMatcher to select the BackendService.
class HostRule {
  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// The list of host patterns to match. They must be valid hostnames with
  /// optional port numbers in the format host:port. * matches any string of
  /// ([a-z0-9-.]*). In that case, * must be the first character and must be
  /// followed in the pattern by either - or ..
  core.List<core.String> hosts;

  /// The name of the PathMatcher to use to match the path portion of the URL if
  /// the hostRule matches the URL's host portion.
  core.String pathMatcher;

  HostRule();

  HostRule.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("hosts")) {
      hosts = (_json["hosts"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("pathMatcher")) {
      pathMatcher = _json["pathMatcher"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (hosts != null) {
      _json["hosts"] = hosts;
    }
    if (pathMatcher != null) {
      _json["pathMatcher"] = pathMatcher;
    }
    return _json;
  }
}

/// Specification for how requests are aborted as part of fault injection.
class HttpFaultAbort {
  /// The HTTP status code used to abort the request.
  /// The value must be between 200 and 599 inclusive.
  core.int httpStatus;

  /// The percentage of traffic (connections/operations/requests) which will be
  /// aborted as part of fault injection.
  /// The value must be between 0.0 and 100.0 inclusive.
  core.double percentage;

  HttpFaultAbort();

  HttpFaultAbort.fromJson(core.Map _json) {
    if (_json.containsKey("httpStatus")) {
      httpStatus = _json["httpStatus"];
    }
    if (_json.containsKey("percentage")) {
      percentage = _json["percentage"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (httpStatus != null) {
      _json["httpStatus"] = httpStatus;
    }
    if (percentage != null) {
      _json["percentage"] = percentage;
    }
    return _json;
  }
}

/// Specifies the delay introduced by Loadbalancer before forwarding the request
/// to the backend service as part of fault injection.
class HttpFaultDelay {
  /// Specifies the value of the fixed delay interval.
  Duration fixedDelay;

  /// The percentage of traffic (connections/operations/requests) on which delay
  /// will be introduced as part of fault injection.
  /// The value must be between 0.0 and 100.0 inclusive.
  core.double percentage;

  HttpFaultDelay();

  HttpFaultDelay.fromJson(core.Map _json) {
    if (_json.containsKey("fixedDelay")) {
      fixedDelay = new Duration.fromJson(_json["fixedDelay"]);
    }
    if (_json.containsKey("percentage")) {
      percentage = _json["percentage"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fixedDelay != null) {
      _json["fixedDelay"] = (fixedDelay).toJson();
    }
    if (percentage != null) {
      _json["percentage"] = percentage;
    }
    return _json;
  }
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault
/// injection, when clients send requests to a backend service, delays can be
/// introduced by Loadbalancer on a percentage of requests before sending those
/// request to the backend service. Similarly requests from clients can be
/// aborted by the Loadbalancer for a percentage of requests.
class HttpFaultInjection {
  /// The specification for how client requests are aborted as part of fault
  /// injection.
  HttpFaultAbort abort;

  /// The specification for how client requests are delayed as part of fault
  /// injection, before being sent to a backend service.
  HttpFaultDelay delay;

  HttpFaultInjection();

  HttpFaultInjection.fromJson(core.Map _json) {
    if (_json.containsKey("abort")) {
      abort = new HttpFaultAbort.fromJson(_json["abort"]);
    }
    if (_json.containsKey("delay")) {
      delay = new HttpFaultDelay.fromJson(_json["delay"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (abort != null) {
      _json["abort"] = (abort).toJson();
    }
    if (delay != null) {
      _json["delay"] = (delay).toJson();
    }
    return _json;
  }
}

/// The request and response header transformations that take effect before the
/// request is passed along to the selected backendService.
class HttpHeaderAction {
  /// Headers to add to a matching request prior to forwarding the request to
  /// the backendService.
  core.List<HttpHeaderOption> requestHeadersToAdd;

  /// A list of header names for headers that need to be removed from the
  /// request prior to forwarding the request to the backendService.
  core.List<core.String> requestHeadersToRemove;

  /// Headers to add the response prior to sending the response back to the
  /// client.
  core.List<HttpHeaderOption> responseHeadersToAdd;

  /// A list of header names for headers that need to be removed from the
  /// response prior to sending the response back to the client.
  core.List<core.String> responseHeadersToRemove;

  HttpHeaderAction();

  HttpHeaderAction.fromJson(core.Map _json) {
    if (_json.containsKey("requestHeadersToAdd")) {
      requestHeadersToAdd = (_json["requestHeadersToAdd"] as core.List)
          .map<HttpHeaderOption>(
              (value) => new HttpHeaderOption.fromJson(value))
          .toList();
    }
    if (_json.containsKey("requestHeadersToRemove")) {
      requestHeadersToRemove =
          (_json["requestHeadersToRemove"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("responseHeadersToAdd")) {
      responseHeadersToAdd = (_json["responseHeadersToAdd"] as core.List)
          .map<HttpHeaderOption>(
              (value) => new HttpHeaderOption.fromJson(value))
          .toList();
    }
    if (_json.containsKey("responseHeadersToRemove")) {
      responseHeadersToRemove =
          (_json["responseHeadersToRemove"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (requestHeadersToAdd != null) {
      _json["requestHeadersToAdd"] =
          requestHeadersToAdd.map((value) => (value).toJson()).toList();
    }
    if (requestHeadersToRemove != null) {
      _json["requestHeadersToRemove"] = requestHeadersToRemove;
    }
    if (responseHeadersToAdd != null) {
      _json["responseHeadersToAdd"] =
          responseHeadersToAdd.map((value) => (value).toJson()).toList();
    }
    if (responseHeadersToRemove != null) {
      _json["responseHeadersToRemove"] = responseHeadersToRemove;
    }
    return _json;
  }
}

/// matchRule criteria for request header matches.
class HttpHeaderMatch {
  /// The value should exactly match contents of exactMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String exactMatch;

  /// The name of the HTTP header to match.
  /// For matching against the HTTP request's authority, use a headerMatch with
  /// the header name ":authority".
  /// For matching a request's method, use the headerName ":method".
  core.String headerName;

  /// If set to false, the headerMatch is considered a match if the match
  /// criteria above are met. If set to true, the headerMatch is considered a
  /// match if the match criteria above are NOT met.
  /// The default setting is false.
  core.bool invertMatch;

  /// The value of the header must start with the contents of prefixMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String prefixMatch;

  /// A header with the contents of headerName must exist. The match takes place
  /// whether or not the request's header has a value.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.bool presentMatch;

  /// The header value must be an integer and its value must be in the range
  /// specified in rangeMatch. If the header does not contain an integer, number
  /// or is empty, the match fails.
  /// For example for a range [-5, 0]
  /// - -3 will match.
  /// - 0 will not match.
  /// - 0.25 will not match.
  /// - -3someString will not match.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  /// Note that rangeMatch is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  Int64RangeMatch rangeMatch;

  /// The value of the header must match the regular expression specified in
  /// regexMatch. For regular expression grammar, please see:
  /// en.cppreference.com/w/cpp/regex/ecmascript
  /// For matching against a port specified in the HTTP request, use a
  /// headerMatch with headerName set to PORT and a regular expression that
  /// satisfies the RFC2616 Host header's port specifier.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  /// Note that regexMatch only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.String regexMatch;

  /// The value of the header must end with the contents of suffixMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String suffixMatch;

  HttpHeaderMatch();

  HttpHeaderMatch.fromJson(core.Map _json) {
    if (_json.containsKey("exactMatch")) {
      exactMatch = _json["exactMatch"];
    }
    if (_json.containsKey("headerName")) {
      headerName = _json["headerName"];
    }
    if (_json.containsKey("invertMatch")) {
      invertMatch = _json["invertMatch"];
    }
    if (_json.containsKey("prefixMatch")) {
      prefixMatch = _json["prefixMatch"];
    }
    if (_json.containsKey("presentMatch")) {
      presentMatch = _json["presentMatch"];
    }
    if (_json.containsKey("rangeMatch")) {
      rangeMatch = new Int64RangeMatch.fromJson(_json["rangeMatch"]);
    }
    if (_json.containsKey("regexMatch")) {
      regexMatch = _json["regexMatch"];
    }
    if (_json.containsKey("suffixMatch")) {
      suffixMatch = _json["suffixMatch"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (exactMatch != null) {
      _json["exactMatch"] = exactMatch;
    }
    if (headerName != null) {
      _json["headerName"] = headerName;
    }
    if (invertMatch != null) {
      _json["invertMatch"] = invertMatch;
    }
    if (prefixMatch != null) {
      _json["prefixMatch"] = prefixMatch;
    }
    if (presentMatch != null) {
      _json["presentMatch"] = presentMatch;
    }
    if (rangeMatch != null) {
      _json["rangeMatch"] = (rangeMatch).toJson();
    }
    if (regexMatch != null) {
      _json["regexMatch"] = regexMatch;
    }
    if (suffixMatch != null) {
      _json["suffixMatch"] = suffixMatch;
    }
    return _json;
  }
}

/// Specification determining how headers are added to requests or responses.
class HttpHeaderOption {
  /// The name of the header.
  core.String headerName;

  /// The value of the header to add.
  core.String headerValue;

  /// If false, headerValue is appended to any values that already exist for the
  /// header. If true, headerValue is set for the header, discarding any values
  /// that were set for that header.
  /// The default value is false.
  core.bool replace;

  HttpHeaderOption();

  HttpHeaderOption.fromJson(core.Map _json) {
    if (_json.containsKey("headerName")) {
      headerName = _json["headerName"];
    }
    if (_json.containsKey("headerValue")) {
      headerValue = _json["headerValue"];
    }
    if (_json.containsKey("replace")) {
      replace = _json["replace"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (headerName != null) {
      _json["headerName"] = headerName;
    }
    if (headerValue != null) {
      _json["headerValue"] = headerValue;
    }
    if (replace != null) {
      _json["replace"] = replace;
    }
    return _json;
  }
}

/// Represents a legacy HTTP Health Check resource.
///
/// Legacy health checks are required by network load balancers. For more
/// information, read Health Check Concepts.
class HttpHealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;

  /// The value of the host header in the HTTP health check request. If left
  /// empty (default value), the public IP on behalf of which this health check
  /// is performed will be used.
  core.String host;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#httpHealthCheck for
  /// HTTP health checks.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The TCP port number for the HTTP health check request. The default value
  /// is 80.
  core.int port;

  /// The request path of the HTTP health check request. The default value is /.
  /// This field does not support query parameters.
  core.String requestPath;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HttpHealthCheck();

  HttpHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("checkIntervalSec")) {
      checkIntervalSec = _json["checkIntervalSec"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("healthyThreshold")) {
      healthyThreshold = _json["healthyThreshold"];
    }
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("timeoutSec")) {
      timeoutSec = _json["timeoutSec"];
    }
    if (_json.containsKey("unhealthyThreshold")) {
      unhealthyThreshold = _json["unhealthyThreshold"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (checkIntervalSec != null) {
      _json["checkIntervalSec"] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (healthyThreshold != null) {
      _json["healthyThreshold"] = healthyThreshold;
    }
    if (host != null) {
      _json["host"] = host;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (timeoutSec != null) {
      _json["timeoutSec"] = timeoutSec;
    }
    if (unhealthyThreshold != null) {
      _json["unhealthyThreshold"] = unhealthyThreshold;
    }
    return _json;
  }
}

class HttpHealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HttpHealthCheckListWarningData();

  HttpHealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HttpHealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HttpHealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HttpHealthCheckListWarning();

  HttpHealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<HttpHealthCheckListWarningData>(
              (value) => new HttpHealthCheckListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of HttpHealthCheck resources.
class HttpHealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HttpHealthCheck resources.
  core.List<HttpHealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HttpHealthCheckListWarning warning;

  HttpHealthCheckList();

  HttpHealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<HttpHealthCheck>((value) => new HttpHealthCheck.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new HttpHealthCheckListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// HttpRouteRuleMatch criteria for a request's query parameter.
class HttpQueryParameterMatch {
  /// The queryParameterMatch matches if the value of the parameter exactly
  /// matches the contents of exactMatch.
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  core.String exactMatch;

  /// The name of the query parameter to match. The query parameter must exist
  /// in the request, in the absence of which the request match fails.
  core.String name;

  /// Specifies that the queryParameterMatch matches if the request contains the
  /// query parameter, irrespective of whether the parameter has a value or not.
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  core.bool presentMatch;

  /// The queryParameterMatch matches if the value of the parameter matches the
  /// regular expression specified by regexMatch. For the regular expression
  /// grammar, please see en.cppreference.com/w/cpp/regex/ecmascript
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  /// Note that regexMatch only applies when the loadBalancingScheme is set to
  /// INTERNAL_SELF_MANAGED.
  core.String regexMatch;

  HttpQueryParameterMatch();

  HttpQueryParameterMatch.fromJson(core.Map _json) {
    if (_json.containsKey("exactMatch")) {
      exactMatch = _json["exactMatch"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("presentMatch")) {
      presentMatch = _json["presentMatch"];
    }
    if (_json.containsKey("regexMatch")) {
      regexMatch = _json["regexMatch"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (exactMatch != null) {
      _json["exactMatch"] = exactMatch;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (presentMatch != null) {
      _json["presentMatch"] = presentMatch;
    }
    if (regexMatch != null) {
      _json["regexMatch"] = regexMatch;
    }
    return _json;
  }
}

/// Specifies settings for an HTTP redirect.
class HttpRedirectAction {
  /// The host that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  /// The value must be between 1 and 255 characters.
  core.String hostRedirect;

  /// If set to true, the URL scheme in the redirected request is set to https.
  /// If set to false, the URL scheme of the redirected request will remain the
  /// same as that of the request.
  /// This must only be set for UrlMaps used in TargetHttpProxys. Setting this
  /// true for TargetHttpsProxy is not permitted.
  /// The default is set to false.
  core.bool httpsRedirect;

  /// The path that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  /// pathRedirect cannot be supplied together with prefixRedirect. Supply one
  /// alone or neither. If neither is supplied, the path of the original request
  /// will be used for the redirect.
  /// The value must be between 1 and 1024 characters.
  core.String pathRedirect;

  /// The prefix that replaces the prefixMatch specified in the
  /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
  /// redirecting the request.
  /// prefixRedirect cannot be supplied together with pathRedirect. Supply one
  /// alone or neither. If neither is supplied, the path of the original request
  /// will be used for the redirect.
  /// The value must be between 1 and 1024 characters.
  core.String prefixRedirect;

  /// The HTTP Status code to use for this RedirectAction.
  /// Supported values are:
  /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to
  /// 301.
  /// - FOUND, which corresponds to 302.
  /// - SEE_OTHER which corresponds to 303.
  /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request
  /// method will be retained.
  /// - PERMANENT_REDIRECT, which corresponds to 308. In this case, the request
  /// method will be retained.
  /// Possible string values are:
  /// - "FOUND"
  /// - "MOVED_PERMANENTLY_DEFAULT"
  /// - "PERMANENT_REDIRECT"
  /// - "SEE_OTHER"
  /// - "TEMPORARY_REDIRECT"
  core.String redirectResponseCode;

  /// If set to true, any accompanying query portion of the original URL is
  /// removed prior to redirecting the request. If set to false, the query
  /// portion of the original URL is retained.
  /// The default is set to false.
  core.bool stripQuery;

  HttpRedirectAction();

  HttpRedirectAction.fromJson(core.Map _json) {
    if (_json.containsKey("hostRedirect")) {
      hostRedirect = _json["hostRedirect"];
    }
    if (_json.containsKey("httpsRedirect")) {
      httpsRedirect = _json["httpsRedirect"];
    }
    if (_json.containsKey("pathRedirect")) {
      pathRedirect = _json["pathRedirect"];
    }
    if (_json.containsKey("prefixRedirect")) {
      prefixRedirect = _json["prefixRedirect"];
    }
    if (_json.containsKey("redirectResponseCode")) {
      redirectResponseCode = _json["redirectResponseCode"];
    }
    if (_json.containsKey("stripQuery")) {
      stripQuery = _json["stripQuery"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (hostRedirect != null) {
      _json["hostRedirect"] = hostRedirect;
    }
    if (httpsRedirect != null) {
      _json["httpsRedirect"] = httpsRedirect;
    }
    if (pathRedirect != null) {
      _json["pathRedirect"] = pathRedirect;
    }
    if (prefixRedirect != null) {
      _json["prefixRedirect"] = prefixRedirect;
    }
    if (redirectResponseCode != null) {
      _json["redirectResponseCode"] = redirectResponseCode;
    }
    if (stripQuery != null) {
      _json["stripQuery"] = stripQuery;
    }
    return _json;
  }
}

/// The retry policy associates with HttpRouteRule
class HttpRetryPolicy {
  /// Specifies the allowed number retries. This number must be > 0. If not
  /// specified, defaults to 1.
  core.int numRetries;

  /// Specifies a non-zero timeout per retry attempt.
  /// If not specified, will use the timeout set in HttpRouteAction. If timeout
  /// in HttpRouteAction is not set, will use the largest timeout among all
  /// backend services associated with the route.
  Duration perTryTimeout;

  /// Specfies one or more conditions when this retry rule applies. Valid values
  /// are:
  /// - 5xx: Loadbalancer will attempt a retry if the backend service responds
  /// with any 5xx response code, or if the backend service does not respond at
  /// all, example: disconnects, reset, read timeout, connection failure, and
  /// refused streams.
  /// - gateway-error: Similar to 5xx, but only applies to response codes 502,
  /// 503 or 504.
  /// -
  /// - connect-failure: Loadbalancer will retry on failures connecting to
  /// backend services, for example due to connection timeouts.
  /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
  /// Currently the only retriable error supported is 409.
  /// - refused-stream:Loadbalancer will retry if the backend service resets the
  /// stream with a REFUSED_STREAM error code. This reset type indicates that it
  /// is safe to retry.
  /// - cancelledLoadbalancer will retry if the gRPC status code in the response
  /// header is set to cancelled
  /// - deadline-exceeded: Loadbalancer will retry if the gRPC status code in
  /// the response header is set to deadline-exceeded
  /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in
  /// the response header is set to resource-exhausted
  /// - unavailable: Loadbalancer will retry if the gRPC status code in the
  /// response header is set to unavailable
  core.List<core.String> retryConditions;

  HttpRetryPolicy();

  HttpRetryPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("numRetries")) {
      numRetries = _json["numRetries"];
    }
    if (_json.containsKey("perTryTimeout")) {
      perTryTimeout = new Duration.fromJson(_json["perTryTimeout"]);
    }
    if (_json.containsKey("retryConditions")) {
      retryConditions =
          (_json["retryConditions"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (numRetries != null) {
      _json["numRetries"] = numRetries;
    }
    if (perTryTimeout != null) {
      _json["perTryTimeout"] = (perTryTimeout).toJson();
    }
    if (retryConditions != null) {
      _json["retryConditions"] = retryConditions;
    }
    return _json;
  }
}

class HttpRouteAction {
  /// The specification for allowing client side cross-origin requests. Please
  /// see W3C Recommendation for Cross Origin Resource Sharing
  CorsPolicy corsPolicy;

  /// The specification for fault injection introduced into traffic to test the
  /// resiliency of clients to backend service failure. As part of fault
  /// injection, when clients send requests to a backend service, delays can be
  /// introduced by Loadbalancer on a percentage of requests before sending
  /// those request to the backend service. Similarly requests from clients can
  /// be aborted by the Loadbalancer for a percentage of requests.
  /// timeout and retry_policy will be ignored by clients that are configured
  /// with a fault_injection_policy.
  HttpFaultInjection faultInjectionPolicy;

  /// Specifies the policy on how requests intended for the route's backends are
  /// shadowed to a separate mirrored backend service. Loadbalancer does not
  /// wait for responses from the shadow service. Prior to sending traffic to
  /// the shadow service, the host / authority header is suffixed with -shadow.
  RequestMirrorPolicy requestMirrorPolicy;

  /// Specifies the retry policy associated with this route.
  HttpRetryPolicy retryPolicy;

  /// Specifies the timeout for the selected route. Timeout is computed from the
  /// time the request has been fully processed (i.e. end-of-stream) up until
  /// the response has been completely processed. Timeout includes all retries.
  /// If not specified, will use the largest timeout among all backend services
  /// associated with the route.
  Duration timeout;

  /// The spec to modify the URL of the request, prior to forwarding the request
  /// to the matched service.
  UrlRewrite urlRewrite;

  /// A list of weighted backend services to send traffic to when a route match
  /// occurs. The weights determine the fraction of traffic that flows to their
  /// corresponding backend service. If all traffic needs to go to a single
  /// backend service, there must be one  weightedBackendService with weight set
  /// to a non 0 number.
  /// Once a backendService is identified and before forwarding the request to
  /// the backend service, advanced routing actions like Url rewrites and header
  /// transformations are applied depending on additional settings specified in
  /// this HttpRouteAction.
  core.List<WeightedBackendService> weightedBackendServices;

  HttpRouteAction();

  HttpRouteAction.fromJson(core.Map _json) {
    if (_json.containsKey("corsPolicy")) {
      corsPolicy = new CorsPolicy.fromJson(_json["corsPolicy"]);
    }
    if (_json.containsKey("faultInjectionPolicy")) {
      faultInjectionPolicy =
          new HttpFaultInjection.fromJson(_json["faultInjectionPolicy"]);
    }
    if (_json.containsKey("requestMirrorPolicy")) {
      requestMirrorPolicy =
          new RequestMirrorPolicy.fromJson(_json["requestMirrorPolicy"]);
    }
    if (_json.containsKey("retryPolicy")) {
      retryPolicy = new HttpRetryPolicy.fromJson(_json["retryPolicy"]);
    }
    if (_json.containsKey("timeout")) {
      timeout = new Duration.fromJson(_json["timeout"]);
    }
    if (_json.containsKey("urlRewrite")) {
      urlRewrite = new UrlRewrite.fromJson(_json["urlRewrite"]);
    }
    if (_json.containsKey("weightedBackendServices")) {
      weightedBackendServices = (_json["weightedBackendServices"] as core.List)
          .map<WeightedBackendService>(
              (value) => new WeightedBackendService.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (corsPolicy != null) {
      _json["corsPolicy"] = (corsPolicy).toJson();
    }
    if (faultInjectionPolicy != null) {
      _json["faultInjectionPolicy"] = (faultInjectionPolicy).toJson();
    }
    if (requestMirrorPolicy != null) {
      _json["requestMirrorPolicy"] = (requestMirrorPolicy).toJson();
    }
    if (retryPolicy != null) {
      _json["retryPolicy"] = (retryPolicy).toJson();
    }
    if (timeout != null) {
      _json["timeout"] = (timeout).toJson();
    }
    if (urlRewrite != null) {
      _json["urlRewrite"] = (urlRewrite).toJson();
    }
    if (weightedBackendServices != null) {
      _json["weightedBackendServices"] =
          weightedBackendServices.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// An HttpRouteRule specifies how to match an HTTP request and the
/// corresponding routing action that load balancing proxies will perform.
class HttpRouteRule {
  /// The short description conveying the intent of this routeRule.
  /// The description can have a maximum length of 1024 characters.
  core.String description;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// The headerAction specified here are applied before the matching
  /// pathMatchers[].headerAction and after
  /// pathMatchers[].routeRules[].routeAction.weightedBackendService.backendServiceWeightAction[].headerAction
  HttpHeaderAction headerAction;
  core.List<HttpRouteRuleMatch> matchRules;

  /// For routeRules within a given pathMatcher, priority determines the order
  /// in which load balancer will interpret routeRules. RouteRules are evaluated
  /// in order of priority, from the lowest to highest number. The priority of a
  /// rule decreases as its number increases (1, 2, 3, N+1). The first rule that
  /// matches the request is applied.
  /// You cannot configure two or more routeRules with the same priority.
  /// Priority for each rule must be set to a number between 0 and 2147483647
  /// inclusive.
  /// Priority numbers can have gaps, which enable you to add or remove rules in
  /// the future without affecting the rest of the rules. For example, 1, 2, 3,
  /// 4, 5, 9, 12, 16 is a valid series of priority numbers to which you could
  /// add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the future
  /// without any impact on existing rules.
  core.int priority;

  /// In response to a matching matchRule, the load balancer performs advanced
  /// routing actions like URL rewrites, header transformations, etc. prior to
  /// forwarding the request to the selected backend. If  routeAction specifies
  /// any  weightedBackendServices, service must not be set. Conversely if
  /// service is set, routeAction cannot contain any  weightedBackendServices.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  HttpRouteAction routeAction;

  /// The full or partial URL of the backend service resource to which traffic
  /// is directed if this rule is matched. If routeAction is additionally
  /// specified, advanced routing actions like URL Rewrites, etc. take effect
  /// prior to sending the request to the backend. However, if service is
  /// specified, routeAction cannot contain any weightedBackendService s.
  /// Conversely, if routeAction specifies any  weightedBackendServices, service
  /// must not be specified.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  core.String service;

  /// When this rule is matched, the request is redirected to a URL specified by
  /// urlRedirect.
  /// If urlRedirect is specified, service or routeAction must not be set.
  HttpRedirectAction urlRedirect;

  HttpRouteRule();

  HttpRouteRule.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("headerAction")) {
      headerAction = new HttpHeaderAction.fromJson(_json["headerAction"]);
    }
    if (_json.containsKey("matchRules")) {
      matchRules = (_json["matchRules"] as core.List)
          .map<HttpRouteRuleMatch>(
              (value) => new HttpRouteRuleMatch.fromJson(value))
          .toList();
    }
    if (_json.containsKey("priority")) {
      priority = _json["priority"];
    }
    if (_json.containsKey("routeAction")) {
      routeAction = new HttpRouteAction.fromJson(_json["routeAction"]);
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
    if (_json.containsKey("urlRedirect")) {
      urlRedirect = new HttpRedirectAction.fromJson(_json["urlRedirect"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (headerAction != null) {
      _json["headerAction"] = (headerAction).toJson();
    }
    if (matchRules != null) {
      _json["matchRules"] =
          matchRules.map((value) => (value).toJson()).toList();
    }
    if (priority != null) {
      _json["priority"] = priority;
    }
    if (routeAction != null) {
      _json["routeAction"] = (routeAction).toJson();
    }
    if (service != null) {
      _json["service"] = service;
    }
    if (urlRedirect != null) {
      _json["urlRedirect"] = (urlRedirect).toJson();
    }
    return _json;
  }
}

/// HttpRouteRuleMatch specifies a set of criteria for matching requests to an
/// HttpRouteRule. All specified criteria must be satisfied for a match to
/// occur.
class HttpRouteRuleMatch {
  /// For satisfying the matchRule condition, the path of the request must
  /// exactly match the value specified in fullPathMatch after removing any
  /// query parameters and anchor that may be part of the original URL.
  /// fullPathMatch must be between 1 and 1024 characters.
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  core.String fullPathMatch;

  /// Specifies a list of header match criteria, all of which must match
  /// corresponding headers in the request.
  core.List<HttpHeaderMatch> headerMatches;

  /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
  /// The default value is false.
  /// ignoreCase must not be used with regexMatch.
  core.bool ignoreCase;

  /// Opaque filter criteria used by Loadbalancer to restrict routing
  /// configuration to a limited set of xDS compliant clients. In their xDS
  /// requests to Loadbalancer, xDS clients present node metadata. If a match
  /// takes place, the relevant routing configuration is made available to those
  /// proxies.
  /// For each metadataFilter in this list, if its filterMatchCriteria is set to
  /// MATCH_ANY, at least one of the filterLabels must match the corresponding
  /// label provided in the metadata. If its filterMatchCriteria is set to
  /// MATCH_ALL, then all of its filterLabels must match with corresponding
  /// labels provided in the metadata.
  /// metadataFilters specified here will be applied after those specified in
  /// ForwardingRule that refers to the UrlMap this HttpRouteRuleMatch belongs
  /// to.
  /// metadataFilters only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.List<MetadataFilter> metadataFilters;

  /// For satisfying the matchRule condition, the request's path must begin with
  /// the specified prefixMatch. prefixMatch must begin with a /.
  /// The value must be between 1 and 1024 characters.
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  core.String prefixMatch;

  /// Specifies a list of query parameter match criteria, all of which must
  /// match corresponding query parameters in the request.
  core.List<HttpQueryParameterMatch> queryParameterMatches;

  /// For satisfying the matchRule condition, the path of the request must
  /// satisfy the regular expression specified in regexMatch after removing any
  /// query parameters and anchor supplied with the original URL. For regular
  /// expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  /// Note that regexMatch only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.String regexMatch;

  HttpRouteRuleMatch();

  HttpRouteRuleMatch.fromJson(core.Map _json) {
    if (_json.containsKey("fullPathMatch")) {
      fullPathMatch = _json["fullPathMatch"];
    }
    if (_json.containsKey("headerMatches")) {
      headerMatches = (_json["headerMatches"] as core.List)
          .map<HttpHeaderMatch>((value) => new HttpHeaderMatch.fromJson(value))
          .toList();
    }
    if (_json.containsKey("ignoreCase")) {
      ignoreCase = _json["ignoreCase"];
    }
    if (_json.containsKey("metadataFilters")) {
      metadataFilters = (_json["metadataFilters"] as core.List)
          .map<MetadataFilter>((value) => new MetadataFilter.fromJson(value))
          .toList();
    }
    if (_json.containsKey("prefixMatch")) {
      prefixMatch = _json["prefixMatch"];
    }
    if (_json.containsKey("queryParameterMatches")) {
      queryParameterMatches = (_json["queryParameterMatches"] as core.List)
          .map<HttpQueryParameterMatch>(
              (value) => new HttpQueryParameterMatch.fromJson(value))
          .toList();
    }
    if (_json.containsKey("regexMatch")) {
      regexMatch = _json["regexMatch"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fullPathMatch != null) {
      _json["fullPathMatch"] = fullPathMatch;
    }
    if (headerMatches != null) {
      _json["headerMatches"] =
          headerMatches.map((value) => (value).toJson()).toList();
    }
    if (ignoreCase != null) {
      _json["ignoreCase"] = ignoreCase;
    }
    if (metadataFilters != null) {
      _json["metadataFilters"] =
          metadataFilters.map((value) => (value).toJson()).toList();
    }
    if (prefixMatch != null) {
      _json["prefixMatch"] = prefixMatch;
    }
    if (queryParameterMatches != null) {
      _json["queryParameterMatches"] =
          queryParameterMatches.map((value) => (value).toJson()).toList();
    }
    if (regexMatch != null) {
      _json["regexMatch"] = regexMatch;
    }
    return _json;
  }
}

/// Represents a legacy HTTPS Health Check resource.
///
/// Legacy health checks are required by network load balancers. For more
/// information, read Health Check Concepts.
class HttpsHealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;

  /// The value of the host header in the HTTPS health check request. If left
  /// empty (default value), the public IP on behalf of which this health check
  /// is performed will be used.
  core.String host;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The TCP port number for the HTTPS health check request. The default value
  /// is 443.
  core.int port;

  /// The request path of the HTTPS health check request. The default value is
  /// "/".
  core.String requestPath;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have a greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HttpsHealthCheck();

  HttpsHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("checkIntervalSec")) {
      checkIntervalSec = _json["checkIntervalSec"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("healthyThreshold")) {
      healthyThreshold = _json["healthyThreshold"];
    }
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("requestPath")) {
      requestPath = _json["requestPath"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("timeoutSec")) {
      timeoutSec = _json["timeoutSec"];
    }
    if (_json.containsKey("unhealthyThreshold")) {
      unhealthyThreshold = _json["unhealthyThreshold"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (checkIntervalSec != null) {
      _json["checkIntervalSec"] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (healthyThreshold != null) {
      _json["healthyThreshold"] = healthyThreshold;
    }
    if (host != null) {
      _json["host"] = host;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (port != null) {
      _json["port"] = port;
    }
    if (requestPath != null) {
      _json["requestPath"] = requestPath;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (timeoutSec != null) {
      _json["timeoutSec"] = timeoutSec;
    }
    if (unhealthyThreshold != null) {
      _json["unhealthyThreshold"] = unhealthyThreshold;
    }
    return _json;
  }
}

class HttpsHealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HttpsHealthCheckListWarningData();

  HttpsHealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HttpsHealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HttpsHealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HttpsHealthCheckListWarning();

  HttpsHealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<HttpsHealthCheckListWarningData>(
              (value) => new HttpsHealthCheckListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of HttpsHealthCheck resources.
class HttpsHealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HttpsHealthCheck resources.
  core.List<HttpsHealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HttpsHealthCheckListWarning warning;

  HttpsHealthCheckList();

  HttpsHealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<HttpsHealthCheck>(
              (value) => new HttpsHealthCheck.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new HttpsHealthCheckListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// The parameters of the raw disk image.
class ImageRawDisk {
  /// The format used to encode and transmit the block device, which should be
  /// TAR. This is just a container and transmission format and not a runtime
  /// format. Provided by the client when the disk image is created.
  /// Possible string values are:
  /// - "TAR"
  core.String containerType;

  /// [Deprecated] This field is deprecated. An optional SHA1 checksum of the
  /// disk image before unpackaging provided by the client when the disk image
  /// is created.
  core.String sha1Checksum;

  /// The full Google Cloud Storage URL where the disk image is stored. You must
  /// provide either this property or the sourceDisk property but not both.
  core.String source;

  ImageRawDisk();

  ImageRawDisk.fromJson(core.Map _json) {
    if (_json.containsKey("containerType")) {
      containerType = _json["containerType"];
    }
    if (_json.containsKey("sha1Checksum")) {
      sha1Checksum = _json["sha1Checksum"];
    }
    if (_json.containsKey("source")) {
      source = _json["source"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (containerType != null) {
      _json["containerType"] = containerType;
    }
    if (sha1Checksum != null) {
      _json["sha1Checksum"] = sha1Checksum;
    }
    if (source != null) {
      _json["source"] = source;
    }
    return _json;
  }
}

/// Represents an Image resource.
///
/// You can use images to create boot disks for your VM instances. For more
/// information, read Images. (== resource_for {$api_version}.images ==)
class Image {
  /// Size of the image tar.gz archive stored in Google Cloud Storage (in
  /// bytes).
  core.String archiveSizeBytes;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The deprecation status associated with this image.
  DeprecationStatus deprecated;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Size of the image when restored onto a persistent disk (in GB).
  core.String diskSizeGb;

  /// The name of the image family to which this image belongs. You can create
  /// disks by specifying an image family instead of a specific image name. The
  /// image family always returns its latest image that is not deprecated. The
  /// name of the image family must comply with RFC1035.
  core.String family;

  /// A list of features to enable on the guest operating system. Applicable
  /// only for bootable images. Read  Enabling guest operating system features
  /// to see a list of available options.
  core.List<GuestOsFeature> guestOsFeatures;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Encrypts the image using a customer-supplied encryption key.
  ///
  /// After you encrypt an image with a customer-supplied key, you must provide
  /// the same key if you use the image later (e.g. to create a disk from the
  /// image).
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the image, then the
  /// disk will be encrypted using an automatically generated key and you do not
  /// need to provide a key to use the image later.
  CustomerEncryptionKey imageEncryptionKey;

  /// [Output Only] Type of the resource. Always compute#image for images.
  core.String kind;

  /// A fingerprint for the labels being applied to this image, which is
  /// essentially a hash of the labels used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an image.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels to apply to this image. These can be later modified by the
  /// setLabels method.
  core.Map<core.String, core.String> labels;

  /// Integer license codes indicating which licenses are attached to this
  /// image.
  core.List<core.String> licenseCodes;

  /// Any applicable license URI.
  core.List<core.String> licenses;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The parameters of the raw disk image.
  ImageRawDisk rawDisk;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Set the secure boot keys of shielded instance.
  InitialStateConfig shieldedInstanceInitialState;

  /// URL of the source disk used to create this image. This can be a full or
  /// valid partial URL. You must provide either this property or the
  /// rawDisk.source property but not both to create an image. For example, the
  /// following are valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String sourceDisk;

  /// The customer-supplied encryption key of the source disk. Required if the
  /// source disk is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceDiskEncryptionKey;

  /// [Output Only] The ID value of the disk used to create this image. This
  /// value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given disk name.
  core.String sourceDiskId;

  /// URL of the source image used to create this image. This can be a full or
  /// valid partial URL. You must provide exactly one of:
  /// - this property, or
  /// - the rawDisk.source property, or
  /// - the sourceDisk property   in order to create an image.
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceImageEncryptionKey;

  /// [Output Only] The ID value of the image used to create this image. This
  /// value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given image name.
  core.String sourceImageId;

  /// URL of the source snapshot used to create this image. This can be a full
  /// or valid partial URL. You must provide exactly one of:
  /// - this property, or
  /// - the sourceImage property, or
  /// - the rawDisk.source property, or
  /// - the sourceDisk property   in order to create an image.
  core.String sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot. Required if
  /// the source snapshot is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceSnapshotEncryptionKey;

  /// [Output Only] The ID value of the snapshot used to create this image. This
  /// value may be used to determine whether the snapshot was taken from the
  /// current or a previous instance of a given snapshot name.
  core.String sourceSnapshotId;

  /// The type of the image used to create this disk. The default and only value
  /// is RAW
  /// Possible string values are:
  /// - "RAW"
  core.String sourceType;

  /// [Output Only] The status of the image. An image can be used to create
  /// other resources, such as instances, only after the image has been
  /// successfully created and the status is set to READY. Possible values are
  /// FAILED, PENDING, or READY.
  /// Possible string values are:
  /// - "DELETING"
  /// - "FAILED"
  /// - "PENDING"
  /// - "READY"
  core.String status;

  /// Cloud Storage bucket storage location of the image (regional or
  /// multi-regional).
  core.List<core.String> storageLocations;

  Image();

  Image.fromJson(core.Map _json) {
    if (_json.containsKey("archiveSizeBytes")) {
      archiveSizeBytes = _json["archiveSizeBytes"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("diskSizeGb")) {
      diskSizeGb = _json["diskSizeGb"];
    }
    if (_json.containsKey("family")) {
      family = _json["family"];
    }
    if (_json.containsKey("guestOsFeatures")) {
      guestOsFeatures = (_json["guestOsFeatures"] as core.List)
          .map<GuestOsFeature>((value) => new GuestOsFeature.fromJson(value))
          .toList();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("imageEncryptionKey")) {
      imageEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["imageEncryptionKey"]);
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("licenseCodes")) {
      licenseCodes = (_json["licenseCodes"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("licenses")) {
      licenses = (_json["licenses"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("rawDisk")) {
      rawDisk = new ImageRawDisk.fromJson(_json["rawDisk"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("shieldedInstanceInitialState")) {
      shieldedInstanceInitialState = new InitialStateConfig.fromJson(
          _json["shieldedInstanceInitialState"]);
    }
    if (_json.containsKey("sourceDisk")) {
      sourceDisk = _json["sourceDisk"];
    }
    if (_json.containsKey("sourceDiskEncryptionKey")) {
      sourceDiskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceDiskEncryptionKey"]);
    }
    if (_json.containsKey("sourceDiskId")) {
      sourceDiskId = _json["sourceDiskId"];
    }
    if (_json.containsKey("sourceImage")) {
      sourceImage = _json["sourceImage"];
    }
    if (_json.containsKey("sourceImageEncryptionKey")) {
      sourceImageEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceImageEncryptionKey"]);
    }
    if (_json.containsKey("sourceImageId")) {
      sourceImageId = _json["sourceImageId"];
    }
    if (_json.containsKey("sourceSnapshot")) {
      sourceSnapshot = _json["sourceSnapshot"];
    }
    if (_json.containsKey("sourceSnapshotEncryptionKey")) {
      sourceSnapshotEncryptionKey = new CustomerEncryptionKey.fromJson(
          _json["sourceSnapshotEncryptionKey"]);
    }
    if (_json.containsKey("sourceSnapshotId")) {
      sourceSnapshotId = _json["sourceSnapshotId"];
    }
    if (_json.containsKey("sourceType")) {
      sourceType = _json["sourceType"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("storageLocations")) {
      storageLocations =
          (_json["storageLocations"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (archiveSizeBytes != null) {
      _json["archiveSizeBytes"] = archiveSizeBytes;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (diskSizeGb != null) {
      _json["diskSizeGb"] = diskSizeGb;
    }
    if (family != null) {
      _json["family"] = family;
    }
    if (guestOsFeatures != null) {
      _json["guestOsFeatures"] =
          guestOsFeatures.map((value) => (value).toJson()).toList();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (imageEncryptionKey != null) {
      _json["imageEncryptionKey"] = (imageEncryptionKey).toJson();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (licenseCodes != null) {
      _json["licenseCodes"] = licenseCodes;
    }
    if (licenses != null) {
      _json["licenses"] = licenses;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (rawDisk != null) {
      _json["rawDisk"] = (rawDisk).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (shieldedInstanceInitialState != null) {
      _json["shieldedInstanceInitialState"] =
          (shieldedInstanceInitialState).toJson();
    }
    if (sourceDisk != null) {
      _json["sourceDisk"] = sourceDisk;
    }
    if (sourceDiskEncryptionKey != null) {
      _json["sourceDiskEncryptionKey"] = (sourceDiskEncryptionKey).toJson();
    }
    if (sourceDiskId != null) {
      _json["sourceDiskId"] = sourceDiskId;
    }
    if (sourceImage != null) {
      _json["sourceImage"] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json["sourceImageEncryptionKey"] = (sourceImageEncryptionKey).toJson();
    }
    if (sourceImageId != null) {
      _json["sourceImageId"] = sourceImageId;
    }
    if (sourceSnapshot != null) {
      _json["sourceSnapshot"] = sourceSnapshot;
    }
    if (sourceSnapshotEncryptionKey != null) {
      _json["sourceSnapshotEncryptionKey"] =
          (sourceSnapshotEncryptionKey).toJson();
    }
    if (sourceSnapshotId != null) {
      _json["sourceSnapshotId"] = sourceSnapshotId;
    }
    if (sourceType != null) {
      _json["sourceType"] = sourceType;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (storageLocations != null) {
      _json["storageLocations"] = storageLocations;
    }
    return _json;
  }
}

class ImageListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ImageListWarningData();

  ImageListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ImageListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ImageListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ImageListWarning();

  ImageListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ImageListWarningData>(
              (value) => new ImageListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of images.
class ImageList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Image resources.
  core.List<Image> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ImageListWarning warning;

  ImageList();

  ImageList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Image>((value) => new Image.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ImageListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Initial State for shielded instance, these are public keys which are safe to
/// store in public
class InitialStateConfig {
  /// The Key Database (db).
  core.List<FileContentBuffer> dbs;

  /// The forbidden key database (dbx).
  core.List<FileContentBuffer> dbxs;

  /// The Key Exchange Key (KEK).
  core.List<FileContentBuffer> keks;

  /// The Platform Key (PK).
  FileContentBuffer pk;

  InitialStateConfig();

  InitialStateConfig.fromJson(core.Map _json) {
    if (_json.containsKey("dbs")) {
      dbs = (_json["dbs"] as core.List)
          .map<FileContentBuffer>(
              (value) => new FileContentBuffer.fromJson(value))
          .toList();
    }
    if (_json.containsKey("dbxs")) {
      dbxs = (_json["dbxs"] as core.List)
          .map<FileContentBuffer>(
              (value) => new FileContentBuffer.fromJson(value))
          .toList();
    }
    if (_json.containsKey("keks")) {
      keks = (_json["keks"] as core.List)
          .map<FileContentBuffer>(
              (value) => new FileContentBuffer.fromJson(value))
          .toList();
    }
    if (_json.containsKey("pk")) {
      pk = new FileContentBuffer.fromJson(_json["pk"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (dbs != null) {
      _json["dbs"] = dbs.map((value) => (value).toJson()).toList();
    }
    if (dbxs != null) {
      _json["dbxs"] = dbxs.map((value) => (value).toJson()).toList();
    }
    if (keks != null) {
      _json["keks"] = keks.map((value) => (value).toJson()).toList();
    }
    if (pk != null) {
      _json["pk"] = (pk).toJson();
    }
    return _json;
  }
}

/// Represents an Instance resource.
///
/// An instance is a virtual machine that is hosted on Google Cloud Platform.
/// For more information, read Virtual Machine Instances. (== resource_for
/// {$api_version}.instances ==)
class Instance {
  /// Allows this instance to send and receive packets with non-matching
  /// destination or source IPs. This is required if you plan to use this
  /// instance to forward routes. For more information, see Enabling IP
  /// Forwarding.
  core.bool canIpForward;

  /// [Output Only] The CPU platform used by this instance.
  core.String cpuPlatform;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// Whether the resource should be protected against deletion.
  core.bool deletionProtection;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Array of disks associated with this instance. Persistent disks must be
  /// created before you can assign them.
  core.List<AttachedDisk> disks;

  /// Enables display device for the instance.
  DisplayDevice displayDevice;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the instance's contents and used for optimistic locking. The fingerprint
  /// is initially generated by Compute Engine and changes after every request
  /// to modify or update the instance. You must always provide an up-to-date
  /// fingerprint hash in order to update the instance.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// A list of the type and count of accelerator cards attached to the
  /// instance.
  core.List<AcceleratorConfig> guestAccelerators;

  /// Specifies the hostname of the instance. The specified hostname must be
  /// RFC1035 compliant. If hostname is not specified, the default hostname is
  /// [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global DNS, and
  /// [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal DNS.
  core.String hostname;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#instance for instances.
  core.String kind;

  /// A fingerprint for this request, which is essentially a hash of the label's
  /// contents and used for optimistic locking. The fingerprint is initially
  /// generated by Compute Engine and changes after every request to modify or
  /// update labels. You must always provide an up-to-date fingerprint hash in
  /// order to update or change labels.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels to apply to this instance. These can be later modified by the
  /// setLabels method.
  core.Map<core.String, core.String> labels;

  /// Full or partial URL of the machine type resource to use for this instance,
  /// in the format: zones/zone/machineTypes/machine-type. This is provided by
  /// the client when the instance is created. For example, the following is a
  /// valid partial url to a predefined machine type:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  ///
  ///
  /// To create a custom machine type, provide a URL to a machine type in the
  /// following format, where CPUS is 1 or an even number up to 32 (2, 4, 6, ...
  /// 24, etc), and MEMORY is the total memory for this instance. Memory must be
  /// a multiple of 256 MB and must be supplied in MB (e.g. 5 GB of memory is
  /// 5120 MB):
  /// zones/zone/machineTypes/custom-CPUS-MEMORY
  ///
  ///
  /// For example: zones/us-central1-f/machineTypes/custom-4-5120
  ///
  /// For a full list of restrictions, read the Specifications for custom
  /// machine types.
  core.String machineType;

  /// The metadata key/value pairs assigned to this instance. This includes
  /// custom metadata and predefined keys.
  Metadata metadata;

  /// Specifies a minimum CPU platform for the VM instance. Applicable values
  /// are the friendly names of CPU platforms, such as minCpuPlatform: "Intel
  /// Haswell" or minCpuPlatform: "Intel Sandy Bridge".
  core.String minCpuPlatform;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// An array of network configurations for this instance. These specify how
  /// interfaces are configured to interact with other network services, such as
  /// connecting to the internet. Multiple interfaces are supported per
  /// instance.
  core.List<NetworkInterface> networkInterfaces;

  /// Specifies the reservations that this instance can consume from.
  ReservationAffinity reservationAffinity;

  /// Resource policies applied to this instance.
  core.List<core.String> resourcePolicies;

  /// Sets the scheduling options for this instance.
  Scheduling scheduling;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// A list of service accounts, with their specified scopes, authorized for
  /// this instance. Only one service account per VM instance is supported.
  ///
  /// Service accounts generate access tokens that can be accessed through the
  /// metadata server and used to authenticate applications on the instance. See
  /// Service Accounts for more information.
  core.List<ServiceAccount> serviceAccounts;
  ShieldedInstanceConfig shieldedInstanceConfig;
  ShieldedInstanceIntegrityPolicy shieldedInstanceIntegrityPolicy;

  /// [Output Only] Whether a VM has been restricted for start because Compute
  /// Engine has detected suspicious activity.
  core.bool startRestricted;

  /// [Output Only] The status of the instance. One of the following values:
  /// PROVISIONING, STAGING, RUNNING, STOPPING, STOPPED, SUSPENDING, SUSPENDED,
  /// and TERMINATED.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String status;

  /// [Output Only] An optional, human-readable explanation of the status.
  core.String statusMessage;

  /// Tags to apply to this instance. Tags are used to identify valid sources or
  /// targets for network firewalls and are specified by the client during
  /// instance creation. The tags can be later modified by the setTags method.
  /// Each tag within the list must comply with RFC1035. Multiple tags can be
  /// specified via the 'tags.items' field.
  Tags tags;

  /// [Output Only] URL of the zone where the instance resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String zone;

  Instance();

  Instance.fromJson(core.Map _json) {
    if (_json.containsKey("canIpForward")) {
      canIpForward = _json["canIpForward"];
    }
    if (_json.containsKey("cpuPlatform")) {
      cpuPlatform = _json["cpuPlatform"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deletionProtection")) {
      deletionProtection = _json["deletionProtection"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("disks")) {
      disks = (_json["disks"] as core.List)
          .map<AttachedDisk>((value) => new AttachedDisk.fromJson(value))
          .toList();
    }
    if (_json.containsKey("displayDevice")) {
      displayDevice = new DisplayDevice.fromJson(_json["displayDevice"]);
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("guestAccelerators")) {
      guestAccelerators = (_json["guestAccelerators"] as core.List)
          .map<AcceleratorConfig>(
              (value) => new AcceleratorConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("hostname")) {
      hostname = _json["hostname"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("machineType")) {
      machineType = _json["machineType"];
    }
    if (_json.containsKey("metadata")) {
      metadata = new Metadata.fromJson(_json["metadata"]);
    }
    if (_json.containsKey("minCpuPlatform")) {
      minCpuPlatform = _json["minCpuPlatform"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("networkInterfaces")) {
      networkInterfaces = (_json["networkInterfaces"] as core.List)
          .map<NetworkInterface>(
              (value) => new NetworkInterface.fromJson(value))
          .toList();
    }
    if (_json.containsKey("reservationAffinity")) {
      reservationAffinity =
          new ReservationAffinity.fromJson(_json["reservationAffinity"]);
    }
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("scheduling")) {
      scheduling = new Scheduling.fromJson(_json["scheduling"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("serviceAccounts")) {
      serviceAccounts = (_json["serviceAccounts"] as core.List)
          .map<ServiceAccount>((value) => new ServiceAccount.fromJson(value))
          .toList();
    }
    if (_json.containsKey("shieldedInstanceConfig")) {
      shieldedInstanceConfig =
          new ShieldedInstanceConfig.fromJson(_json["shieldedInstanceConfig"]);
    }
    if (_json.containsKey("shieldedInstanceIntegrityPolicy")) {
      shieldedInstanceIntegrityPolicy =
          new ShieldedInstanceIntegrityPolicy.fromJson(
              _json["shieldedInstanceIntegrityPolicy"]);
    }
    if (_json.containsKey("startRestricted")) {
      startRestricted = _json["startRestricted"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusMessage")) {
      statusMessage = _json["statusMessage"];
    }
    if (_json.containsKey("tags")) {
      tags = new Tags.fromJson(_json["tags"]);
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (canIpForward != null) {
      _json["canIpForward"] = canIpForward;
    }
    if (cpuPlatform != null) {
      _json["cpuPlatform"] = cpuPlatform;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deletionProtection != null) {
      _json["deletionProtection"] = deletionProtection;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (disks != null) {
      _json["disks"] = disks.map((value) => (value).toJson()).toList();
    }
    if (displayDevice != null) {
      _json["displayDevice"] = (displayDevice).toJson();
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (guestAccelerators != null) {
      _json["guestAccelerators"] =
          guestAccelerators.map((value) => (value).toJson()).toList();
    }
    if (hostname != null) {
      _json["hostname"] = hostname;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (machineType != null) {
      _json["machineType"] = machineType;
    }
    if (metadata != null) {
      _json["metadata"] = (metadata).toJson();
    }
    if (minCpuPlatform != null) {
      _json["minCpuPlatform"] = minCpuPlatform;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (networkInterfaces != null) {
      _json["networkInterfaces"] =
          networkInterfaces.map((value) => (value).toJson()).toList();
    }
    if (reservationAffinity != null) {
      _json["reservationAffinity"] = (reservationAffinity).toJson();
    }
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    if (scheduling != null) {
      _json["scheduling"] = (scheduling).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (serviceAccounts != null) {
      _json["serviceAccounts"] =
          serviceAccounts.map((value) => (value).toJson()).toList();
    }
    if (shieldedInstanceConfig != null) {
      _json["shieldedInstanceConfig"] = (shieldedInstanceConfig).toJson();
    }
    if (shieldedInstanceIntegrityPolicy != null) {
      _json["shieldedInstanceIntegrityPolicy"] =
          (shieldedInstanceIntegrityPolicy).toJson();
    }
    if (startRestricted != null) {
      _json["startRestricted"] = startRestricted;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusMessage != null) {
      _json["statusMessage"] = statusMessage;
    }
    if (tags != null) {
      _json["tags"] = (tags).toJson();
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class InstanceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceAggregatedListWarningData();

  InstanceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceAggregatedListWarning();

  InstanceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceAggregatedListWarningData>(
              (value) => new InstanceAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// An object that contains a list of instances scoped by zone.
  core.Map<core.String, InstancesScopedList> items;

  /// [Output Only] Type of resource. Always compute#instanceAggregatedList for
  /// aggregated lists of Instance resources.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceAggregatedListWarning warning;

  InstanceAggregatedList();

  InstanceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, InstancesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new InstancesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<InstancesScopedList, core.Map<core.String, core.Object>>(
              items, (InstancesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents an Instance Group resource.
///
/// Instance Groups can be used to configure a target for load balancing.
///
/// Instance groups can either be managed or unmanaged.
///
/// To create  managed instance groups, use the instanceGroupManager or
/// regionInstanceGroupManager resource instead.
///
/// Use zonal unmanaged instance groups if you need to apply load balancing to
/// groups of heterogeneous instances or if you need to manage the instances
/// yourself. You cannot create regional unmanaged instance groups.
///
/// For more information, read Instance groups.
///
/// (== resource_for {$api_version}.instanceGroups ==) (== resource_for
/// {$api_version}.regionInstanceGroups ==)
class InstanceGroup {
  /// [Output Only] The creation timestamp for this instance group in RFC3339
  /// text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The fingerprint of the named ports. The system uses this
  /// fingerprint to detect conflicts when multiple users change the named ports
  /// concurrently.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] A unique identifier for this instance group, generated by
  /// the server.
  core.String id;

  /// [Output Only] The resource type, which is always compute#instanceGroup for
  /// instance groups.
  core.String kind;

  /// The name of the instance group. The name must be 1-63 characters long, and
  /// comply with RFC1035.
  core.String name;

  /// Assigns a name to a port number. For example: {name: "http", port: 80}
  ///
  /// This allows the system to reference ports by the assigned name instead of
  /// a port number. Named ports can also contain multiple ports. For example:
  /// [{name: "http", port: 80},{name: "http", port: 8080}]
  ///
  /// Named ports apply to all instances in this instance group.
  core.List<NamedPort> namedPorts;

  /// [Output Only] The URL of the network to which all instances in the
  /// instance group belong. If your instance has multiple network interfaces,
  /// then the network and subnetwork fields only refer to the network and
  /// subnet used by your primary interface (nic0).
  core.String network;

  /// [Output Only] The URL of the region where the instance group is located
  /// (for regional resources).
  core.String region;

  /// [Output Only] The URL for this instance group. The server generates this
  /// URL.
  core.String selfLink;

  /// [Output Only] The total number of instances in the instance group.
  core.int size;

  /// [Output Only] The URL of the subnetwork to which all instances in the
  /// instance group belong. If your instance has multiple network interfaces,
  /// then the network and subnetwork fields only refer to the network and
  /// subnet used by your primary interface (nic0).
  core.String subnetwork;

  /// [Output Only] The URL of the zone where the instance group is located (for
  /// zonal resources).
  core.String zone;

  InstanceGroup();

  InstanceGroup.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = (_json["namedPorts"] as core.List)
          .map<NamedPort>((value) => new NamedPort.fromJson(value))
          .toList();
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("size")) {
      size = _json["size"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (size != null) {
      _json["size"] = size;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class InstanceGroupAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupAggregatedListWarningData();

  InstanceGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupAggregatedListWarning();

  InstanceGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceGroupAggregatedListWarningData>((value) =>
              new InstanceGroupAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupsScopedList resources.
  core.Map<core.String, InstanceGroupsScopedList> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupAggregatedList for aggregated lists of instance
  /// groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupAggregatedListWarning warning;

  InstanceGroupAggregatedList();

  InstanceGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, InstanceGroupsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new InstanceGroupsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new InstanceGroupAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<InstanceGroupsScopedList, core.Map<core.String, core.Object>>(
              items, (InstanceGroupsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupListWarningData();

  InstanceGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupListWarning();

  InstanceGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceGroupListWarningData>(
              (value) => new InstanceGroupListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// A list of InstanceGroup resources.
class InstanceGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup> items;

  /// [Output Only] The resource type, which is always compute#instanceGroupList
  /// for instance group lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupListWarning warning;

  InstanceGroupList();

  InstanceGroupList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceGroup>((value) => new InstanceGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceGroupListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Managed Instance Group resource.
///
/// An instance group is a collection of VM instances that you can manage as a
/// single entity. For more information, read Instance groups.
///
/// For zonal Managed Instance Group, use the instanceGroupManagers resource.
///
/// For regional Managed Instance Group, use the regionInstanceGroupManagers
/// resource. (== resource_for {$api_version}.instanceGroupManagers ==) (==
/// resource_for {$api_version}.regionInstanceGroupManagers ==)
class InstanceGroupManager {
  /// The autohealing policy for this managed instance group. You can specify
  /// only one value.
  core.List<InstanceGroupManagerAutoHealingPolicy> autoHealingPolicies;

  /// The base instance name to use for instances in this group. The value must
  /// be 1-58 characters long. Instances are named by appending a hyphen and a
  /// random four-character string to the base instance name. The base instance
  /// name must comply with RFC1035.
  core.String baseInstanceName;

  /// [Output Only] The creation timestamp for this managed instance group in
  /// RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The list of instance actions and the number of instances in
  /// this managed instance group that are scheduled for each of those actions.
  InstanceGroupManagerActionsSummary currentActions;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Policy specifying intended distribution of instances in regional managed
  /// instance group.
  DistributionPolicy distributionPolicy;

  /// Fingerprint of this resource. This field may be used in optimistic
  /// locking. It will be ignored when inserting an InstanceGroupManager. An
  /// up-to-date fingerprint must be provided in order to update the
  /// InstanceGroupManager, otherwise the request will fail with error 412
  /// conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// InstanceGroupManager.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] A unique identifier for this resource type. The server
  /// generates this identifier.
  core.String id;

  /// [Output Only] The URL of the Instance Group resource.
  core.String instanceGroup;

  /// The URL of the instance template that is specified for this managed
  /// instance group. The group uses this template to create all new instances
  /// in the managed instance group.
  core.String instanceTemplate;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManager for managed instance groups.
  core.String kind;

  /// The name of the managed instance group. The name must be 1-63 characters
  /// long, and comply with RFC1035.
  core.String name;

  /// Named ports configured for the Instance Groups complementary to this
  /// Instance Group Manager.
  core.List<NamedPort> namedPorts;

  /// [Output Only] The URL of the region where the managed instance group
  /// resides (for regional resources).
  core.String region;

  /// [Output Only] The URL for this managed instance group. The server defines
  /// this URL.
  core.String selfLink;

  /// [Output Only] The status of this managed instance group.
  InstanceGroupManagerStatus status;

  /// The URLs for all TargetPool resources to which instances in the
  /// instanceGroup field are added. The target pools automatically apply to all
  /// of the instances in the managed instance group.
  core.List<core.String> targetPools;

  /// The target number of running instances for this managed instance group.
  /// You can reduce this number by using the instanceGroupManager
  /// deleteInstances or abandonInstances methods. Resizing the group also
  /// changes this number.
  core.int targetSize;

  /// The update policy for this managed instance group.
  InstanceGroupManagerUpdatePolicy updatePolicy;

  /// Specifies the instance templates used by this managed instance group to
  /// create instances.
  ///
  /// Each version is defined by an instanceTemplate and a name. Every version
  /// can appear at most once per instance group. This field overrides the
  /// top-level instanceTemplate field. Read more about the relationships
  /// between these fields. Exactly one version must leave the targetSize field
  /// unset. That version will be applied to all remaining instances. For more
  /// information, read about canary updates.
  core.List<InstanceGroupManagerVersion> versions;

  /// [Output Only] The URL of the zone where the managed instance group is
  /// located (for zonal resources).
  core.String zone;

  InstanceGroupManager();

  InstanceGroupManager.fromJson(core.Map _json) {
    if (_json.containsKey("autoHealingPolicies")) {
      autoHealingPolicies = (_json["autoHealingPolicies"] as core.List)
          .map<InstanceGroupManagerAutoHealingPolicy>((value) =>
              new InstanceGroupManagerAutoHealingPolicy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("baseInstanceName")) {
      baseInstanceName = _json["baseInstanceName"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("currentActions")) {
      currentActions = new InstanceGroupManagerActionsSummary.fromJson(
          _json["currentActions"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("distributionPolicy")) {
      distributionPolicy =
          new DistributionPolicy.fromJson(_json["distributionPolicy"]);
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("instanceGroup")) {
      instanceGroup = _json["instanceGroup"];
    }
    if (_json.containsKey("instanceTemplate")) {
      instanceTemplate = _json["instanceTemplate"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = (_json["namedPorts"] as core.List)
          .map<NamedPort>((value) => new NamedPort.fromJson(value))
          .toList();
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = new InstanceGroupManagerStatus.fromJson(_json["status"]);
    }
    if (_json.containsKey("targetPools")) {
      targetPools = (_json["targetPools"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("targetSize")) {
      targetSize = _json["targetSize"];
    }
    if (_json.containsKey("updatePolicy")) {
      updatePolicy =
          new InstanceGroupManagerUpdatePolicy.fromJson(_json["updatePolicy"]);
    }
    if (_json.containsKey("versions")) {
      versions = (_json["versions"] as core.List)
          .map<InstanceGroupManagerVersion>(
              (value) => new InstanceGroupManagerVersion.fromJson(value))
          .toList();
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoHealingPolicies != null) {
      _json["autoHealingPolicies"] =
          autoHealingPolicies.map((value) => (value).toJson()).toList();
    }
    if (baseInstanceName != null) {
      _json["baseInstanceName"] = baseInstanceName;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (currentActions != null) {
      _json["currentActions"] = (currentActions).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (distributionPolicy != null) {
      _json["distributionPolicy"] = (distributionPolicy).toJson();
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (instanceGroup != null) {
      _json["instanceGroup"] = instanceGroup;
    }
    if (instanceTemplate != null) {
      _json["instanceTemplate"] = instanceTemplate;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = (status).toJson();
    }
    if (targetPools != null) {
      _json["targetPools"] = targetPools;
    }
    if (targetSize != null) {
      _json["targetSize"] = targetSize;
    }
    if (updatePolicy != null) {
      _json["updatePolicy"] = (updatePolicy).toJson();
    }
    if (versions != null) {
      _json["versions"] = versions.map((value) => (value).toJson()).toList();
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class InstanceGroupManagerActionsSummary {
  /// [Output Only] The total number of instances in the managed instance group
  /// that are scheduled to be abandoned. Abandoning an instance removes it from
  /// the managed instance group without deleting it.
  core.int abandoning;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be created or are currently being created. If the group
  /// fails to create any of these instances, it tries again until it creates
  /// the instance successfully.
  ///
  /// If you have disabled creation retries, this field will not be populated;
  /// instead, the creatingWithoutRetries field will be populated.
  core.int creating;

  /// [Output Only] The number of instances that the managed instance group will
  /// attempt to create. The group attempts to create each instance only once.
  /// If the group fails to create any of these instances, it decreases the
  /// group's targetSize value accordingly.
  core.int creatingWithoutRetries;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be deleted or are currently being deleted.
  core.int deleting;

  /// [Output Only] The number of instances in the managed instance group that
  /// are running and have no scheduled actions.
  core.int none;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be recreated or are currently being being recreated.
  /// Recreating an instance deletes the existing root persistent disk and
  /// creates a new disk from the image that is defined in the instance
  /// template.
  core.int recreating;

  /// [Output Only] The number of instances in the managed instance group that
  /// are being reconfigured with properties that do not require a restart or a
  /// recreate action. For example, setting or removing target pools for the
  /// instance.
  core.int refreshing;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be restarted or are currently being restarted.
  core.int restarting;

  /// [Output Only] The number of instances in the managed instance group that
  /// are being verified. See the managedInstances[].currentAction property in
  /// the listManagedInstances method documentation.
  core.int verifying;

  InstanceGroupManagerActionsSummary();

  InstanceGroupManagerActionsSummary.fromJson(core.Map _json) {
    if (_json.containsKey("abandoning")) {
      abandoning = _json["abandoning"];
    }
    if (_json.containsKey("creating")) {
      creating = _json["creating"];
    }
    if (_json.containsKey("creatingWithoutRetries")) {
      creatingWithoutRetries = _json["creatingWithoutRetries"];
    }
    if (_json.containsKey("deleting")) {
      deleting = _json["deleting"];
    }
    if (_json.containsKey("none")) {
      none = _json["none"];
    }
    if (_json.containsKey("recreating")) {
      recreating = _json["recreating"];
    }
    if (_json.containsKey("refreshing")) {
      refreshing = _json["refreshing"];
    }
    if (_json.containsKey("restarting")) {
      restarting = _json["restarting"];
    }
    if (_json.containsKey("verifying")) {
      verifying = _json["verifying"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (abandoning != null) {
      _json["abandoning"] = abandoning;
    }
    if (creating != null) {
      _json["creating"] = creating;
    }
    if (creatingWithoutRetries != null) {
      _json["creatingWithoutRetries"] = creatingWithoutRetries;
    }
    if (deleting != null) {
      _json["deleting"] = deleting;
    }
    if (none != null) {
      _json["none"] = none;
    }
    if (recreating != null) {
      _json["recreating"] = recreating;
    }
    if (refreshing != null) {
      _json["refreshing"] = refreshing;
    }
    if (restarting != null) {
      _json["restarting"] = restarting;
    }
    if (verifying != null) {
      _json["verifying"] = verifying;
    }
    return _json;
  }
}

class InstanceGroupManagerAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagerAggregatedListWarningData();

  InstanceGroupManagerAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupManagerAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagerAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagerAggregatedListWarning();

  InstanceGroupManagerAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceGroupManagerAggregatedListWarningData>((value) =>
              new InstanceGroupManagerAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupManagerAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManagersScopedList resources.
  core.Map<core.String, InstanceGroupManagersScopedList> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerAggregatedList for an aggregated list of
  /// managed instance groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupManagerAggregatedListWarning warning;

  InstanceGroupManagerAggregatedList();

  InstanceGroupManagerAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, InstanceGroupManagersScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) =>
              new InstanceGroupManagersScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceGroupManagerAggregatedListWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<InstanceGroupManagersScopedList,
              core.Map<core.String, core.Object>>(
          items, (InstanceGroupManagersScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupManagerAutoHealingPolicy {
  /// The URL for the health check that signals autohealing.
  core.String healthCheck;

  /// The number of seconds that the managed instance group waits before it
  /// applies autohealing policies to new instances or recently recreated
  /// instances. This initial delay allows instances to initialize and run their
  /// startup scripts before the instance group determines that they are
  /// UNHEALTHY. This prevents the managed instance group from recreating its
  /// instances prematurely. This value must be from range [0, 3600].
  core.int initialDelaySec;

  InstanceGroupManagerAutoHealingPolicy();

  InstanceGroupManagerAutoHealingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("healthCheck")) {
      healthCheck = _json["healthCheck"];
    }
    if (_json.containsKey("initialDelaySec")) {
      initialDelaySec = _json["initialDelaySec"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthCheck != null) {
      _json["healthCheck"] = healthCheck;
    }
    if (initialDelaySec != null) {
      _json["initialDelaySec"] = initialDelaySec;
    }
    return _json;
  }
}

class InstanceGroupManagerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagerListWarningData();

  InstanceGroupManagerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupManagerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagerListWarning();

  InstanceGroupManagerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceGroupManagerListWarningData>((value) =>
              new InstanceGroupManagerListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// [Output Only] A list of managed instance groups.
class InstanceGroupManagerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerList for a list of managed instance groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupManagerListWarning warning;

  InstanceGroupManagerList();

  InstanceGroupManagerList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceGroupManager>(
              (value) => new InstanceGroupManager.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceGroupManagerListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupManagerStatus {
  /// [Output Only] The URL of the Autoscaler that targets this instance group
  /// manager.
  core.String autoscaler;

  /// [Output Only] A bit indicating whether the managed instance group is in a
  /// stable state. A stable state means that: none of the instances in the
  /// managed instance group is currently undergoing any type of change (for
  /// example, creation, restart, or deletion); no future changes are scheduled
  /// for instances in the managed instance group; and the managed instance
  /// group itself is not being modified.
  core.bool isStable;

  /// [Output Only] A status of consistency of Instances' versions with their
  /// target version specified by version field on Instance Group Manager.
  InstanceGroupManagerStatusVersionTarget versionTarget;

  InstanceGroupManagerStatus();

  InstanceGroupManagerStatus.fromJson(core.Map _json) {
    if (_json.containsKey("autoscaler")) {
      autoscaler = _json["autoscaler"];
    }
    if (_json.containsKey("isStable")) {
      isStable = _json["isStable"];
    }
    if (_json.containsKey("versionTarget")) {
      versionTarget = new InstanceGroupManagerStatusVersionTarget.fromJson(
          _json["versionTarget"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoscaler != null) {
      _json["autoscaler"] = autoscaler;
    }
    if (isStable != null) {
      _json["isStable"] = isStable;
    }
    if (versionTarget != null) {
      _json["versionTarget"] = (versionTarget).toJson();
    }
    return _json;
  }
}

class InstanceGroupManagerStatusVersionTarget {
  /// [Output Only] A bit indicating whether version target has been reached in
  /// this managed instance group, i.e. all instances are in their target
  /// version. Instances' target version are specified by version field on
  /// Instance Group Manager.
  core.bool isReached;

  InstanceGroupManagerStatusVersionTarget();

  InstanceGroupManagerStatusVersionTarget.fromJson(core.Map _json) {
    if (_json.containsKey("isReached")) {
      isReached = _json["isReached"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (isReached != null) {
      _json["isReached"] = isReached;
    }
    return _json;
  }
}

class InstanceGroupManagerUpdatePolicy {
  /// The  instance redistribution policy for regional managed instance groups.
  /// Valid values are:
  /// - PROACTIVE (default): The group attempts to maintain an even distribution
  /// of VM instances across zones in the region.
  /// - NONE: For non-autoscaled groups, proactive redistribution is disabled.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROACTIVE"
  core.String instanceRedistributionType;

  /// The maximum number of instances that can be created above the specified
  /// targetSize during the update process. By default, a fixed value of 1 is
  /// used. This value can be either a fixed number or a percentage if the
  /// instance group has 10 or more instances. If you set a percentage, the
  /// number of instances will be rounded up if necessary.
  ///
  /// At least one of either maxSurge or maxUnavailable must be greater than 0.
  /// Learn more about maxSurge.
  FixedOrPercent maxSurge;

  /// The maximum number of instances that can be unavailable during the update
  /// process. An instance is considered available if all of the following
  /// conditions are satisfied:
  ///
  ///
  /// - The instance's status is RUNNING.
  /// - If there is a health check on the instance group, the instance's
  /// liveness health check result must be HEALTHY at least once. If there is no
  /// health check on the group, then the instance only needs to have a status
  /// of RUNNING to be considered available.  By default, a fixed value of 1 is
  /// used. This value can be either a fixed number or a percentage if the
  /// instance group has 10 or more instances. If you set a percentage, the
  /// number of instances will be rounded up if necessary.
  ///
  /// At least one of either maxSurge or maxUnavailable must be greater than 0.
  /// Learn more about maxUnavailable.
  FixedOrPercent maxUnavailable;

  /// Minimal action to be taken on an instance. You can specify either RESTART
  /// to restart existing instances or REPLACE to delete and create new
  /// instances from the target template. If you specify a RESTART, the Updater
  /// will attempt to perform that action only. However, if the Updater
  /// determines that the minimal action you specify is not enough to perform
  /// the update, it might perform a more disruptive action.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String minimalAction;

  /// What action should be used to replace instances. See
  /// minimal_action.REPLACE
  /// Possible string values are:
  /// - "RECREATE"
  /// - "SUBSTITUTE"
  core.String replacementMethod;

  /// The type of update process. You can specify either PROACTIVE so that the
  /// instance group manager proactively executes actions in order to bring
  /// instances to their target versions or OPPORTUNISTIC so that no action is
  /// proactively executed but the update will be performed as part of other
  /// actions (for example, resizes or recreateInstances calls).
  /// Possible string values are:
  /// - "OPPORTUNISTIC"
  /// - "PROACTIVE"
  core.String type;

  InstanceGroupManagerUpdatePolicy();

  InstanceGroupManagerUpdatePolicy.fromJson(core.Map _json) {
    if (_json.containsKey("instanceRedistributionType")) {
      instanceRedistributionType = _json["instanceRedistributionType"];
    }
    if (_json.containsKey("maxSurge")) {
      maxSurge = new FixedOrPercent.fromJson(_json["maxSurge"]);
    }
    if (_json.containsKey("maxUnavailable")) {
      maxUnavailable = new FixedOrPercent.fromJson(_json["maxUnavailable"]);
    }
    if (_json.containsKey("minimalAction")) {
      minimalAction = _json["minimalAction"];
    }
    if (_json.containsKey("replacementMethod")) {
      replacementMethod = _json["replacementMethod"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceRedistributionType != null) {
      _json["instanceRedistributionType"] = instanceRedistributionType;
    }
    if (maxSurge != null) {
      _json["maxSurge"] = (maxSurge).toJson();
    }
    if (maxUnavailable != null) {
      _json["maxUnavailable"] = (maxUnavailable).toJson();
    }
    if (minimalAction != null) {
      _json["minimalAction"] = minimalAction;
    }
    if (replacementMethod != null) {
      _json["replacementMethod"] = replacementMethod;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class InstanceGroupManagerVersion {
  /// The URL of the instance template that is specified for this managed
  /// instance group. The group uses this template to create new instances in
  /// the managed instance group until the `targetSize` for this version is
  /// reached.
  core.String instanceTemplate;

  /// Name of the version. Unique among all versions in the scope of this
  /// managed instance group.
  core.String name;

  /// Specifies the intended number of instances to be created from the
  /// instanceTemplate. The final number of instances created from the template
  /// will be equal to:
  /// - If expressed as a fixed number, the minimum of either targetSize.fixed
  /// or instanceGroupManager.targetSize is used.
  /// - if expressed as a percent, the targetSize would be
  /// (targetSize.percent/100 * InstanceGroupManager.targetSize) If there is a
  /// remainder, the number is rounded up.  If unset, this version will update
  /// any remaining instances not updated by another version. Read Starting a
  /// canary update for more information.
  FixedOrPercent targetSize;

  InstanceGroupManagerVersion();

  InstanceGroupManagerVersion.fromJson(core.Map _json) {
    if (_json.containsKey("instanceTemplate")) {
      instanceTemplate = _json["instanceTemplate"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("targetSize")) {
      targetSize = new FixedOrPercent.fromJson(_json["targetSize"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceTemplate != null) {
      _json["instanceTemplate"] = instanceTemplate;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (targetSize != null) {
      _json["targetSize"] = (targetSize).toJson();
    }
    return _json;
  }
}

class InstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersAbandonInstancesRequest();

  InstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

/// InstanceGroupManagers.applyUpdatesToInstances
class InstanceGroupManagersApplyUpdatesRequest {
  /// The list of URLs of one or more instances for which you want to apply
  /// updates. Each URL can be a full URL or a partial URL, such as
  /// zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  /// The minimal action that you want to perform on each instance during the
  /// update:
  /// - REPLACE: At minimum, delete the instance and create it again.
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all.  By default, the minimum
  /// action is NONE. If your update requires a more disruptive action than you
  /// set with this flag, the necessary action is performed to execute the
  /// update.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update:
  /// - REPLACE: Delete the instance and create it again.
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all.  By default, the most
  /// disruptive allowed action is REPLACE. If your update requires a more
  /// disruptive action than you set with this flag, the update request will
  /// fail.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String mostDisruptiveAllowedAction;

  InstanceGroupManagersApplyUpdatesRequest();

  InstanceGroupManagersApplyUpdatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("minimalAction")) {
      minimalAction = _json["minimalAction"];
    }
    if (_json.containsKey("mostDisruptiveAllowedAction")) {
      mostDisruptiveAllowedAction = _json["mostDisruptiveAllowedAction"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    if (minimalAction != null) {
      _json["minimalAction"] = minimalAction;
    }
    if (mostDisruptiveAllowedAction != null) {
      _json["mostDisruptiveAllowedAction"] = mostDisruptiveAllowedAction;
    }
    return _json;
  }
}

/// InstanceGroupManagers.createInstances
class InstanceGroupManagersCreateInstancesRequest {
  /// [Required] List of specifications of per-instance configs.
  core.List<PerInstanceConfig> instances;

  InstanceGroupManagersCreateInstancesRequest();

  InstanceGroupManagersCreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List)
          .map<PerInstanceConfig>(
              (value) => new PerInstanceConfig.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersDeleteInstancesRequest();

  InstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class InstanceGroupManagersListErrorsResponse {
  /// [Output Only] The list of errors of the managed instance group.
  core.List<InstanceManagedByIgmError> items;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  InstanceGroupManagersListErrorsResponse();

  InstanceGroupManagersListErrorsResponse.fromJson(core.Map _json) {
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceManagedByIgmError>(
              (value) => new InstanceManagedByIgmError.fromJson(value))
          .toList();
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    return _json;
  }
}

class InstanceGroupManagersListManagedInstancesResponse {
  /// [Output Only] The list of instances in the managed instance group.
  core.List<ManagedInstance> managedInstances;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  InstanceGroupManagersListManagedInstancesResponse();

  InstanceGroupManagersListManagedInstancesResponse.fromJson(core.Map _json) {
    if (_json.containsKey("managedInstances")) {
      managedInstances = (_json["managedInstances"] as core.List)
          .map<ManagedInstance>((value) => new ManagedInstance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (managedInstances != null) {
      _json["managedInstances"] =
          managedInstances.map((value) => (value).toJson()).toList();
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    return _json;
  }
}

class InstanceGroupManagersRecreateInstancesRequest {
  /// The URLs of one or more instances to recreate. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersRecreateInstancesRequest();

  InstanceGroupManagersRecreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class InstanceGroupManagersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagersScopedListWarningData();

  InstanceGroupManagersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] The warning that replaces the list of managed instance groups
/// when the list is empty.
class InstanceGroupManagersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagersScopedListWarning();

  InstanceGroupManagersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceGroupManagersScopedListWarningData>((value) =>
              new InstanceGroupManagersScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupManagersScopedList {
  /// [Output Only] The list of managed instance groups that are contained in
  /// the specified project and zone.
  core.List<InstanceGroupManager> instanceGroupManagers;

  /// [Output Only] The warning that replaces the list of managed instance
  /// groups when the list is empty.
  InstanceGroupManagersScopedListWarning warning;

  InstanceGroupManagersScopedList();

  InstanceGroupManagersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("instanceGroupManagers")) {
      instanceGroupManagers = (_json["instanceGroupManagers"] as core.List)
          .map<InstanceGroupManager>(
              (value) => new InstanceGroupManager.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new InstanceGroupManagersScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceGroupManagers != null) {
      _json["instanceGroupManagers"] =
          instanceGroupManagers.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupManagersSetInstanceTemplateRequest {
  /// The URL of the instance template that is specified for this managed
  /// instance group. The group uses this template to create all new instances
  /// in the managed instance group.
  core.String instanceTemplate;

  InstanceGroupManagersSetInstanceTemplateRequest();

  InstanceGroupManagersSetInstanceTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instanceTemplate")) {
      instanceTemplate = _json["instanceTemplate"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceTemplate != null) {
      _json["instanceTemplate"] = instanceTemplate;
    }
    return _json;
  }
}

class InstanceGroupManagersSetTargetPoolsRequest {
  /// The fingerprint of the target pools information. Use this optional
  /// property to prevent conflicts when multiple users change the target pools
  /// settings concurrently. Obtain the fingerprint with the
  /// instanceGroupManagers.get method. Then, include the fingerprint in your
  /// request to ensure that you do not overwrite changes that were applied from
  /// another concurrent request.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of target pool URLs that instances in this managed instance group
  /// belong to. The managed instance group applies these target pools to all of
  /// the instances in the group. Existing instances and new instances in the
  /// group all receive these target pool settings.
  core.List<core.String> targetPools;

  InstanceGroupManagersSetTargetPoolsRequest();

  InstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("targetPools")) {
      targetPools = (_json["targetPools"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (targetPools != null) {
      _json["targetPools"] = targetPools;
    }
    return _json;
  }
}

class InstanceGroupsAddInstancesRequest {
  /// The list of instances to add to the instance group.
  core.List<InstanceReference> instances;

  InstanceGroupsAddInstancesRequest();

  InstanceGroupsAddInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List)
          .map<InstanceReference>(
              (value) => new InstanceReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupsListInstancesWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupsListInstancesWarningData();

  InstanceGroupsListInstancesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupsListInstancesWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupsListInstancesWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupsListInstancesWarning();

  InstanceGroupsListInstancesWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceGroupsListInstancesWarningData>((value) =>
              new InstanceGroupsListInstancesWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupsListInstances {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupsListInstances for the list of instances in the
  /// specified instance group.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupsListInstancesWarning warning;

  InstanceGroupsListInstances();

  InstanceGroupsListInstances.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceWithNamedPorts>(
              (value) => new InstanceWithNamedPorts.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new InstanceGroupsListInstancesWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupsListInstancesRequest {
  /// A filter for the state of the instances in the instance group. Valid
  /// options are ALL or RUNNING. If you do not specify this parameter the list
  /// includes all instances regardless of their state.
  /// Possible string values are:
  /// - "ALL"
  /// - "RUNNING"
  core.String instanceState;

  InstanceGroupsListInstancesRequest();

  InstanceGroupsListInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instanceState")) {
      instanceState = _json["instanceState"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceState != null) {
      _json["instanceState"] = instanceState;
    }
    return _json;
  }
}

class InstanceGroupsRemoveInstancesRequest {
  /// The list of instances to remove from the instance group.
  core.List<InstanceReference> instances;

  InstanceGroupsRemoveInstancesRequest();

  InstanceGroupsRemoveInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List)
          .map<InstanceReference>(
              (value) => new InstanceReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupsScopedListWarningData();

  InstanceGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that replaces the list of instance
/// groups when the list is empty.
class InstanceGroupsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupsScopedListWarning();

  InstanceGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceGroupsScopedListWarningData>((value) =>
              new InstanceGroupsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceGroupsScopedList {
  /// [Output Only] The list of instance groups that are contained in this
  /// scope.
  core.List<InstanceGroup> instanceGroups;

  /// [Output Only] An informational warning that replaces the list of instance
  /// groups when the list is empty.
  InstanceGroupsScopedListWarning warning;

  InstanceGroupsScopedList();

  InstanceGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("instanceGroups")) {
      instanceGroups = (_json["instanceGroups"] as core.List)
          .map<InstanceGroup>((value) => new InstanceGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceGroupsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceGroups != null) {
      _json["instanceGroups"] =
          instanceGroups.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request. A request with an incorrect fingerprint will fail with
  /// error 412 conditionNotMet.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort> namedPorts;

  InstanceGroupsSetNamedPortsRequest();

  InstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = (_json["namedPorts"] as core.List)
          .map<NamedPort>((value) => new NamedPort.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstanceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceListWarningData();

  InstanceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceListWarning();

  InstanceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceListWarningData>(
              (value) => new InstanceListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of instances.
class InstanceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Instance resources.
  core.List<Instance> items;

  /// [Output Only] Type of resource. Always compute#instanceList for lists of
  /// Instance resources.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceListWarning warning;

  InstanceList();

  InstanceList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Instance>((value) => new Instance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceListReferrersWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceListReferrersWarningData();

  InstanceListReferrersWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceListReferrersWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceListReferrersWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceListReferrersWarning();

  InstanceListReferrersWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceListReferrersWarningData>(
              (value) => new InstanceListReferrersWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of instance referrers.
class InstanceListReferrers {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Reference resources.
  core.List<Reference> items;

  /// [Output Only] Type of resource. Always compute#instanceListReferrers for
  /// lists of Instance referrers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceListReferrersWarning warning;

  InstanceListReferrers();

  InstanceListReferrers.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Reference>((value) => new Reference.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceListReferrersWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceManagedByIgmError {
  /// [Output Only] Contents of the error.
  InstanceManagedByIgmErrorManagedInstanceError error;

  /// [Output Only] Details of the instance action that triggered this error.
  /// May be null, if the error was not caused by an action on an instance. This
  /// field is optional.
  InstanceManagedByIgmErrorInstanceActionDetails instanceActionDetails;

  /// [Output Only] The time that this error occurred. This value is in RFC3339
  /// text format.
  core.String timestamp;

  InstanceManagedByIgmError();

  InstanceManagedByIgmError.fromJson(core.Map _json) {
    if (_json.containsKey("error")) {
      error = new InstanceManagedByIgmErrorManagedInstanceError.fromJson(
          _json["error"]);
    }
    if (_json.containsKey("instanceActionDetails")) {
      instanceActionDetails =
          new InstanceManagedByIgmErrorInstanceActionDetails.fromJson(
              _json["instanceActionDetails"]);
    }
    if (_json.containsKey("timestamp")) {
      timestamp = _json["timestamp"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (error != null) {
      _json["error"] = (error).toJson();
    }
    if (instanceActionDetails != null) {
      _json["instanceActionDetails"] = (instanceActionDetails).toJson();
    }
    if (timestamp != null) {
      _json["timestamp"] = timestamp;
    }
    return _json;
  }
}

class InstanceManagedByIgmErrorInstanceActionDetails {
  /// [Output Only] Action that managed instance group was executing on the
  /// instance when the error occurred. Possible values:
  /// Possible string values are:
  /// - "ABANDONING"
  /// - "CREATING"
  /// - "CREATING_WITHOUT_RETRIES"
  /// - "DELETING"
  /// - "NONE"
  /// - "RECREATING"
  /// - "REFRESHING"
  /// - "RESTARTING"
  /// - "VERIFYING"
  core.String action;

  /// [Output Only] The URL of the instance. The URL can be set even if the
  /// instance has not yet been created.
  core.String instance;

  /// [Output Only] Version this instance was created from, or was being created
  /// from, but the creation failed. Corresponds to one of the versions that
  /// were set on the Instance Group Manager resource at the time this instance
  /// was being created.
  ManagedInstanceVersion version;

  InstanceManagedByIgmErrorInstanceActionDetails();

  InstanceManagedByIgmErrorInstanceActionDetails.fromJson(core.Map _json) {
    if (_json.containsKey("action")) {
      action = _json["action"];
    }
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("version")) {
      version = new ManagedInstanceVersion.fromJson(_json["version"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (action != null) {
      _json["action"] = action;
    }
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (version != null) {
      _json["version"] = (version).toJson();
    }
    return _json;
  }
}

class InstanceManagedByIgmErrorManagedInstanceError {
  /// [Output Only] Error code.
  core.String code;

  /// [Output Only] Error message.
  core.String message;

  InstanceManagedByIgmErrorManagedInstanceError();

  InstanceManagedByIgmErrorManagedInstanceError.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstanceMoveRequest {
  /// The URL of the destination zone to move the instance. This can be a full
  /// or partial URL. For example, the following are all valid URLs to a zone:
  /// - https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// - projects/project/zones/zone
  /// - zones/zone
  core.String destinationZone;

  /// The URL of the target instance to move. This can be a full or partial URL.
  /// For example, the following are all valid URLs to an instance:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  /// - zones/zone/instances/instance
  core.String targetInstance;

  InstanceMoveRequest();

  InstanceMoveRequest.fromJson(core.Map _json) {
    if (_json.containsKey("destinationZone")) {
      destinationZone = _json["destinationZone"];
    }
    if (_json.containsKey("targetInstance")) {
      targetInstance = _json["targetInstance"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (destinationZone != null) {
      _json["destinationZone"] = destinationZone;
    }
    if (targetInstance != null) {
      _json["targetInstance"] = targetInstance;
    }
    return _json;
  }
}

class InstanceProperties {
  /// Enables instances created based on this template to send packets with
  /// source IP addresses other than their own and receive packets with
  /// destination IP addresses other than their own. If these instances will be
  /// used as an IP gateway or it will be set as the next-hop in a Route
  /// resource, specify true. If unsure, leave this set to false. See the Enable
  /// IP forwarding documentation for more information.
  core.bool canIpForward;

  /// An optional text description for the instances that are created from this
  /// instance template.
  core.String description;

  /// An array of disks that are associated with the instances that are created
  /// from this template.
  core.List<AttachedDisk> disks;

  /// A list of guest accelerator cards' type and count to use for instances
  /// created from the instance template.
  core.List<AcceleratorConfig> guestAccelerators;

  /// Labels to apply to instances that are created from this template.
  core.Map<core.String, core.String> labels;

  /// The machine type to use for instances that are created from this template.
  core.String machineType;

  /// The metadata key/value pairs to assign to instances that are created from
  /// this template. These pairs can consist of custom metadata or predefined
  /// keys. See Project and instance metadata for more information.
  Metadata metadata;

  /// Minimum cpu/platform to be used by this instance. The instance may be
  /// scheduled on the specified or newer cpu/platform. Applicable values are
  /// the friendly names of CPU platforms, such as minCpuPlatform: "Intel
  /// Haswell" or minCpuPlatform: "Intel Sandy Bridge". For more information,
  /// read Specifying a Minimum CPU Platform.
  core.String minCpuPlatform;

  /// An array of network access configurations for this interface.
  core.List<NetworkInterface> networkInterfaces;

  /// Specifies the reservations that this instance can consume from.
  ReservationAffinity reservationAffinity;

  /// Resource policies (names, not ULRs) applied to instances created from this
  /// template.
  core.List<core.String> resourcePolicies;

  /// Specifies the scheduling options for the instances that are created from
  /// this template.
  Scheduling scheduling;

  /// A list of service accounts with specified scopes. Access tokens for these
  /// service accounts are available to the instances that are created from this
  /// template. Use metadata queries to obtain the access tokens for these
  /// instances.
  core.List<ServiceAccount> serviceAccounts;
  ShieldedInstanceConfig shieldedInstanceConfig;

  /// A list of tags to apply to the instances that are created from this
  /// template. The tags identify valid sources or targets for network
  /// firewalls. The setTags method can modify this list of tags. Each tag
  /// within the list must comply with RFC1035.
  Tags tags;

  InstanceProperties();

  InstanceProperties.fromJson(core.Map _json) {
    if (_json.containsKey("canIpForward")) {
      canIpForward = _json["canIpForward"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("disks")) {
      disks = (_json["disks"] as core.List)
          .map<AttachedDisk>((value) => new AttachedDisk.fromJson(value))
          .toList();
    }
    if (_json.containsKey("guestAccelerators")) {
      guestAccelerators = (_json["guestAccelerators"] as core.List)
          .map<AcceleratorConfig>(
              (value) => new AcceleratorConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("machineType")) {
      machineType = _json["machineType"];
    }
    if (_json.containsKey("metadata")) {
      metadata = new Metadata.fromJson(_json["metadata"]);
    }
    if (_json.containsKey("minCpuPlatform")) {
      minCpuPlatform = _json["minCpuPlatform"];
    }
    if (_json.containsKey("networkInterfaces")) {
      networkInterfaces = (_json["networkInterfaces"] as core.List)
          .map<NetworkInterface>(
              (value) => new NetworkInterface.fromJson(value))
          .toList();
    }
    if (_json.containsKey("reservationAffinity")) {
      reservationAffinity =
          new ReservationAffinity.fromJson(_json["reservationAffinity"]);
    }
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("scheduling")) {
      scheduling = new Scheduling.fromJson(_json["scheduling"]);
    }
    if (_json.containsKey("serviceAccounts")) {
      serviceAccounts = (_json["serviceAccounts"] as core.List)
          .map<ServiceAccount>((value) => new ServiceAccount.fromJson(value))
          .toList();
    }
    if (_json.containsKey("shieldedInstanceConfig")) {
      shieldedInstanceConfig =
          new ShieldedInstanceConfig.fromJson(_json["shieldedInstanceConfig"]);
    }
    if (_json.containsKey("tags")) {
      tags = new Tags.fromJson(_json["tags"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (canIpForward != null) {
      _json["canIpForward"] = canIpForward;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (disks != null) {
      _json["disks"] = disks.map((value) => (value).toJson()).toList();
    }
    if (guestAccelerators != null) {
      _json["guestAccelerators"] =
          guestAccelerators.map((value) => (value).toJson()).toList();
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (machineType != null) {
      _json["machineType"] = machineType;
    }
    if (metadata != null) {
      _json["metadata"] = (metadata).toJson();
    }
    if (minCpuPlatform != null) {
      _json["minCpuPlatform"] = minCpuPlatform;
    }
    if (networkInterfaces != null) {
      _json["networkInterfaces"] =
          networkInterfaces.map((value) => (value).toJson()).toList();
    }
    if (reservationAffinity != null) {
      _json["reservationAffinity"] = (reservationAffinity).toJson();
    }
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    if (scheduling != null) {
      _json["scheduling"] = (scheduling).toJson();
    }
    if (serviceAccounts != null) {
      _json["serviceAccounts"] =
          serviceAccounts.map((value) => (value).toJson()).toList();
    }
    if (shieldedInstanceConfig != null) {
      _json["shieldedInstanceConfig"] = (shieldedInstanceConfig).toJson();
    }
    if (tags != null) {
      _json["tags"] = (tags).toJson();
    }
    return _json;
  }
}

class InstanceReference {
  /// The URL for a specific instance.
  core.String instance;

  InstanceReference();

  InstanceReference.fromJson(core.Map _json) {
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instance != null) {
      _json["instance"] = instance;
    }
    return _json;
  }
}

/// Represents an Instance Template resource.
///
/// You can use instance templates to create VM instances and managed instance
/// groups. For more information, read Instance Templates. (== resource_for
/// {$api_version}.instanceTemplates ==)
class InstanceTemplate {
  /// [Output Only] The creation timestamp for this instance template in RFC3339
  /// text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] A unique identifier for this instance template. The server
  /// defines this identifier.
  core.String id;

  /// [Output Only] The resource type, which is always compute#instanceTemplate
  /// for instance templates.
  core.String kind;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The instance properties for this instance template.
  InstanceProperties properties;

  /// [Output Only] The URL for this instance template. The server defines this
  /// URL.
  core.String selfLink;

  /// The source instance used to create the template. You can provide this as a
  /// partial or full URL to the resource. For example, the following are valid
  /// values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  core.String sourceInstance;

  /// The source instance params to use to create this instance template.
  SourceInstanceParams sourceInstanceParams;

  InstanceTemplate();

  InstanceTemplate.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("properties")) {
      properties = new InstanceProperties.fromJson(_json["properties"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sourceInstance")) {
      sourceInstance = _json["sourceInstance"];
    }
    if (_json.containsKey("sourceInstanceParams")) {
      sourceInstanceParams =
          new SourceInstanceParams.fromJson(_json["sourceInstanceParams"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (properties != null) {
      _json["properties"] = (properties).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sourceInstance != null) {
      _json["sourceInstance"] = sourceInstance;
    }
    if (sourceInstanceParams != null) {
      _json["sourceInstanceParams"] = (sourceInstanceParams).toJson();
    }
    return _json;
  }
}

class InstanceTemplateListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceTemplateListWarningData();

  InstanceTemplateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceTemplateListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceTemplateListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceTemplateListWarning();

  InstanceTemplateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstanceTemplateListWarningData>(
              (value) => new InstanceTemplateListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// A list of instance templates.
class InstanceTemplateList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceTemplate resources.
  core.List<InstanceTemplate> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceTemplatesListResponse for instance template lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceTemplateListWarning warning;

  InstanceTemplateList();

  InstanceTemplateList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceTemplate>(
              (value) => new InstanceTemplate.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InstanceTemplateListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstanceWithNamedPorts {
  /// [Output Only] The URL of the instance.
  core.String instance;

  /// [Output Only] The named ports that belong to this instance group.
  core.List<NamedPort> namedPorts;

  /// [Output Only] The status of the instance.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String status;

  InstanceWithNamedPorts();

  InstanceWithNamedPorts.fromJson(core.Map _json) {
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = (_json["namedPorts"] as core.List)
          .map<NamedPort>((value) => new NamedPort.fromJson(value))
          .toList();
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

class InstancesAddResourcePoliciesRequest {
  /// Resource policies to be added to this instance.
  core.List<core.String> resourcePolicies;

  InstancesAddResourcePoliciesRequest();

  InstancesAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    return _json;
  }
}

class InstancesRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this instance.
  core.List<core.String> resourcePolicies;

  InstancesRemoveResourcePoliciesRequest();

  InstancesRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    return _json;
  }
}

class InstancesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstancesScopedListWarningData();

  InstancesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of instances
/// when the list is empty.
class InstancesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstancesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstancesScopedListWarning();

  InstancesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InstancesScopedListWarningData>(
              (value) => new InstancesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InstancesScopedList {
  /// [Output Only] A list of instances contained in this scope.
  core.List<Instance> instances;

  /// [Output Only] Informational warning which replaces the list of instances
  /// when the list is empty.
  InstancesScopedListWarning warning;

  InstancesScopedList();

  InstancesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List)
          .map<Instance>((value) => new Instance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new InstancesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InstancesSetLabelsRequest {
  /// Fingerprint of the previous set of labels for this resource, used to
  /// prevent conflicts. Provide the latest fingerprint value when making a
  /// request to add or change labels.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  core.Map<core.String, core.String> labels;

  InstancesSetLabelsRequest();

  InstancesSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    return _json;
  }
}

class InstancesSetMachineResourcesRequest {
  /// A list of the type and count of accelerator cards attached to the
  /// instance.
  core.List<AcceleratorConfig> guestAccelerators;

  InstancesSetMachineResourcesRequest();

  InstancesSetMachineResourcesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("guestAccelerators")) {
      guestAccelerators = (_json["guestAccelerators"] as core.List)
          .map<AcceleratorConfig>(
              (value) => new AcceleratorConfig.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (guestAccelerators != null) {
      _json["guestAccelerators"] =
          guestAccelerators.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class InstancesSetMachineTypeRequest {
  /// Full or partial URL of the machine type resource. See Machine Types for a
  /// full list of machine types. For example:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  core.String machineType;

  InstancesSetMachineTypeRequest();

  InstancesSetMachineTypeRequest.fromJson(core.Map _json) {
    if (_json.containsKey("machineType")) {
      machineType = _json["machineType"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (machineType != null) {
      _json["machineType"] = machineType;
    }
    return _json;
  }
}

class InstancesSetMinCpuPlatformRequest {
  /// Minimum cpu/platform this instance should be started at.
  core.String minCpuPlatform;

  InstancesSetMinCpuPlatformRequest();

  InstancesSetMinCpuPlatformRequest.fromJson(core.Map _json) {
    if (_json.containsKey("minCpuPlatform")) {
      minCpuPlatform = _json["minCpuPlatform"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (minCpuPlatform != null) {
      _json["minCpuPlatform"] = minCpuPlatform;
    }
    return _json;
  }
}

class InstancesSetServiceAccountRequest {
  /// Email address of the service account.
  core.String email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String> scopes;

  InstancesSetServiceAccountRequest();

  InstancesSetServiceAccountRequest.fromJson(core.Map _json) {
    if (_json.containsKey("email")) {
      email = _json["email"];
    }
    if (_json.containsKey("scopes")) {
      scopes = (_json["scopes"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (email != null) {
      _json["email"] = email;
    }
    if (scopes != null) {
      _json["scopes"] = scopes;
    }
    return _json;
  }
}

class InstancesStartWithEncryptionKeyRequest {
  /// Array of disks associated with this instance that are protected with a
  /// customer-supplied encryption key.
  ///
  /// In order to start the instance, the disk url and its corresponding key
  /// must be provided.
  ///
  /// If the disk is not protected with a customer-supplied encryption key it
  /// should not be specified.
  core.List<CustomerEncryptionKeyProtectedDisk> disks;

  InstancesStartWithEncryptionKeyRequest();

  InstancesStartWithEncryptionKeyRequest.fromJson(core.Map _json) {
    if (_json.containsKey("disks")) {
      disks = (_json["disks"] as core.List)
          .map<CustomerEncryptionKeyProtectedDisk>(
              (value) => new CustomerEncryptionKeyProtectedDisk.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (disks != null) {
      _json["disks"] = disks.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// HttpRouteRuleMatch criteria for field values that must stay within the
/// specified integer range.
class Int64RangeMatch {
  /// The end of the range (exclusive) in signed long integer format.
  core.String rangeEnd;

  /// The start of the range (inclusive) in signed long integer format.
  core.String rangeStart;

  Int64RangeMatch();

  Int64RangeMatch.fromJson(core.Map _json) {
    if (_json.containsKey("rangeEnd")) {
      rangeEnd = _json["rangeEnd"];
    }
    if (_json.containsKey("rangeStart")) {
      rangeStart = _json["rangeStart"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (rangeEnd != null) {
      _json["rangeEnd"] = rangeEnd;
    }
    if (rangeStart != null) {
      _json["rangeStart"] = rangeStart;
    }
    return _json;
  }
}

/// Represents an Interconnect resource.
///
/// An Interconnect resource is a dedicated connection between the GCP network
/// and your on-premises network. For more information, read the  Dedicated
/// Interconnect Overview. (== resource_for {$api_version}.interconnects ==)
class Interconnect {
  /// Administrative status of the interconnect. When this is set to true, the
  /// Interconnect is functional and can carry traffic. When set to false, no
  /// packets can be carried over the interconnect and no BGP routes are
  /// exchanged over it. By default, the status is set to true.
  core.bool adminEnabled;

  /// [Output Only] A list of CircuitInfo objects, that describe the individual
  /// circuits in this LAG.
  core.List<InterconnectCircuitInfo> circuitInfos;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// Customer name, to put in the Letter of Authorization as the party
  /// authorized to request a crossconnect.
  core.String customerName;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] A list of outages expected for this Interconnect.
  core.List<InterconnectOutageNotification> expectedOutages;

  /// [Output Only] IP address configured on the Google side of the Interconnect
  /// link. This can be used only for ping tests.
  core.String googleIpAddress;

  /// [Output Only] Google reference ID to be used when raising support tickets
  /// with Google or otherwise to debug backend connectivity issues.
  core.String googleReferenceId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of the URLs of all InterconnectAttachments configured
  /// to use this Interconnect.
  core.List<core.String> interconnectAttachments;

  /// Type of interconnect, which can take one of the following values:
  /// - PARTNER: A partner-managed interconnection shared between customers
  /// though a partner.
  /// - DEDICATED: A dedicated physical interconnection with the customer. Note
  /// that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
  /// Possible string values are:
  /// - "DEDICATED"
  /// - "IT_PRIVATE"
  /// - "PARTNER"
  core.String interconnectType;

  /// [Output Only] Type of the resource. Always compute#interconnect for
  /// interconnects.
  core.String kind;

  /// Type of link requested, which can take one of the following values:
  /// - LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics
  /// - LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that
  /// this field indicates the speed of each of the links in the bundle, not the
  /// speed of the entire bundle.
  /// Possible string values are:
  /// - "LINK_TYPE_ETHERNET_100G_LR"
  /// - "LINK_TYPE_ETHERNET_10G_LR"
  core.String linkType;

  /// URL of the InterconnectLocation object that represents where this
  /// connection is to be provisioned.
  core.String location;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Email address to contact the customer NOC for operations and maintenance
  /// notifications regarding this Interconnect. If specified, this will be used
  /// for notifications in addition to all other forms described, such as
  /// Stackdriver logs alerting and Cloud Notifications.
  core.String nocContactEmail;

  /// [Output Only] The current status of this Interconnect's functionality,
  /// which can take one of the following values:
  /// - OS_ACTIVE: A valid Interconnect, which is turned up and is ready to use.
  /// Attachments may be provisioned on this Interconnect.
  /// - OS_UNPROVISIONED: An Interconnect that has not completed turnup. No
  /// attachments may be provisioned on this Interconnect.
  /// - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing internal
  /// maintenance. No attachments may be provisioned or updated on this
  /// Interconnect.
  /// Possible string values are:
  /// - "OS_ACTIVE"
  /// - "OS_UNPROVISIONED"
  core.String operationalStatus;

  /// [Output Only] IP address configured on the customer side of the
  /// Interconnect link. The customer should configure this IP address during
  /// turnup when prompted by Google NOC. This can be used only for ping tests.
  core.String peerIpAddress;

  /// [Output Only] Number of links actually provisioned in this interconnect.
  core.int provisionedLinkCount;

  /// Target number of physical links in the link bundle, as requested by the
  /// customer.
  core.int requestedLinkCount;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The current state of Interconnect functionality, which can
  /// take one of the following values:
  /// - ACTIVE: The Interconnect is valid, turned up and ready to use.
  /// Attachments may be provisioned on this Interconnect.
  /// - UNPROVISIONED: The Interconnect has not completed turnup. No attachments
  /// may be provisioned on this Interconnect.
  /// - UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance.
  /// No attachments may be provisioned or updated on this Interconnect.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "UNPROVISIONED"
  core.String state;

  Interconnect();

  Interconnect.fromJson(core.Map _json) {
    if (_json.containsKey("adminEnabled")) {
      adminEnabled = _json["adminEnabled"];
    }
    if (_json.containsKey("circuitInfos")) {
      circuitInfos = (_json["circuitInfos"] as core.List)
          .map<InterconnectCircuitInfo>(
              (value) => new InterconnectCircuitInfo.fromJson(value))
          .toList();
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("customerName")) {
      customerName = _json["customerName"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("expectedOutages")) {
      expectedOutages = (_json["expectedOutages"] as core.List)
          .map<InterconnectOutageNotification>(
              (value) => new InterconnectOutageNotification.fromJson(value))
          .toList();
    }
    if (_json.containsKey("googleIpAddress")) {
      googleIpAddress = _json["googleIpAddress"];
    }
    if (_json.containsKey("googleReferenceId")) {
      googleReferenceId = _json["googleReferenceId"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("interconnectAttachments")) {
      interconnectAttachments =
          (_json["interconnectAttachments"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("interconnectType")) {
      interconnectType = _json["interconnectType"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("linkType")) {
      linkType = _json["linkType"];
    }
    if (_json.containsKey("location")) {
      location = _json["location"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("nocContactEmail")) {
      nocContactEmail = _json["nocContactEmail"];
    }
    if (_json.containsKey("operationalStatus")) {
      operationalStatus = _json["operationalStatus"];
    }
    if (_json.containsKey("peerIpAddress")) {
      peerIpAddress = _json["peerIpAddress"];
    }
    if (_json.containsKey("provisionedLinkCount")) {
      provisionedLinkCount = _json["provisionedLinkCount"];
    }
    if (_json.containsKey("requestedLinkCount")) {
      requestedLinkCount = _json["requestedLinkCount"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (adminEnabled != null) {
      _json["adminEnabled"] = adminEnabled;
    }
    if (circuitInfos != null) {
      _json["circuitInfos"] =
          circuitInfos.map((value) => (value).toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (customerName != null) {
      _json["customerName"] = customerName;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (expectedOutages != null) {
      _json["expectedOutages"] =
          expectedOutages.map((value) => (value).toJson()).toList();
    }
    if (googleIpAddress != null) {
      _json["googleIpAddress"] = googleIpAddress;
    }
    if (googleReferenceId != null) {
      _json["googleReferenceId"] = googleReferenceId;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (interconnectAttachments != null) {
      _json["interconnectAttachments"] = interconnectAttachments;
    }
    if (interconnectType != null) {
      _json["interconnectType"] = interconnectType;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (linkType != null) {
      _json["linkType"] = linkType;
    }
    if (location != null) {
      _json["location"] = location;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (nocContactEmail != null) {
      _json["nocContactEmail"] = nocContactEmail;
    }
    if (operationalStatus != null) {
      _json["operationalStatus"] = operationalStatus;
    }
    if (peerIpAddress != null) {
      _json["peerIpAddress"] = peerIpAddress;
    }
    if (provisionedLinkCount != null) {
      _json["provisionedLinkCount"] = provisionedLinkCount;
    }
    if (requestedLinkCount != null) {
      _json["requestedLinkCount"] = requestedLinkCount;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (state != null) {
      _json["state"] = state;
    }
    return _json;
  }
}

/// Represents an Interconnect Attachment (VLAN) resource.
///
/// You can use Interconnect attachments (VLANS) to connect your Virtual Private
/// Cloud networks to your on-premises networks through an Interconnect. For
/// more information, read  Creating VLAN Attachments. (== resource_for
/// {$api_version}.interconnectAttachments ==)
class InterconnectAttachment {
  /// Determines whether this Attachment will carry packets. Not present for
  /// PARTNER_PROVIDER.
  core.bool adminEnabled;

  /// Provisioned bandwidth capacity for the interconnect attachment. For
  /// attachments of type DEDICATED, the user can set the bandwidth. For
  /// attachments of type PARTNER, the Google Partner that is operating the
  /// interconnect must set the bandwidth. Output only for PARTNER type, mutable
  /// for PARTNER_PROVIDER and DEDICATED, and can take one of the following
  /// values:
  /// - BPS_50M: 50 Mbit/s
  /// - BPS_100M: 100 Mbit/s
  /// - BPS_200M: 200 Mbit/s
  /// - BPS_300M: 300 Mbit/s
  /// - BPS_400M: 400 Mbit/s
  /// - BPS_500M: 500 Mbit/s
  /// - BPS_1G: 1 Gbit/s
  /// - BPS_2G: 2 Gbit/s
  /// - BPS_5G: 5 Gbit/s
  /// - BPS_10G: 10 Gbit/s
  /// - BPS_20G: 20 Gbit/s
  /// - BPS_50G: 50 Gbit/s
  /// Possible string values are:
  /// - "BPS_100M"
  /// - "BPS_10G"
  /// - "BPS_1G"
  /// - "BPS_200M"
  /// - "BPS_20G"
  /// - "BPS_2G"
  /// - "BPS_300M"
  /// - "BPS_400M"
  /// - "BPS_500M"
  /// - "BPS_50G"
  /// - "BPS_50M"
  /// - "BPS_5G"
  core.String bandwidth;

  /// Up to 16 candidate prefixes that can be used to restrict the allocation of
  /// cloudRouterIpAddress and customerRouterIpAddress for this attachment. All
  /// prefixes must be within link-local address space (169.254.0.0/16) and must
  /// be /29 or shorter (/28, /27, etc). Google will attempt to select an unused
  /// /29 from the supplied candidate prefix(es). The request will fail if all
  /// possible /29s are in use on Google's edge. If not supplied, Google will
  /// randomly select an unused /29 from all of link-local space.
  core.List<core.String> candidateSubnets;

  /// [Output Only] IPv4 address + prefix length to be configured on Cloud
  /// Router Interface for this interconnect attachment.
  core.String cloudRouterIpAddress;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] IPv4 address + prefix length to be configured on the
  /// customer router subinterface for this interconnect attachment.
  core.String customerRouterIpAddress;

  /// An optional description of this resource.
  core.String description;

  /// Desired availability domain for the attachment. Only available for type
  /// PARTNER, at creation time, and can take one of the following values:
  /// - AVAILABILITY_DOMAIN_ANY
  /// - AVAILABILITY_DOMAIN_1
  /// - AVAILABILITY_DOMAIN_2 For improved reliability, customers should
  /// configure a pair of attachments, one per availability domain. The selected
  /// availability domain will be provided to the Partner via the pairing key,
  /// so that the provisioned circuit will lie in the specified domain. If not
  /// specified, the value will default to AVAILABILITY_DOMAIN_ANY.
  /// Possible string values are:
  /// - "AVAILABILITY_DOMAIN_1"
  /// - "AVAILABILITY_DOMAIN_2"
  /// - "AVAILABILITY_DOMAIN_ANY"
  core.String edgeAvailabilityDomain;

  /// [Output Only] Google reference ID, to be used when raising support tickets
  /// with Google or otherwise to debug backend connectivity issues.
  /// [Deprecated] This field is not used.
  core.String googleReferenceId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// URL of the underlying Interconnect object that this attachment's traffic
  /// will traverse through.
  core.String interconnect;

  /// [Output Only] Type of the resource. Always compute#interconnectAttachment
  /// for interconnect attachments.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] The current status of whether or not this interconnect
  /// attachment is functional, which can take one of the following values:
  /// - OS_ACTIVE: The attachment has been turned up and is ready to use.
  /// - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup
  /// is not complete.
  /// Possible string values are:
  /// - "OS_ACTIVE"
  /// - "OS_UNPROVISIONED"
  core.String operationalStatus;

  /// [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not
  /// present for DEDICATED]. The opaque identifier of an PARTNER attachment
  /// used to initiate provisioning with a selected partner. Of the form
  /// "XXXXX/region/domain"
  core.String pairingKey;

  /// Optional BGP ASN for the router supplied by a Layer 3 Partner if they
  /// configured BGP on behalf of the customer. Output only for PARTNER type,
  /// input only for PARTNER_PROVIDER, not available for DEDICATED.
  core.String partnerAsn;

  /// Informational metadata about Partner attachments from Partners to display
  /// to customers. Output only for for PARTNER type, mutable for
  /// PARTNER_PROVIDER, not available for DEDICATED.
  InterconnectAttachmentPartnerMetadata partnerMetadata;

  /// [Output Only] Information specific to an InterconnectAttachment. This
  /// property is populated if the interconnect that this is attached to is of
  /// type DEDICATED.
  InterconnectAttachmentPrivateInfo privateInterconnectInfo;

  /// [Output Only] URL of the region where the regional interconnect attachment
  /// resides. You must specify this field as part of the HTTP request URL. It
  /// is not settable as a field in the request body.
  core.String region;

  /// URL of the Cloud Router to be used for dynamic routing. This router must
  /// be in the same region as this InterconnectAttachment. The
  /// InterconnectAttachment will automatically connect the Interconnect to the
  /// network & region within which the Cloud Router is configured.
  core.String router;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The current state of this attachment's functionality. Enum
  /// values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER,
  /// and PARTNER_PROVIDER interconnect attachments, while enum values
  /// PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used
  /// for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state
  /// can take one of the following values:
  /// - ACTIVE: The attachment has been turned up and is ready to use.
  /// - UNPROVISIONED: The attachment is not ready to use yet, because turnup is
  /// not complete.
  /// - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet
  /// been configured on the Partner side.
  /// - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of
  /// provisioning after a PARTNER_PROVIDER attachment was created that
  /// references it.
  /// - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is
  /// waiting for a customer to activate it.
  /// - DEFUNCT: The attachment was deleted externally and is no longer
  /// functional. This could be because the associated Interconnect was removed,
  /// or because the other side of a Partner attachment was deleted.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DEFUNCT"
  /// - "PARTNER_REQUEST_RECEIVED"
  /// - "PENDING_CUSTOMER"
  /// - "PENDING_PARTNER"
  /// - "STATE_UNSPECIFIED"
  /// - "UNPROVISIONED"
  core.String state;

  /// The type of interconnect attachment this is, which can take one of the
  /// following values:
  /// - DEDICATED: an attachment to a Dedicated Interconnect.
  /// - PARTNER: an attachment to a Partner Interconnect, created by the
  /// customer.
  /// - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by
  /// the partner.
  /// Possible string values are:
  /// - "DEDICATED"
  /// - "PARTNER"
  /// - "PARTNER_PROVIDER"
  core.String type;

  /// The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only
  /// specified at creation time.
  core.int vlanTag8021q;

  InterconnectAttachment();

  InterconnectAttachment.fromJson(core.Map _json) {
    if (_json.containsKey("adminEnabled")) {
      adminEnabled = _json["adminEnabled"];
    }
    if (_json.containsKey("bandwidth")) {
      bandwidth = _json["bandwidth"];
    }
    if (_json.containsKey("candidateSubnets")) {
      candidateSubnets =
          (_json["candidateSubnets"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("cloudRouterIpAddress")) {
      cloudRouterIpAddress = _json["cloudRouterIpAddress"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("customerRouterIpAddress")) {
      customerRouterIpAddress = _json["customerRouterIpAddress"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("edgeAvailabilityDomain")) {
      edgeAvailabilityDomain = _json["edgeAvailabilityDomain"];
    }
    if (_json.containsKey("googleReferenceId")) {
      googleReferenceId = _json["googleReferenceId"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("interconnect")) {
      interconnect = _json["interconnect"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("operationalStatus")) {
      operationalStatus = _json["operationalStatus"];
    }
    if (_json.containsKey("pairingKey")) {
      pairingKey = _json["pairingKey"];
    }
    if (_json.containsKey("partnerAsn")) {
      partnerAsn = _json["partnerAsn"];
    }
    if (_json.containsKey("partnerMetadata")) {
      partnerMetadata = new InterconnectAttachmentPartnerMetadata.fromJson(
          _json["partnerMetadata"]);
    }
    if (_json.containsKey("privateInterconnectInfo")) {
      privateInterconnectInfo = new InterconnectAttachmentPrivateInfo.fromJson(
          _json["privateInterconnectInfo"]);
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("router")) {
      router = _json["router"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
    if (_json.containsKey("vlanTag8021q")) {
      vlanTag8021q = _json["vlanTag8021q"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (adminEnabled != null) {
      _json["adminEnabled"] = adminEnabled;
    }
    if (bandwidth != null) {
      _json["bandwidth"] = bandwidth;
    }
    if (candidateSubnets != null) {
      _json["candidateSubnets"] = candidateSubnets;
    }
    if (cloudRouterIpAddress != null) {
      _json["cloudRouterIpAddress"] = cloudRouterIpAddress;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (customerRouterIpAddress != null) {
      _json["customerRouterIpAddress"] = customerRouterIpAddress;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (edgeAvailabilityDomain != null) {
      _json["edgeAvailabilityDomain"] = edgeAvailabilityDomain;
    }
    if (googleReferenceId != null) {
      _json["googleReferenceId"] = googleReferenceId;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (interconnect != null) {
      _json["interconnect"] = interconnect;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (operationalStatus != null) {
      _json["operationalStatus"] = operationalStatus;
    }
    if (pairingKey != null) {
      _json["pairingKey"] = pairingKey;
    }
    if (partnerAsn != null) {
      _json["partnerAsn"] = partnerAsn;
    }
    if (partnerMetadata != null) {
      _json["partnerMetadata"] = (partnerMetadata).toJson();
    }
    if (privateInterconnectInfo != null) {
      _json["privateInterconnectInfo"] = (privateInterconnectInfo).toJson();
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (router != null) {
      _json["router"] = router;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (state != null) {
      _json["state"] = state;
    }
    if (type != null) {
      _json["type"] = type;
    }
    if (vlanTag8021q != null) {
      _json["vlanTag8021q"] = vlanTag8021q;
    }
    return _json;
  }
}

class InterconnectAttachmentAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentAggregatedListWarningData();

  InterconnectAttachmentAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectAttachmentAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentAggregatedListWarning();

  InterconnectAttachmentAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InterconnectAttachmentAggregatedListWarningData>((value) =>
              new InterconnectAttachmentAggregatedListWarningData.fromJson(
                  value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InterconnectAttachmentAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectAttachmentsScopedList resources.
  core.Map<core.String, InterconnectAttachmentsScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#interconnectAttachmentAggregatedList for aggregated lists of
  /// interconnect attachments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectAttachmentAggregatedListWarning warning;

  InterconnectAttachmentAggregatedList();

  InterconnectAttachmentAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, InterconnectAttachmentsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) =>
              new InterconnectAttachmentsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InterconnectAttachmentAggregatedListWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<InterconnectAttachmentsScopedList,
              core.Map<core.String, core.Object>>(
          items, (InterconnectAttachmentsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class InterconnectAttachmentListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentListWarningData();

  InterconnectAttachmentListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectAttachmentListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentListWarning();

  InterconnectAttachmentListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InterconnectAttachmentListWarningData>((value) =>
              new InterconnectAttachmentListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnect
/// attachments.
class InterconnectAttachmentList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectAttachment resources.
  core.List<InterconnectAttachment> items;

  /// [Output Only] Type of resource. Always compute#interconnectAttachmentList
  /// for lists of interconnect attachments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectAttachmentListWarning warning;

  InterconnectAttachmentList();

  InterconnectAttachmentList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InterconnectAttachment>(
              (value) => new InterconnectAttachment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new InterconnectAttachmentListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Informational metadata about Partner attachments from Partners to display to
/// customers. These fields are propagated from PARTNER_PROVIDER attachments to
/// their corresponding PARTNER attachments.
class InterconnectAttachmentPartnerMetadata {
  /// Plain text name of the Interconnect this attachment is connected to, as
  /// displayed in the Partner's portal. For instance "Chicago 1". This value
  /// may be validated to match approved Partner values.
  core.String interconnectName;

  /// Plain text name of the Partner providing this attachment. This value may
  /// be validated to match approved Partner values.
  core.String partnerName;

  /// URL of the Partner's portal for this Attachment. Partners may customise
  /// this to be a deep link to the specific resource on the Partner portal.
  /// This value may be validated to match approved Partner values.
  core.String portalUrl;

  InterconnectAttachmentPartnerMetadata();

  InterconnectAttachmentPartnerMetadata.fromJson(core.Map _json) {
    if (_json.containsKey("interconnectName")) {
      interconnectName = _json["interconnectName"];
    }
    if (_json.containsKey("partnerName")) {
      partnerName = _json["partnerName"];
    }
    if (_json.containsKey("portalUrl")) {
      portalUrl = _json["portalUrl"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (interconnectName != null) {
      _json["interconnectName"] = interconnectName;
    }
    if (partnerName != null) {
      _json["partnerName"] = partnerName;
    }
    if (portalUrl != null) {
      _json["portalUrl"] = portalUrl;
    }
    return _json;
  }
}

/// Information for an interconnect attachment when this belongs to an
/// interconnect of type DEDICATED.
class InterconnectAttachmentPrivateInfo {
  /// [Output Only] 802.1q encapsulation tag to be used for traffic between
  /// Google and the customer, going to and from this network and region.
  core.int tag8021q;

  InterconnectAttachmentPrivateInfo();

  InterconnectAttachmentPrivateInfo.fromJson(core.Map _json) {
    if (_json.containsKey("tag8021q")) {
      tag8021q = _json["tag8021q"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (tag8021q != null) {
      _json["tag8021q"] = tag8021q;
    }
    return _json;
  }
}

class InterconnectAttachmentsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentsScopedListWarningData();

  InterconnectAttachmentsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class InterconnectAttachmentsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentsScopedListWarning();

  InterconnectAttachmentsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InterconnectAttachmentsScopedListWarningData>((value) =>
              new InterconnectAttachmentsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class InterconnectAttachmentsScopedList {
  /// A list of interconnect attachments contained in this scope.
  core.List<InterconnectAttachment> interconnectAttachments;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  InterconnectAttachmentsScopedListWarning warning;

  InterconnectAttachmentsScopedList();

  InterconnectAttachmentsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("interconnectAttachments")) {
      interconnectAttachments = (_json["interconnectAttachments"] as core.List)
          .map<InterconnectAttachment>(
              (value) => new InterconnectAttachment.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new InterconnectAttachmentsScopedListWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (interconnectAttachments != null) {
      _json["interconnectAttachments"] =
          interconnectAttachments.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Describes a single physical circuit between the Customer and Google.
/// CircuitInfo objects are created by Google, so all fields are output only.
/// Next id: 4
class InterconnectCircuitInfo {
  /// Customer-side demarc ID for this circuit.
  core.String customerDemarcId;

  /// Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
  core.String googleCircuitId;

  /// Google-side demarc ID for this circuit. Assigned at circuit turn-up and
  /// provided by Google to the customer in the LOA.
  core.String googleDemarcId;

  InterconnectCircuitInfo();

  InterconnectCircuitInfo.fromJson(core.Map _json) {
    if (_json.containsKey("customerDemarcId")) {
      customerDemarcId = _json["customerDemarcId"];
    }
    if (_json.containsKey("googleCircuitId")) {
      googleCircuitId = _json["googleCircuitId"];
    }
    if (_json.containsKey("googleDemarcId")) {
      googleDemarcId = _json["googleDemarcId"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (customerDemarcId != null) {
      _json["customerDemarcId"] = customerDemarcId;
    }
    if (googleCircuitId != null) {
      _json["googleCircuitId"] = googleCircuitId;
    }
    if (googleDemarcId != null) {
      _json["googleDemarcId"] = googleDemarcId;
    }
    return _json;
  }
}

/// Diagnostics information about interconnect, contains detailed and current
/// technical information about Google's side of the connection.
class InterconnectDiagnostics {
  /// A list of InterconnectDiagnostics.ARPEntry objects, describing individual
  /// neighbors currently seen by the Google router in the ARP cache for the
  /// Interconnect. This will be empty when the Interconnect is not bundled.
  core.List<InterconnectDiagnosticsARPEntry> arpCaches;

  /// A list of InterconnectDiagnostics.LinkStatus objects, describing the
  /// status for each link on the Interconnect.
  core.List<InterconnectDiagnosticsLinkStatus> links;

  /// The MAC address of the Interconnect's bundle interface.
  core.String macAddress;

  InterconnectDiagnostics();

  InterconnectDiagnostics.fromJson(core.Map _json) {
    if (_json.containsKey("arpCaches")) {
      arpCaches = (_json["arpCaches"] as core.List)
          .map<InterconnectDiagnosticsARPEntry>(
              (value) => new InterconnectDiagnosticsARPEntry.fromJson(value))
          .toList();
    }
    if (_json.containsKey("links")) {
      links = (_json["links"] as core.List)
          .map<InterconnectDiagnosticsLinkStatus>(
              (value) => new InterconnectDiagnosticsLinkStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("macAddress")) {
      macAddress = _json["macAddress"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (arpCaches != null) {
      _json["arpCaches"] = arpCaches.map((value) => (value).toJson()).toList();
    }
    if (links != null) {
      _json["links"] = links.map((value) => (value).toJson()).toList();
    }
    if (macAddress != null) {
      _json["macAddress"] = macAddress;
    }
    return _json;
  }
}

/// Describing the ARP neighbor entries seen on this link
class InterconnectDiagnosticsARPEntry {
  /// The IP address of this ARP neighbor.
  core.String ipAddress;

  /// The MAC address of this ARP neighbor.
  core.String macAddress;

  InterconnectDiagnosticsARPEntry();

  InterconnectDiagnosticsARPEntry.fromJson(core.Map _json) {
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
    if (_json.containsKey("macAddress")) {
      macAddress = _json["macAddress"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    if (macAddress != null) {
      _json["macAddress"] = macAddress;
    }
    return _json;
  }
}

class InterconnectDiagnosticsLinkLACPStatus {
  /// System ID of the port on Google's side of the LACP exchange.
  core.String googleSystemId;

  /// System ID of the port on the neighbor's side of the LACP exchange.
  core.String neighborSystemId;

  /// The state of a LACP link, which can take one of the following values:
  /// - ACTIVE: The link is configured and active within the bundle.
  /// - DETACHED: The link is not configured within the bundle. This means that
  /// the rest of the object should be empty.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DETACHED"
  core.String state;

  InterconnectDiagnosticsLinkLACPStatus();

  InterconnectDiagnosticsLinkLACPStatus.fromJson(core.Map _json) {
    if (_json.containsKey("googleSystemId")) {
      googleSystemId = _json["googleSystemId"];
    }
    if (_json.containsKey("neighborSystemId")) {
      neighborSystemId = _json["neighborSystemId"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (googleSystemId != null) {
      _json["googleSystemId"] = googleSystemId;
    }
    if (neighborSystemId != null) {
      _json["neighborSystemId"] = neighborSystemId;
    }
    if (state != null) {
      _json["state"] = state;
    }
    return _json;
  }
}

class InterconnectDiagnosticsLinkOpticalPower {
  /// The status of the current value when compared to the warning and alarm
  /// levels for the receiving or transmitting transceiver. Possible states
  /// include:
  /// - OK: The value has not crossed a warning threshold.
  /// - LOW_WARNING: The value has crossed below the low warning threshold.
  /// - HIGH_WARNING: The value has crossed above the high warning threshold.
  /// - LOW_ALARM: The value has crossed below the low alarm threshold.
  /// - HIGH_ALARM: The value has crossed above the high alarm threshold.
  /// Possible string values are:
  /// - "HIGH_ALARM"
  /// - "HIGH_WARNING"
  /// - "LOW_ALARM"
  /// - "LOW_WARNING"
  /// - "OK"
  core.String state;

  /// Value of the current receiving or transmitting optical power, read in dBm.
  /// Take a known good optical value, give it a 10% margin and trigger warnings
  /// relative to that value. In general, a -7dBm warning and a -11dBm alarm are
  /// good optical value estimates for most links.
  core.double value;

  InterconnectDiagnosticsLinkOpticalPower();

  InterconnectDiagnosticsLinkOpticalPower.fromJson(core.Map _json) {
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (state != null) {
      _json["state"] = state;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

class InterconnectDiagnosticsLinkStatus {
  /// A list of InterconnectDiagnostics.ARPEntry objects, describing the ARP
  /// neighbor entries seen on this link. This will be empty if the link is
  /// bundled
  core.List<InterconnectDiagnosticsARPEntry> arpCaches;

  /// The unique ID for this link assigned during turn up by Google.
  core.String circuitId;

  /// The Demarc address assigned by Google and provided in the LoA.
  core.String googleDemarc;
  InterconnectDiagnosticsLinkLACPStatus lacpStatus;

  /// An InterconnectDiagnostics.LinkOpticalPower object, describing the current
  /// value and status of the received light level.
  InterconnectDiagnosticsLinkOpticalPower receivingOpticalPower;

  /// An InterconnectDiagnostics.LinkOpticalPower object, describing the current
  /// value and status of the transmitted light level.
  InterconnectDiagnosticsLinkOpticalPower transmittingOpticalPower;

  InterconnectDiagnosticsLinkStatus();

  InterconnectDiagnosticsLinkStatus.fromJson(core.Map _json) {
    if (_json.containsKey("arpCaches")) {
      arpCaches = (_json["arpCaches"] as core.List)
          .map<InterconnectDiagnosticsARPEntry>(
              (value) => new InterconnectDiagnosticsARPEntry.fromJson(value))
          .toList();
    }
    if (_json.containsKey("circuitId")) {
      circuitId = _json["circuitId"];
    }
    if (_json.containsKey("googleDemarc")) {
      googleDemarc = _json["googleDemarc"];
    }
    if (_json.containsKey("lacpStatus")) {
      lacpStatus = new InterconnectDiagnosticsLinkLACPStatus.fromJson(
          _json["lacpStatus"]);
    }
    if (_json.containsKey("receivingOpticalPower")) {
      receivingOpticalPower =
          new InterconnectDiagnosticsLinkOpticalPower.fromJson(
              _json["receivingOpticalPower"]);
    }
    if (_json.containsKey("transmittingOpticalPower")) {
      transmittingOpticalPower =
          new InterconnectDiagnosticsLinkOpticalPower.fromJson(
              _json["transmittingOpticalPower"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (arpCaches != null) {
      _json["arpCaches"] = arpCaches.map((value) => (value).toJson()).toList();
    }
    if (circuitId != null) {
      _json["circuitId"] = circuitId;
    }
    if (googleDemarc != null) {
      _json["googleDemarc"] = googleDemarc;
    }
    if (lacpStatus != null) {
      _json["lacpStatus"] = (lacpStatus).toJson();
    }
    if (receivingOpticalPower != null) {
      _json["receivingOpticalPower"] = (receivingOpticalPower).toJson();
    }
    if (transmittingOpticalPower != null) {
      _json["transmittingOpticalPower"] = (transmittingOpticalPower).toJson();
    }
    return _json;
  }
}

class InterconnectListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectListWarningData();

  InterconnectListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectListWarning();

  InterconnectListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InterconnectListWarningData>(
              (value) => new InterconnectListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnects.
class InterconnectList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Interconnect resources.
  core.List<Interconnect> items;

  /// [Output Only] Type of resource. Always compute#interconnectList for lists
  /// of interconnects.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectListWarning warning;

  InterconnectList();

  InterconnectList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Interconnect>((value) => new Interconnect.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InterconnectListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents an Interconnect Attachment (VLAN) Location resource.
///
/// You can use this resource to find location details about an Interconnect
/// attachment (VLAN). For more information about interconnect attachments, read
/// Creating VLAN Attachments.
class InterconnectLocation {
  /// [Output Only] The postal address of the Point of Presence, each line in
  /// the address is separated by a newline character.
  core.String address;

  /// [Output Only] Availability zone for this InterconnectLocation. Within a
  /// metropolitan area (metro), maintenance will not be simultaneously
  /// scheduled in more than one availability zone. Example: "zone1" or "zone2".
  core.String availabilityZone;

  /// [Output Only] Metropolitan area designator that indicates which city an
  /// interconnect is located. For example: "Chicago, IL", "Amsterdam,
  /// Netherlands".
  core.String city;

  /// [Output Only] Continent for this location, which can take one of the
  /// following values:
  /// - AFRICA
  /// - ASIA_PAC
  /// - EUROPE
  /// - NORTH_AMERICA
  /// - SOUTH_AMERICA
  /// Possible string values are:
  /// - "AFRICA"
  /// - "ASIA_PAC"
  /// - "C_AFRICA"
  /// - "C_ASIA_PAC"
  /// - "C_EUROPE"
  /// - "C_NORTH_AMERICA"
  /// - "C_SOUTH_AMERICA"
  /// - "EUROPE"
  /// - "NORTH_AMERICA"
  /// - "SOUTH_AMERICA"
  core.String continent;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] An optional description of the resource.
  core.String description;

  /// [Output Only] The name of the provider for this facility (e.g., EQUINIX).
  core.String facilityProvider;

  /// [Output Only] A provider-assigned Identifier for this facility (e.g.,
  /// Ashburn-DC1).
  core.String facilityProviderFacilityId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#interconnectLocation
  /// for interconnect locations.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] The peeringdb identifier for this facility (corresponding
  /// with a netfac type in peeringdb).
  core.String peeringdbFacilityId;

  /// [Output Only] A list of InterconnectLocation.RegionInfo objects, that
  /// describe parameters pertaining to the relation between this
  /// InterconnectLocation and various Google Cloud regions.
  core.List<InterconnectLocationRegionInfo> regionInfos;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of this InterconnectLocation, which can take one
  /// of the following values:
  /// - CLOSED: The InterconnectLocation is closed and is unavailable for
  /// provisioning new Interconnects.
  /// - AVAILABLE: The InterconnectLocation is available for provisioning new
  /// Interconnects.
  /// Possible string values are:
  /// - "AVAILABLE"
  /// - "CLOSED"
  core.String status;

  InterconnectLocation();

  InterconnectLocation.fromJson(core.Map _json) {
    if (_json.containsKey("address")) {
      address = _json["address"];
    }
    if (_json.containsKey("availabilityZone")) {
      availabilityZone = _json["availabilityZone"];
    }
    if (_json.containsKey("city")) {
      city = _json["city"];
    }
    if (_json.containsKey("continent")) {
      continent = _json["continent"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("facilityProvider")) {
      facilityProvider = _json["facilityProvider"];
    }
    if (_json.containsKey("facilityProviderFacilityId")) {
      facilityProviderFacilityId = _json["facilityProviderFacilityId"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peeringdbFacilityId")) {
      peeringdbFacilityId = _json["peeringdbFacilityId"];
    }
    if (_json.containsKey("regionInfos")) {
      regionInfos = (_json["regionInfos"] as core.List)
          .map<InterconnectLocationRegionInfo>(
              (value) => new InterconnectLocationRegionInfo.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (address != null) {
      _json["address"] = address;
    }
    if (availabilityZone != null) {
      _json["availabilityZone"] = availabilityZone;
    }
    if (city != null) {
      _json["city"] = city;
    }
    if (continent != null) {
      _json["continent"] = continent;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (facilityProvider != null) {
      _json["facilityProvider"] = facilityProvider;
    }
    if (facilityProviderFacilityId != null) {
      _json["facilityProviderFacilityId"] = facilityProviderFacilityId;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peeringdbFacilityId != null) {
      _json["peeringdbFacilityId"] = peeringdbFacilityId;
    }
    if (regionInfos != null) {
      _json["regionInfos"] =
          regionInfos.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

class InterconnectLocationListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectLocationListWarningData();

  InterconnectLocationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectLocationListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectLocationListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectLocationListWarning();

  InterconnectLocationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<InterconnectLocationListWarningData>((value) =>
              new InterconnectLocationListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnect locations.
class InterconnectLocationList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectLocation resources.
  core.List<InterconnectLocation> items;

  /// [Output Only] Type of resource. Always compute#interconnectLocationList
  /// for lists of interconnect locations.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectLocationListWarning warning;

  InterconnectLocationList();

  InterconnectLocationList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InterconnectLocation>(
              (value) => new InterconnectLocation.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new InterconnectLocationListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Information about any potential InterconnectAttachments between an
/// Interconnect at a specific InterconnectLocation, and a specific Cloud
/// Region.
class InterconnectLocationRegionInfo {
  /// Expected round-trip time in milliseconds, from this InterconnectLocation
  /// to a VM in this region.
  core.String expectedRttMs;

  /// Identifies the network presence of this location.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "LOCAL_REGION"
  /// - "LP_GLOBAL"
  /// - "LP_LOCAL_REGION"
  core.String locationPresence;

  /// URL for the region of this location.
  core.String region;

  InterconnectLocationRegionInfo();

  InterconnectLocationRegionInfo.fromJson(core.Map _json) {
    if (_json.containsKey("expectedRttMs")) {
      expectedRttMs = _json["expectedRttMs"];
    }
    if (_json.containsKey("locationPresence")) {
      locationPresence = _json["locationPresence"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (expectedRttMs != null) {
      _json["expectedRttMs"] = expectedRttMs;
    }
    if (locationPresence != null) {
      _json["locationPresence"] = locationPresence;
    }
    if (region != null) {
      _json["region"] = region;
    }
    return _json;
  }
}

/// Description of a planned outage on this Interconnect. Next id: 9
class InterconnectOutageNotification {
  /// If issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs
  /// that will be affected.
  core.List<core.String> affectedCircuits;

  /// A description about the purpose of the outage.
  core.String description;

  /// Scheduled end time for the outage (milliseconds since Unix epoch).
  core.String endTime;

  /// Form this outage is expected to take, which can take one of the following
  /// values:
  /// - OUTAGE: The Interconnect may be completely out of service for some or
  /// all of the specified window.
  /// - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole
  /// should remain up, but with reduced bandwidth. Note that the versions of
  /// this enum prefixed with "IT_" have been deprecated in favor of the
  /// unprefixed values.
  /// Possible string values are:
  /// - "IT_OUTAGE"
  /// - "IT_PARTIAL_OUTAGE"
  /// - "OUTAGE"
  /// - "PARTIAL_OUTAGE"
  core.String issueType;

  /// Unique identifier for this outage notification.
  core.String name;

  /// The party that generated this notification, which can take the following
  /// value:
  /// - GOOGLE: this notification as generated by Google. Note that the value of
  /// NSRC_GOOGLE has been deprecated in favor of GOOGLE.
  /// Possible string values are:
  /// - "GOOGLE"
  /// - "NSRC_GOOGLE"
  core.String source;

  /// Scheduled start time for the outage (milliseconds since Unix epoch).
  core.String startTime;

  /// State of this notification, which can take one of the following values:
  /// - ACTIVE: This outage notification is active. The event could be in the
  /// past, present, or future. See start_time and end_time for scheduling.
  /// - CANCELLED: The outage associated with this notification was cancelled
  /// before the outage was due to start. Note that the versions of this enum
  /// prefixed with "NS_" have been deprecated in favor of the unprefixed
  /// values.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CANCELLED"
  /// - "COMPLETED"
  /// - "NS_ACTIVE"
  /// - "NS_CANCELED"
  core.String state;

  InterconnectOutageNotification();

  InterconnectOutageNotification.fromJson(core.Map _json) {
    if (_json.containsKey("affectedCircuits")) {
      affectedCircuits =
          (_json["affectedCircuits"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("endTime")) {
      endTime = _json["endTime"];
    }
    if (_json.containsKey("issueType")) {
      issueType = _json["issueType"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("source")) {
      source = _json["source"];
    }
    if (_json.containsKey("startTime")) {
      startTime = _json["startTime"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (affectedCircuits != null) {
      _json["affectedCircuits"] = affectedCircuits;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (endTime != null) {
      _json["endTime"] = endTime;
    }
    if (issueType != null) {
      _json["issueType"] = issueType;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (source != null) {
      _json["source"] = source;
    }
    if (startTime != null) {
      _json["startTime"] = startTime;
    }
    if (state != null) {
      _json["state"] = state;
    }
    return _json;
  }
}

/// Response for the InterconnectsGetDiagnosticsRequest.
class InterconnectsGetDiagnosticsResponse {
  InterconnectDiagnostics result;

  InterconnectsGetDiagnosticsResponse();

  InterconnectsGetDiagnosticsResponse.fromJson(core.Map _json) {
    if (_json.containsKey("result")) {
      result = new InterconnectDiagnostics.fromJson(_json["result"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (result != null) {
      _json["result"] = (result).toJson();
    }
    return _json;
  }
}

/// Represents a License resource.
///
/// A License represents billing and aggregate usage data for public and
/// marketplace images.  Caution This resource is intended for use only by
/// third-party partners who are creating Cloud Marketplace images. (==
/// resource_for {$api_version}.licenses ==)
class License {
  /// [Output Only] Deprecated. This field no longer reflects whether a license
  /// charges a usage fee.
  core.bool chargesUseFee;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#license for licenses.
  core.String kind;

  /// [Output Only] The unique code used to attach this license to images,
  /// snapshots, and disks.
  core.String licenseCode;

  /// Name of the resource. The name must be 1-63 characters long and comply
  /// with RFC1035.
  core.String name;
  LicenseResourceRequirements resourceRequirements;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// If false, licenses will not be copied from the source resource when
  /// creating an image from a disk, disk from snapshot, or snapshot from disk.
  core.bool transferable;

  License();

  License.fromJson(core.Map _json) {
    if (_json.containsKey("chargesUseFee")) {
      chargesUseFee = _json["chargesUseFee"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("licenseCode")) {
      licenseCode = _json["licenseCode"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("resourceRequirements")) {
      resourceRequirements = new LicenseResourceRequirements.fromJson(
          _json["resourceRequirements"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("transferable")) {
      transferable = _json["transferable"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (chargesUseFee != null) {
      _json["chargesUseFee"] = chargesUseFee;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (licenseCode != null) {
      _json["licenseCode"] = licenseCode;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (resourceRequirements != null) {
      _json["resourceRequirements"] = (resourceRequirements).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (transferable != null) {
      _json["transferable"] = transferable;
    }
    return _json;
  }
}

/// Represents a License Code resource.
///
/// A License Code is a unique identifier used to represent a license resource.
/// Caution This resource is intended for use only by third-party partners who
/// are creating Cloud Marketplace images. (== resource_for
/// {$api_version}.licenseCodes ==)
class LicenseCode {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] Description of this License Code.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#licenseCode for licenses.
  core.String kind;

  /// [Output Only] URL and description aliases of Licenses with the same
  /// License Code.
  core.List<LicenseCodeLicenseAlias> licenseAlias;

  /// [Output Only] Name of the resource. The name is 1-20 characters long and
  /// must be a valid 64 bit integer.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Current state of this License Code.
  /// Possible string values are:
  /// - "DISABLED"
  /// - "ENABLED"
  /// - "RESTRICTED"
  /// - "STATE_UNSPECIFIED"
  /// - "TERMINATED"
  core.String state;

  /// [Output Only] If true, the license will remain attached when creating
  /// images or snapshots from disks. Otherwise, the license is not transferred.
  core.bool transferable;

  LicenseCode();

  LicenseCode.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("licenseAlias")) {
      licenseAlias = (_json["licenseAlias"] as core.List)
          .map<LicenseCodeLicenseAlias>(
              (value) => new LicenseCodeLicenseAlias.fromJson(value))
          .toList();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
    if (_json.containsKey("transferable")) {
      transferable = _json["transferable"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (licenseAlias != null) {
      _json["licenseAlias"] =
          licenseAlias.map((value) => (value).toJson()).toList();
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (state != null) {
      _json["state"] = state;
    }
    if (transferable != null) {
      _json["transferable"] = transferable;
    }
    return _json;
  }
}

class LicenseCodeLicenseAlias {
  /// [Output Only] Description of this License Code.
  core.String description;

  /// [Output Only] URL of license corresponding to this License Code.
  core.String selfLink;

  LicenseCodeLicenseAlias();

  LicenseCodeLicenseAlias.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class LicenseResourceRequirements {
  /// Minimum number of guest cpus required to use the Instance. Enforced at
  /// Instance creation and Instance start.
  core.int minGuestCpuCount;

  /// Minimum memory required to use the Instance. Enforced at Instance creation
  /// and Instance start.
  core.int minMemoryMb;

  LicenseResourceRequirements();

  LicenseResourceRequirements.fromJson(core.Map _json) {
    if (_json.containsKey("minGuestCpuCount")) {
      minGuestCpuCount = _json["minGuestCpuCount"];
    }
    if (_json.containsKey("minMemoryMb")) {
      minMemoryMb = _json["minMemoryMb"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (minGuestCpuCount != null) {
      _json["minGuestCpuCount"] = minGuestCpuCount;
    }
    if (minMemoryMb != null) {
      _json["minMemoryMb"] = minMemoryMb;
    }
    return _json;
  }
}

class LicensesListResponseWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  LicensesListResponseWarningData();

  LicensesListResponseWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class LicensesListResponseWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<LicensesListResponseWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  LicensesListResponseWarning();

  LicensesListResponseWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<LicensesListResponseWarningData>(
              (value) => new LicensesListResponseWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class LicensesListResponse {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of License resources.
  core.List<License> items;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  LicensesListResponseWarning warning;

  LicensesListResponse();

  LicensesListResponse.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<License>((value) => new License.fromJson(value))
          .toList();
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new LicensesListResponseWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Specifies what kind of log the caller must write
class LogConfig {
  /// Cloud audit options.
  LogConfigCloudAuditOptions cloudAudit;

  /// Counter options.
  LogConfigCounterOptions counter;

  /// Data access options.
  LogConfigDataAccessOptions dataAccess;

  LogConfig();

  LogConfig.fromJson(core.Map _json) {
    if (_json.containsKey("cloudAudit")) {
      cloudAudit = new LogConfigCloudAuditOptions.fromJson(_json["cloudAudit"]);
    }
    if (_json.containsKey("counter")) {
      counter = new LogConfigCounterOptions.fromJson(_json["counter"]);
    }
    if (_json.containsKey("dataAccess")) {
      dataAccess = new LogConfigDataAccessOptions.fromJson(_json["dataAccess"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (cloudAudit != null) {
      _json["cloudAudit"] = (cloudAudit).toJson();
    }
    if (counter != null) {
      _json["counter"] = (counter).toJson();
    }
    if (dataAccess != null) {
      _json["dataAccess"] = (dataAccess).toJson();
    }
    return _json;
  }
}

/// Write a Cloud Audit log
class LogConfigCloudAuditOptions {
  /// Information used by the Cloud Audit Logging pipeline.
  AuthorizationLoggingOptions authorizationLoggingOptions;

  /// The log_name to populate in the Cloud Audit Record.
  /// Possible string values are:
  /// - "ADMIN_ACTIVITY"
  /// - "DATA_ACCESS"
  /// - "UNSPECIFIED_LOG_NAME"
  core.String logName;

  LogConfigCloudAuditOptions();

  LogConfigCloudAuditOptions.fromJson(core.Map _json) {
    if (_json.containsKey("authorizationLoggingOptions")) {
      authorizationLoggingOptions = new AuthorizationLoggingOptions.fromJson(
          _json["authorizationLoggingOptions"]);
    }
    if (_json.containsKey("logName")) {
      logName = _json["logName"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (authorizationLoggingOptions != null) {
      _json["authorizationLoggingOptions"] =
          (authorizationLoggingOptions).toJson();
    }
    if (logName != null) {
      _json["logName"] = logName;
    }
    return _json;
  }
}

/// Increment a streamz counter with the specified metric and field names.
///
/// Metric names should start with a '/', generally be lowercase-only, and end
/// in "_count". Field names should not contain an initial slash. The actual
/// exported metric names will have "/iam/policy" prepended.
///
/// Field names correspond to IAM request parameters and field values are their
/// respective values.
///
/// Supported field names: - "authority", which is "[token]" if IAMContext.token
/// is present, otherwise the value of IAMContext.authority_selector if present,
/// and otherwise a representation of IAMContext.principal; or -
/// "iam_principal", a representation of IAMContext.principal even if a token or
/// authority selector is present; or - "" (empty string), resulting in a
/// counter with no fields.
///
/// Examples: counter { metric: "/debug_access_count" field: "iam_principal" }
/// ==> increment counter /iam/policy/debug_access_count {iam_principal=[value
/// of IAMContext.principal]}
class LogConfigCounterOptions {
  /// Custom fields.
  core.List<LogConfigCounterOptionsCustomField> customFields;

  /// The field value to attribute.
  core.String field;

  /// The metric to update.
  core.String metric;

  LogConfigCounterOptions();

  LogConfigCounterOptions.fromJson(core.Map _json) {
    if (_json.containsKey("customFields")) {
      customFields = (_json["customFields"] as core.List)
          .map<LogConfigCounterOptionsCustomField>(
              (value) => new LogConfigCounterOptionsCustomField.fromJson(value))
          .toList();
    }
    if (_json.containsKey("field")) {
      field = _json["field"];
    }
    if (_json.containsKey("metric")) {
      metric = _json["metric"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (customFields != null) {
      _json["customFields"] =
          customFields.map((value) => (value).toJson()).toList();
    }
    if (field != null) {
      _json["field"] = field;
    }
    if (metric != null) {
      _json["metric"] = metric;
    }
    return _json;
  }
}

/// Custom fields. These can be used to create a counter with arbitrary
/// field/value pairs. See: go/rpcsp-custom-fields.
class LogConfigCounterOptionsCustomField {
  /// Name is the field name.
  core.String name;

  /// Value is the field value. It is important that in contrast to the
  /// CounterOptions.field, the value here is a constant that is not derived
  /// from the IAMContext.
  core.String value;

  LogConfigCounterOptionsCustomField();

  LogConfigCounterOptionsCustomField.fromJson(core.Map _json) {
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (name != null) {
      _json["name"] = name;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Write a Data Access (Gin) log
class LogConfigDataAccessOptions {
  /// Whether Gin logging should happen in a fail-closed manner at the caller.
  /// This is currently supported in the LocalIAM implementation, Stubby C++,
  /// and Stubby Java. For Apps Framework, see go/af-audit-logging#failclosed.
  /// TODO(b/77591626): Add support for Stubby Go. TODO(b/129671387): Add
  /// support for Scaffolding.
  /// Possible string values are:
  /// - "LOG_FAIL_CLOSED"
  /// - "LOG_MODE_UNSPECIFIED"
  core.String logMode;

  LogConfigDataAccessOptions();

  LogConfigDataAccessOptions.fromJson(core.Map _json) {
    if (_json.containsKey("logMode")) {
      logMode = _json["logMode"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (logMode != null) {
      _json["logMode"] = logMode;
    }
    return _json;
  }
}

class MachineTypeScratchDisks {
  /// Size of the scratch disk, defined in GB.
  core.int diskGb;

  MachineTypeScratchDisks();

  MachineTypeScratchDisks.fromJson(core.Map _json) {
    if (_json.containsKey("diskGb")) {
      diskGb = _json["diskGb"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskGb != null) {
      _json["diskGb"] = diskGb;
    }
    return _json;
  }
}

/// Represents a Machine Type resource.
///
/// You can use specific machine types for your VM instances based on
/// performance and pricing requirements. For more information, read Machine
/// Types. (== resource_for {$api_version}.machineTypes ==)
class MachineType {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this machine type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional textual description of the resource.
  core.String description;

  /// [Output Only] The number of virtual CPUs that are available to the
  /// instance.
  core.int guestCpus;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Deprecated] This property is deprecated and will never be populated with
  /// any relevant values.
  core.int imageSpaceGb;

  /// [Output Only] Whether this machine type has a shared CPU. See Shared-core
  /// machine types for more information.
  core.bool isSharedCpu;

  /// [Output Only] The type of the resource. Always compute#machineType for
  /// machine types.
  core.String kind;

  /// [Output Only] Maximum persistent disks allowed.
  core.int maximumPersistentDisks;

  /// [Output Only] Maximum total persistent disks size (GB) allowed.
  core.String maximumPersistentDisksSizeGb;

  /// [Output Only] The amount of physical memory available to the instance,
  /// defined in MB.
  core.int memoryMb;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] A list of extended scratch disks assigned to the instance.
  core.List<MachineTypeScratchDisks> scratchDisks;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The name of the zone where the machine type resides, such as
  /// us-central1-a.
  core.String zone;

  MachineType();

  MachineType.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("guestCpus")) {
      guestCpus = _json["guestCpus"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("imageSpaceGb")) {
      imageSpaceGb = _json["imageSpaceGb"];
    }
    if (_json.containsKey("isSharedCpu")) {
      isSharedCpu = _json["isSharedCpu"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("maximumPersistentDisks")) {
      maximumPersistentDisks = _json["maximumPersistentDisks"];
    }
    if (_json.containsKey("maximumPersistentDisksSizeGb")) {
      maximumPersistentDisksSizeGb = _json["maximumPersistentDisksSizeGb"];
    }
    if (_json.containsKey("memoryMb")) {
      memoryMb = _json["memoryMb"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("scratchDisks")) {
      scratchDisks = (_json["scratchDisks"] as core.List)
          .map<MachineTypeScratchDisks>(
              (value) => new MachineTypeScratchDisks.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (guestCpus != null) {
      _json["guestCpus"] = guestCpus;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (imageSpaceGb != null) {
      _json["imageSpaceGb"] = imageSpaceGb;
    }
    if (isSharedCpu != null) {
      _json["isSharedCpu"] = isSharedCpu;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (maximumPersistentDisks != null) {
      _json["maximumPersistentDisks"] = maximumPersistentDisks;
    }
    if (maximumPersistentDisksSizeGb != null) {
      _json["maximumPersistentDisksSizeGb"] = maximumPersistentDisksSizeGb;
    }
    if (memoryMb != null) {
      _json["memoryMb"] = memoryMb;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (scratchDisks != null) {
      _json["scratchDisks"] =
          scratchDisks.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class MachineTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypeAggregatedListWarningData();

  MachineTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class MachineTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypeAggregatedListWarning();

  MachineTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<MachineTypeAggregatedListWarningData>((value) =>
              new MachineTypeAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class MachineTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of MachineTypesScopedList resources.
  core.Map<core.String, MachineTypesScopedList> items;

  /// [Output Only] Type of resource. Always compute#machineTypeAggregatedList
  /// for aggregated lists of machine types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  MachineTypeAggregatedListWarning warning;

  MachineTypeAggregatedList();

  MachineTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, MachineTypesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new MachineTypesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new MachineTypeAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<MachineTypesScopedList, core.Map<core.String, core.Object>>(
              items, (MachineTypesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class MachineTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypeListWarningData();

  MachineTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class MachineTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypeListWarning();

  MachineTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<MachineTypeListWarningData>(
              (value) => new MachineTypeListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of machine types.
class MachineTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of MachineType resources.
  core.List<MachineType> items;

  /// [Output Only] Type of resource. Always compute#machineTypeList for lists
  /// of machine types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  MachineTypeListWarning warning;

  MachineTypeList();

  MachineTypeList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<MachineType>((value) => new MachineType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new MachineTypeListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class MachineTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypesScopedListWarningData();

  MachineTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the machine types
/// list is empty.
class MachineTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypesScopedListWarning();

  MachineTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<MachineTypesScopedListWarningData>(
              (value) => new MachineTypesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class MachineTypesScopedList {
  /// [Output Only] A list of machine types contained in this scope.
  core.List<MachineType> machineTypes;

  /// [Output Only] An informational warning that appears when the machine types
  /// list is empty.
  MachineTypesScopedListWarning warning;

  MachineTypesScopedList();

  MachineTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("machineTypes")) {
      machineTypes = (_json["machineTypes"] as core.List)
          .map<MachineType>((value) => new MachineType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new MachineTypesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (machineTypes != null) {
      _json["machineTypes"] =
          machineTypes.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A Managed Instance resource.
class ManagedInstance {
  /// [Output Only] The current action that the managed instance group has
  /// scheduled for the instance. Possible values:
  /// - NONE The instance is running, and the managed instance group does not
  /// have any scheduled actions for this instance.
  /// - CREATING The managed instance group is creating this instance. If the
  /// group fails to create this instance, it will try again until it is
  /// successful.
  /// - CREATING_WITHOUT_RETRIES The managed instance group is attempting to
  /// create this instance only once. If the group fails to create this
  /// instance, it does not try again and the group's targetSize value is
  /// decreased instead.
  /// - RECREATING The managed instance group is recreating this instance.
  /// - DELETING The managed instance group is permanently deleting this
  /// instance.
  /// - ABANDONING The managed instance group is abandoning this instance. The
  /// instance will be removed from the instance group and from any target pools
  /// that are associated with this group.
  /// - RESTARTING The managed instance group is restarting the instance.
  /// - REFRESHING The managed instance group is applying configuration changes
  /// to the instance without stopping it. For example, the group can update the
  /// target pool list for an instance without stopping that instance.
  /// - VERIFYING The managed instance group has created the instance and it is
  /// in the process of being verified.
  /// Possible string values are:
  /// - "ABANDONING"
  /// - "CREATING"
  /// - "CREATING_WITHOUT_RETRIES"
  /// - "DELETING"
  /// - "NONE"
  /// - "RECREATING"
  /// - "REFRESHING"
  /// - "RESTARTING"
  /// - "VERIFYING"
  core.String currentAction;

  /// [Output only] The unique identifier for this resource. This field is empty
  /// when instance does not exist.
  core.String id;

  /// [Output Only] The URL of the instance. The URL can exist even if the
  /// instance has not yet been created.
  core.String instance;

  /// [Output Only] Health state of the instance per health-check.
  core.List<ManagedInstanceInstanceHealth> instanceHealth;

  /// [Output Only] The status of the instance. This field is empty when the
  /// instance does not exist.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String instanceStatus;

  /// [Output Only] Information about the last attempt to create or delete the
  /// instance.
  ManagedInstanceLastAttempt lastAttempt;

  /// [Output Only] Intended version of this instance.
  ManagedInstanceVersion version;

  ManagedInstance();

  ManagedInstance.fromJson(core.Map _json) {
    if (_json.containsKey("currentAction")) {
      currentAction = _json["currentAction"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("instanceHealth")) {
      instanceHealth = (_json["instanceHealth"] as core.List)
          .map<ManagedInstanceInstanceHealth>(
              (value) => new ManagedInstanceInstanceHealth.fromJson(value))
          .toList();
    }
    if (_json.containsKey("instanceStatus")) {
      instanceStatus = _json["instanceStatus"];
    }
    if (_json.containsKey("lastAttempt")) {
      lastAttempt =
          new ManagedInstanceLastAttempt.fromJson(_json["lastAttempt"]);
    }
    if (_json.containsKey("version")) {
      version = new ManagedInstanceVersion.fromJson(_json["version"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (currentAction != null) {
      _json["currentAction"] = currentAction;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (instanceHealth != null) {
      _json["instanceHealth"] =
          instanceHealth.map((value) => (value).toJson()).toList();
    }
    if (instanceStatus != null) {
      _json["instanceStatus"] = instanceStatus;
    }
    if (lastAttempt != null) {
      _json["lastAttempt"] = (lastAttempt).toJson();
    }
    if (version != null) {
      _json["version"] = (version).toJson();
    }
    return _json;
  }
}

class ManagedInstanceInstanceHealth {
  /// [Output Only] The current detailed instance health state.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "HEALTHY"
  /// - "TIMEOUT"
  /// - "UNHEALTHY"
  /// - "UNKNOWN"
  core.String detailedHealthState;

  /// [Output Only] The URL for the health check that verifies whether the
  /// instance is healthy.
  core.String healthCheck;

  ManagedInstanceInstanceHealth();

  ManagedInstanceInstanceHealth.fromJson(core.Map _json) {
    if (_json.containsKey("detailedHealthState")) {
      detailedHealthState = _json["detailedHealthState"];
    }
    if (_json.containsKey("healthCheck")) {
      healthCheck = _json["healthCheck"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (detailedHealthState != null) {
      _json["detailedHealthState"] = detailedHealthState;
    }
    if (healthCheck != null) {
      _json["healthCheck"] = healthCheck;
    }
    return _json;
  }
}

class ManagedInstanceLastAttemptErrorsErrors {
  /// [Output Only] The error type identifier for this error.
  core.String code;

  /// [Output Only] Indicates the field in the request that caused the error.
  /// This property is optional.
  core.String location;

  /// [Output Only] An optional, human-readable error message.
  core.String message;

  ManagedInstanceLastAttemptErrorsErrors();

  ManagedInstanceLastAttemptErrorsErrors.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("location")) {
      location = _json["location"];
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (location != null) {
      _json["location"] = location;
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// [Output Only] Encountered errors during the last attempt to create or delete
/// the instance.
class ManagedInstanceLastAttemptErrors {
  /// [Output Only] The array of errors encountered while processing this
  /// operation.
  core.List<ManagedInstanceLastAttemptErrorsErrors> errors;

  ManagedInstanceLastAttemptErrors();

  ManagedInstanceLastAttemptErrors.fromJson(core.Map _json) {
    if (_json.containsKey("errors")) {
      errors = (_json["errors"] as core.List)
          .map<ManagedInstanceLastAttemptErrorsErrors>((value) =>
              new ManagedInstanceLastAttemptErrorsErrors.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (errors != null) {
      _json["errors"] = errors.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class ManagedInstanceLastAttempt {
  /// [Output Only] Encountered errors during the last attempt to create or
  /// delete the instance.
  ManagedInstanceLastAttemptErrors errors;

  ManagedInstanceLastAttempt();

  ManagedInstanceLastAttempt.fromJson(core.Map _json) {
    if (_json.containsKey("errors")) {
      errors = new ManagedInstanceLastAttemptErrors.fromJson(_json["errors"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (errors != null) {
      _json["errors"] = (errors).toJson();
    }
    return _json;
  }
}

class ManagedInstanceVersion {
  /// [Output Only] The intended template of the instance. This field is empty
  /// when current_action is one of { DELETING, ABANDONING }.
  core.String instanceTemplate;

  /// [Output Only] Name of the version.
  core.String name;

  ManagedInstanceVersion();

  ManagedInstanceVersion.fromJson(core.Map _json) {
    if (_json.containsKey("instanceTemplate")) {
      instanceTemplate = _json["instanceTemplate"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceTemplate != null) {
      _json["instanceTemplate"] = instanceTemplate;
    }
    if (name != null) {
      _json["name"] = name;
    }
    return _json;
  }
}

class MetadataItems {
  /// Key for the metadata entry. Keys must conform to the following regexp:
  /// [a-zA-Z0-9-_]+, and be less than 128 bytes in length. This is reflected as
  /// part of a URL in the metadata server. Additionally, to avoid ambiguity,
  /// keys must not conflict with any other metadata keys for the project.
  core.String key;

  /// Value for the metadata entry. These are free-form strings, and only have
  /// meaning as interpreted by the image running in the instance. The only
  /// restriction placed on values is that their size must be less than or equal
  /// to 262144 bytes (256 KiB).
  core.String value;

  MetadataItems();

  MetadataItems.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// A metadata key/value entry.
class Metadata {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking. The fingerprint
  /// is initially generated by Compute Engine and changes after every request
  /// to modify or update metadata. You must always provide an up-to-date
  /// fingerprint hash in order to update or change metadata, otherwise the
  /// request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve the
  /// resource.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Array of key/value pairs. The total size of all keys and values must be
  /// less than 512 KB.
  core.List<MetadataItems> items;

  /// [Output Only] Type of the resource. Always compute#metadata for metadata.
  core.String kind;

  Metadata();

  Metadata.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<MetadataItems>((value) => new MetadataItems.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    return _json;
  }
}

/// Opaque filter criteria used by loadbalancers to restrict routing
/// configuration to a limited set of loadbalancing proxies. Proxies and
/// sidecars involved in loadbalancing would typically present metadata to the
/// loadbalancers which need to match criteria specified here. If a match takes
/// place, the relevant configuration is made available to those proxies.
/// For each metadataFilter in this list, if its filterMatchCriteria is set to
/// MATCH_ANY, at least one of the filterLabels must match the corresponding
/// label provided in the metadata. If its filterMatchCriteria is set to
/// MATCH_ALL, then all of its filterLabels must match with corresponding labels
/// provided in the metadata.
/// An example for using metadataFilters would be: if loadbalancing involves
/// Envoys, they will only receive routing configuration when values in
/// metadataFilters match values supplied in <a
/// href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/base.proto#envoy-api-msg-core-node"
/// Node metadata of their XDS requests to loadbalancers.
class MetadataFilter {
  /// The list of label value pairs that must match labels in the provided
  /// metadata based on filterMatchCriteria
  /// This list must not be empty and can have at the most 64 entries.
  core.List<MetadataFilterLabelMatch> filterLabels;

  /// Specifies how individual filterLabel matches within the list of
  /// filterLabels contribute towards the overall metadataFilter match.
  /// Supported values are:
  /// - MATCH_ANY: At least one of the filterLabels must have a matching label
  /// in the provided metadata.
  /// - MATCH_ALL: All filterLabels must have matching labels in the provided
  /// metadata.
  /// Possible string values are:
  /// - "MATCH_ALL"
  /// - "MATCH_ANY"
  /// - "NOT_SET"
  core.String filterMatchCriteria;

  MetadataFilter();

  MetadataFilter.fromJson(core.Map _json) {
    if (_json.containsKey("filterLabels")) {
      filterLabels = (_json["filterLabels"] as core.List)
          .map<MetadataFilterLabelMatch>(
              (value) => new MetadataFilterLabelMatch.fromJson(value))
          .toList();
    }
    if (_json.containsKey("filterMatchCriteria")) {
      filterMatchCriteria = _json["filterMatchCriteria"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (filterLabels != null) {
      _json["filterLabels"] =
          filterLabels.map((value) => (value).toJson()).toList();
    }
    if (filterMatchCriteria != null) {
      _json["filterMatchCriteria"] = filterMatchCriteria;
    }
    return _json;
  }
}

/// MetadataFilter label name value pairs that are expected to match
/// corresponding labels presented as metadata to the loadbalancer.
class MetadataFilterLabelMatch {
  /// Name of metadata label.
  /// The name can have a maximum length of 1024 characters and must be at least
  /// 1 character long.
  core.String name;

  /// The value of the label must match the specified value.
  /// value can have a maximum length of 1024 characters.
  core.String value;

  MetadataFilterLabelMatch();

  MetadataFilterLabelMatch.fromJson(core.Map _json) {
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (name != null) {
      _json["name"] = name;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// The named port. For example: .
class NamedPort {
  /// The name for this named port. The name must be 1-63 characters long, and
  /// comply with RFC1035.
  core.String name;

  /// The port number, which can be a value between 1 and 65535.
  core.int port;

  NamedPort();

  NamedPort.fromJson(core.Map _json) {
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (name != null) {
      _json["name"] = name;
    }
    if (port != null) {
      _json["port"] = port;
    }
    return _json;
  }
}

/// Represents a VPC Network resource.
///
/// Networks connect resources to each other and to the internet. For more
/// information, read Virtual Private Cloud (VPC) Network. (== resource_for
/// {$api_version}.networks ==)
class Network {
  /// Deprecated in favor of subnet mode networks. The range of internal
  /// addresses that are legal on this network. This range is a CIDR
  /// specification, for example: 192.168.0.0/16. Provided by the client when
  /// the network is created.
  core.String IPv4Range;

  /// When set to true, the VPC network is created in "auto" mode. When set to
  /// false, the VPC network is created in "custom" mode.
  ///
  /// An auto mode VPC network starts with one subnet per region. Each subnet
  /// has a predetermined range as described in Auto mode VPC network IP ranges.
  core.bool autoCreateSubnetworks;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this field when you
  /// create the resource.
  core.String description;

  /// [Output Only] The gateway address for default routing out of the network,
  /// selected by GCP.
  core.String gatewayIPv4;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#network for networks.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
  /// lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String name;

  /// [Output Only] A list of network peerings for the resource.
  core.List<NetworkPeering> peerings;

  /// The network-level routing configuration for this network. Used by Cloud
  /// Router to determine what type of network-wide routing behavior to enforce.
  NetworkRoutingConfig routingConfig;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Server-defined fully-qualified URLs for all subnetworks in
  /// this VPC network.
  core.List<core.String> subnetworks;

  Network();

  Network.fromJson(core.Map _json) {
    if (_json.containsKey("IPv4Range")) {
      IPv4Range = _json["IPv4Range"];
    }
    if (_json.containsKey("autoCreateSubnetworks")) {
      autoCreateSubnetworks = _json["autoCreateSubnetworks"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("gatewayIPv4")) {
      gatewayIPv4 = _json["gatewayIPv4"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peerings")) {
      peerings = (_json["peerings"] as core.List)
          .map<NetworkPeering>((value) => new NetworkPeering.fromJson(value))
          .toList();
    }
    if (_json.containsKey("routingConfig")) {
      routingConfig = new NetworkRoutingConfig.fromJson(_json["routingConfig"]);
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("subnetworks")) {
      subnetworks = (_json["subnetworks"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPv4Range != null) {
      _json["IPv4Range"] = IPv4Range;
    }
    if (autoCreateSubnetworks != null) {
      _json["autoCreateSubnetworks"] = autoCreateSubnetworks;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (gatewayIPv4 != null) {
      _json["gatewayIPv4"] = gatewayIPv4;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peerings != null) {
      _json["peerings"] = peerings.map((value) => (value).toJson()).toList();
    }
    if (routingConfig != null) {
      _json["routingConfig"] = (routingConfig).toJson();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (subnetworks != null) {
      _json["subnetworks"] = subnetworks;
    }
    return _json;
  }
}

/// The network endpoint. Next ID: 7
class NetworkEndpoint {
  /// Optional fully qualified domain name of network endpoint. This can only be
  /// specified when NetworkEndpointGroup.network_endpoint_type is
  /// NON_GCP_FQDN_PORT.
  core.String fqdn;

  /// The name for a specific VM instance that the IP address belongs to. This
  /// is required for network endpoints of type GCE_VM_IP_PORT. The instance
  /// must be in the same zone of network endpoint group.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String instance;

  /// Optional IPv4 address of network endpoint. The IP address must belong to a
  /// VM in Compute Engine (either the primary IP or as part of an aliased IP
  /// range). If the IP address is not specified, then the primary IP address
  /// for the VM instance in the network that the network endpoint group belongs
  /// to will be used.
  core.String ipAddress;

  /// Optional port number of network endpoint. If not specified and the
  /// NetworkEndpointGroup.network_endpoint_type is GCE_IP_PORT, the defaultPort
  /// for the network endpoint group will be used.
  core.int port;

  NetworkEndpoint();

  NetworkEndpoint.fromJson(core.Map _json) {
    if (_json.containsKey("fqdn")) {
      fqdn = _json["fqdn"];
    }
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fqdn != null) {
      _json["fqdn"] = fqdn;
    }
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    if (port != null) {
      _json["port"] = port;
    }
    return _json;
  }
}

/// Represents a collection of network endpoints.
///
/// For more information read Network endpoint groups overview. (== resource_for
/// {$api_version}.networkEndpointGroups ==) Next ID: 21
class NetworkEndpointGroup {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The default port used if the port number is not specified in the network
  /// endpoint.
  core.int defaultPort;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#networkEndpointGroup
  /// for network endpoint group.
  core.String kind;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The URL of the network to which all network endpoints in the NEG belong.
  /// Uses "default" project network if unspecified.
  core.String network;

  /// Type of network endpoints in this network endpoint group.
  /// Possible string values are:
  /// - "GCE_VM_IP_PORT"
  /// - "INTERNET_FQDN_PORT"
  /// - "INTERNET_IP_PORT"
  core.String networkEndpointType;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output only] Number of network endpoints in the network endpoint group.
  core.int size;

  /// Optional URL of the subnetwork to which all network endpoints in the NEG
  /// belong.
  core.String subnetwork;

  /// [Output Only] The URL of the zone where the network endpoint group is
  /// located.
  core.String zone;

  NetworkEndpointGroup();

  NetworkEndpointGroup.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("defaultPort")) {
      defaultPort = _json["defaultPort"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("networkEndpointType")) {
      networkEndpointType = _json["networkEndpointType"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("size")) {
      size = _json["size"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (defaultPort != null) {
      _json["defaultPort"] = defaultPort;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (networkEndpointType != null) {
      _json["networkEndpointType"] = networkEndpointType;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (size != null) {
      _json["size"] = size;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class NetworkEndpointGroupAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkEndpointGroupAggregatedListWarningData();

  NetworkEndpointGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkEndpointGroupAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkEndpointGroupAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkEndpointGroupAggregatedListWarning();

  NetworkEndpointGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NetworkEndpointGroupAggregatedListWarningData>((value) =>
              new NetworkEndpointGroupAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NetworkEndpointGroupAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NetworkEndpointGroupsScopedList resources.
  core.Map<core.String, NetworkEndpointGroupsScopedList> items;

  /// [Output Only] The resource type, which is always
  /// compute#networkEndpointGroupAggregatedList for aggregated lists of network
  /// endpoint groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NetworkEndpointGroupAggregatedListWarning warning;

  NetworkEndpointGroupAggregatedList();

  NetworkEndpointGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, NetworkEndpointGroupsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) =>
              new NetworkEndpointGroupsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NetworkEndpointGroupAggregatedListWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<NetworkEndpointGroupsScopedList,
              core.Map<core.String, core.Object>>(
          items, (NetworkEndpointGroupsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NetworkEndpointGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkEndpointGroupListWarningData();

  NetworkEndpointGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkEndpointGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkEndpointGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkEndpointGroupListWarning();

  NetworkEndpointGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NetworkEndpointGroupListWarningData>((value) =>
              new NetworkEndpointGroupListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NetworkEndpointGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NetworkEndpointGroup resources.
  core.List<NetworkEndpointGroup> items;

  /// [Output Only] The resource type, which is always
  /// compute#networkEndpointGroupList for network endpoint group lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NetworkEndpointGroupListWarning warning;

  NetworkEndpointGroupList();

  NetworkEndpointGroupList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<NetworkEndpointGroup>(
              (value) => new NetworkEndpointGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NetworkEndpointGroupListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NetworkEndpointGroupsAttachEndpointsRequest {
  /// The list of network endpoints to be attached.
  core.List<NetworkEndpoint> networkEndpoints;

  NetworkEndpointGroupsAttachEndpointsRequest();

  NetworkEndpointGroupsAttachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("networkEndpoints")) {
      networkEndpoints = (_json["networkEndpoints"] as core.List)
          .map<NetworkEndpoint>((value) => new NetworkEndpoint.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (networkEndpoints != null) {
      _json["networkEndpoints"] =
          networkEndpoints.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class NetworkEndpointGroupsDetachEndpointsRequest {
  /// The list of network endpoints to be detached.
  core.List<NetworkEndpoint> networkEndpoints;

  NetworkEndpointGroupsDetachEndpointsRequest();

  NetworkEndpointGroupsDetachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("networkEndpoints")) {
      networkEndpoints = (_json["networkEndpoints"] as core.List)
          .map<NetworkEndpoint>((value) => new NetworkEndpoint.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (networkEndpoints != null) {
      _json["networkEndpoints"] =
          networkEndpoints.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class NetworkEndpointGroupsListEndpointsRequest {
  /// Optional query parameter for showing the health status of each network
  /// endpoint. Valid options are SKIP or SHOW. If you don't specifiy this
  /// parameter, the health status of network endpoints will not be provided.
  /// Possible string values are:
  /// - "SHOW"
  /// - "SKIP"
  core.String healthStatus;

  NetworkEndpointGroupsListEndpointsRequest();

  NetworkEndpointGroupsListEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("healthStatus")) {
      healthStatus = _json["healthStatus"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthStatus != null) {
      _json["healthStatus"] = healthStatus;
    }
    return _json;
  }
}

class NetworkEndpointGroupsListNetworkEndpointsWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkEndpointGroupsListNetworkEndpointsWarningData();

  NetworkEndpointGroupsListNetworkEndpointsWarningData.fromJson(
      core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkEndpointGroupsListNetworkEndpointsWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkEndpointGroupsListNetworkEndpointsWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkEndpointGroupsListNetworkEndpointsWarning();

  NetworkEndpointGroupsListNetworkEndpointsWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NetworkEndpointGroupsListNetworkEndpointsWarningData>((value) =>
              new NetworkEndpointGroupsListNetworkEndpointsWarningData.fromJson(
                  value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NetworkEndpointGroupsListNetworkEndpoints {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NetworkEndpointWithHealthStatus resources.
  core.List<NetworkEndpointWithHealthStatus> items;

  /// [Output Only] The resource type, which is always
  /// compute#networkEndpointGroupsListNetworkEndpoints for the list of network
  /// endpoints in the specified network endpoint group.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Informational warning message.
  NetworkEndpointGroupsListNetworkEndpointsWarning warning;

  NetworkEndpointGroupsListNetworkEndpoints();

  NetworkEndpointGroupsListNetworkEndpoints.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<NetworkEndpointWithHealthStatus>(
              (value) => new NetworkEndpointWithHealthStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("warning")) {
      warning = new NetworkEndpointGroupsListNetworkEndpointsWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NetworkEndpointGroupsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkEndpointGroupsScopedListWarningData();

  NetworkEndpointGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that replaces the list of network
/// endpoint groups when the list is empty.
class NetworkEndpointGroupsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkEndpointGroupsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkEndpointGroupsScopedListWarning();

  NetworkEndpointGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NetworkEndpointGroupsScopedListWarningData>((value) =>
              new NetworkEndpointGroupsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NetworkEndpointGroupsScopedList {
  /// [Output Only] The list of network endpoint groups that are contained in
  /// this scope.
  core.List<NetworkEndpointGroup> networkEndpointGroups;

  /// [Output Only] An informational warning that replaces the list of network
  /// endpoint groups when the list is empty.
  NetworkEndpointGroupsScopedListWarning warning;

  NetworkEndpointGroupsScopedList();

  NetworkEndpointGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("networkEndpointGroups")) {
      networkEndpointGroups = (_json["networkEndpointGroups"] as core.List)
          .map<NetworkEndpointGroup>(
              (value) => new NetworkEndpointGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new NetworkEndpointGroupsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (networkEndpointGroups != null) {
      _json["networkEndpointGroups"] =
          networkEndpointGroups.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NetworkEndpointWithHealthStatus {
  /// [Output only] The health status of network endpoint;
  core.List<HealthStatusForNetworkEndpoint> healths;

  /// [Output only] The network endpoint;
  NetworkEndpoint networkEndpoint;

  NetworkEndpointWithHealthStatus();

  NetworkEndpointWithHealthStatus.fromJson(core.Map _json) {
    if (_json.containsKey("healths")) {
      healths = (_json["healths"] as core.List)
          .map<HealthStatusForNetworkEndpoint>(
              (value) => new HealthStatusForNetworkEndpoint.fromJson(value))
          .toList();
    }
    if (_json.containsKey("networkEndpoint")) {
      networkEndpoint = new NetworkEndpoint.fromJson(_json["networkEndpoint"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healths != null) {
      _json["healths"] = healths.map((value) => (value).toJson()).toList();
    }
    if (networkEndpoint != null) {
      _json["networkEndpoint"] = (networkEndpoint).toJson();
    }
    return _json;
  }
}

/// A network interface resource attached to an instance.
class NetworkInterface {
  /// An array of configurations for this interface. Currently, only one access
  /// config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs
  /// specified, then this instance will have no external internet access.
  core.List<AccessConfig> accessConfigs;

  /// An array of alias IP ranges for this network interface. You can only
  /// specify this field for network interfaces in VPC networks.
  core.List<AliasIpRange> aliasIpRanges;

  /// Fingerprint hash of contents stored in this network interface. This field
  /// will be ignored when inserting an Instance or adding a NetworkInterface.
  /// An up-to-date fingerprint must be provided in order to update the
  /// NetworkInterface, otherwise the request will fail with error 412
  /// conditionNotMet.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] Type of the resource. Always compute#networkInterface for
  /// network interfaces.
  core.String kind;

  /// [Output Only] The name of the network interface, which is generated by the
  /// server. For network devices, these are eth0, eth1, etc.
  core.String name;

  /// URL of the network resource for this instance. When creating an instance,
  /// if neither the network nor the subnetwork is specified, the default
  /// network global/networks/default is used; if the network is not specified
  /// but the subnetwork is specified, the network is inferred.
  ///
  /// If you specify this property, you can specify the network as a full or
  /// partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/networks/network
  /// - projects/project/global/networks/network
  /// - global/networks/default
  core.String network;

  /// An IPv4 internal IP address to assign to the instance for this network
  /// interface. If not specified by the user, an unused internal IP is assigned
  /// by the system.
  core.String networkIP;

  /// The URL of the Subnetwork resource for this instance. If the network
  /// resource is in legacy mode, do not specify this field. If the network is
  /// in auto subnet mode, specifying the subnetwork is optional. If the network
  /// is in custom subnet mode, specifying the subnetwork is required. If you
  /// specify this field, you can specify the subnetwork as a full or partial
  /// URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/subnetworks/subnetwork
  /// - regions/region/subnetworks/subnetwork
  core.String subnetwork;

  NetworkInterface();

  NetworkInterface.fromJson(core.Map _json) {
    if (_json.containsKey("accessConfigs")) {
      accessConfigs = (_json["accessConfigs"] as core.List)
          .map<AccessConfig>((value) => new AccessConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("aliasIpRanges")) {
      aliasIpRanges = (_json["aliasIpRanges"] as core.List)
          .map<AliasIpRange>((value) => new AliasIpRange.fromJson(value))
          .toList();
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("networkIP")) {
      networkIP = _json["networkIP"];
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (accessConfigs != null) {
      _json["accessConfigs"] =
          accessConfigs.map((value) => (value).toJson()).toList();
    }
    if (aliasIpRanges != null) {
      _json["aliasIpRanges"] =
          aliasIpRanges.map((value) => (value).toJson()).toList();
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (networkIP != null) {
      _json["networkIP"] = networkIP;
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    return _json;
  }
}

class NetworkListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkListWarningData();

  NetworkListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkListWarning();

  NetworkListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NetworkListWarningData>(
              (value) => new NetworkListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of networks.
class NetworkList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Network resources.
  core.List<Network> items;

  /// [Output Only] Type of resource. Always compute#networkList for lists of
  /// networks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NetworkListWarning warning;

  NetworkList();

  NetworkList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Network>((value) => new Network.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NetworkListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A network peering attached to a network resource. The message includes the
/// peering name, peer network, peering state, and a flag indicating whether
/// Google Compute Engine should automatically create routes for the peering.
class NetworkPeering {
  /// This field will be deprecated soon. Use the exchange_subnet_routes field
  /// instead. Indicates whether full mesh connectivity is created and managed
  /// automatically between peered networks. Currently this field should always
  /// be true since Google Compute Engine will automatically create and manage
  /// subnetwork routes between two networks when peering state is ACTIVE.
  core.bool autoCreateRoutes;

  /// Indicates whether full mesh connectivity is created and managed
  /// automatically between peered networks. Currently this field should always
  /// be true since Google Compute Engine will automatically create and manage
  /// subnetwork routes between two networks when peering state is ACTIVE.
  core.bool exchangeSubnetRoutes;

  /// Whether to export the custom routes to peer network.
  core.bool exportCustomRoutes;

  /// Whether subnet routes with public IP range are exported. The default value
  /// is true, all subnet routes are exported. The IPv4 special-use ranges
  /// (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported
  /// to peers and are not controlled by this field.
  core.bool exportSubnetRoutesWithPublicIp;

  /// Whether to import the custom routes from peer network.
  core.bool importCustomRoutes;

  /// Whether subnet routes with public IP range are imported. The default value
  /// is false. The IPv4 special-use ranges
  /// (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported
  /// from peers and are not controlled by this field.
  core.bool importSubnetRoutesWithPublicIp;

  /// Name of this peering. Provided by the client when the peering is created.
  /// The name must comply with RFC1035. Specifically, the name must be 1-63
  /// characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`.
  /// The first character must be a lowercase letter, and all the following
  /// characters must be a dash, lowercase letter, or digit, except the last
  /// character, which cannot be a dash.
  core.String name;

  /// The URL of the peer network. It can be either full URL or partial URL. The
  /// peer network may belong to a different project. If the partial URL does
  /// not contain project, it is assumed that the peer network is in the same
  /// project as the current network.
  core.String network;

  /// [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The
  /// peering is `ACTIVE` when there's a matching configuration in the peer
  /// network.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "INACTIVE"
  core.String state;

  /// [Output Only] Details about the current state of the peering.
  core.String stateDetails;

  NetworkPeering();

  NetworkPeering.fromJson(core.Map _json) {
    if (_json.containsKey("autoCreateRoutes")) {
      autoCreateRoutes = _json["autoCreateRoutes"];
    }
    if (_json.containsKey("exchangeSubnetRoutes")) {
      exchangeSubnetRoutes = _json["exchangeSubnetRoutes"];
    }
    if (_json.containsKey("exportCustomRoutes")) {
      exportCustomRoutes = _json["exportCustomRoutes"];
    }
    if (_json.containsKey("exportSubnetRoutesWithPublicIp")) {
      exportSubnetRoutesWithPublicIp = _json["exportSubnetRoutesWithPublicIp"];
    }
    if (_json.containsKey("importCustomRoutes")) {
      importCustomRoutes = _json["importCustomRoutes"];
    }
    if (_json.containsKey("importSubnetRoutesWithPublicIp")) {
      importSubnetRoutesWithPublicIp = _json["importSubnetRoutesWithPublicIp"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
    if (_json.containsKey("stateDetails")) {
      stateDetails = _json["stateDetails"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoCreateRoutes != null) {
      _json["autoCreateRoutes"] = autoCreateRoutes;
    }
    if (exchangeSubnetRoutes != null) {
      _json["exchangeSubnetRoutes"] = exchangeSubnetRoutes;
    }
    if (exportCustomRoutes != null) {
      _json["exportCustomRoutes"] = exportCustomRoutes;
    }
    if (exportSubnetRoutesWithPublicIp != null) {
      _json["exportSubnetRoutesWithPublicIp"] = exportSubnetRoutesWithPublicIp;
    }
    if (importCustomRoutes != null) {
      _json["importCustomRoutes"] = importCustomRoutes;
    }
    if (importSubnetRoutesWithPublicIp != null) {
      _json["importSubnetRoutesWithPublicIp"] = importSubnetRoutesWithPublicIp;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (state != null) {
      _json["state"] = state;
    }
    if (stateDetails != null) {
      _json["stateDetails"] = stateDetails;
    }
    return _json;
  }
}

/// A routing configuration attached to a network resource. The message includes
/// the list of routers associated with the network, and a flag indicating the
/// type of routing behavior to enforce network-wide.
class NetworkRoutingConfig {
  /// The network-wide routing mode to use. If set to REGIONAL, this network's
  /// Cloud Routers will only advertise routes with subnets of this network in
  /// the same region as the router. If set to GLOBAL, this network's Cloud
  /// Routers will advertise routes with all subnets of this network, across
  /// regions.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "REGIONAL"
  core.String routingMode;

  NetworkRoutingConfig();

  NetworkRoutingConfig.fromJson(core.Map _json) {
    if (_json.containsKey("routingMode")) {
      routingMode = _json["routingMode"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (routingMode != null) {
      _json["routingMode"] = routingMode;
    }
    return _json;
  }
}

class NetworksAddPeeringRequest {
  /// This field will be deprecated soon. Use exchange_subnet_routes in
  /// network_peering instead. Indicates whether full mesh connectivity is
  /// created and managed automatically between peered networks. Currently this
  /// field should always be true since Google Compute Engine will automatically
  /// create and manage subnetwork routes between two networks when peering
  /// state is ACTIVE.
  core.bool autoCreateRoutes;

  /// Name of the peering, which should conform to RFC1035.
  core.String name;

  /// Network peering parameters. In order to specify route policies for peering
  /// using import and export custom routes, you must specify all peering
  /// related parameters (name, peer network, exchange_subnet_routes) in the
  /// network_peering field. The corresponding fields in
  /// NetworksAddPeeringRequest will be deprecated soon.
  NetworkPeering networkPeering;

  /// URL of the peer network. It can be either full URL or partial URL. The
  /// peer network may belong to a different project. If the partial URL does
  /// not contain project, it is assumed that the peer network is in the same
  /// project as the current network.
  core.String peerNetwork;

  NetworksAddPeeringRequest();

  NetworksAddPeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey("autoCreateRoutes")) {
      autoCreateRoutes = _json["autoCreateRoutes"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("networkPeering")) {
      networkPeering = new NetworkPeering.fromJson(_json["networkPeering"]);
    }
    if (_json.containsKey("peerNetwork")) {
      peerNetwork = _json["peerNetwork"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoCreateRoutes != null) {
      _json["autoCreateRoutes"] = autoCreateRoutes;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (networkPeering != null) {
      _json["networkPeering"] = (networkPeering).toJson();
    }
    if (peerNetwork != null) {
      _json["peerNetwork"] = peerNetwork;
    }
    return _json;
  }
}

class NetworksRemovePeeringRequest {
  /// Name of the peering, which should conform to RFC1035.
  core.String name;

  NetworksRemovePeeringRequest();

  NetworksRemovePeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (name != null) {
      _json["name"] = name;
    }
    return _json;
  }
}

class NetworksUpdatePeeringRequest {
  NetworkPeering networkPeering;

  NetworksUpdatePeeringRequest();

  NetworksUpdatePeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey("networkPeering")) {
      networkPeering = new NetworkPeering.fromJson(_json["networkPeering"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (networkPeering != null) {
      _json["networkPeering"] = (networkPeering).toJson();
    }
    return _json;
  }
}

/// Represent a sole-tenant Node Group resource.
///
/// A sole-tenant node is a physical server that is dedicated to hosting VM
/// instances only for your specific project. Use sole-tenant nodes to keep your
/// instances physically separated from instances in other projects, or to group
/// your instances together on the same host hardware. For more information,
/// read Sole-tenant nodes. (== resource_for {$api_version}.nodeGroups ==)
class NodeGroup {
  /// Specifies how autoscaling should behave.
  NodeGroupAutoscalingPolicy autoscalingPolicy;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#nodeGroup for node
  /// group.
  core.String kind;

  /// Specifies how to handle instances when a node in the group undergoes
  /// maintenance.
  /// Possible string values are:
  /// - "DEFAULT"
  /// - "MAINTENANCE_POLICY_UNSPECIFIED"
  /// - "MIGRATE_WITHIN_NODE_GROUP"
  /// - "RESTART_IN_PLACE"
  core.String maintenancePolicy;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// The URL of the node template to which this node group belongs.
  core.String nodeTemplate;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The total number of nodes in the node group.
  core.int size;

  ///
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String status;

  /// [Output Only] The name of the zone where the node group resides, such as
  /// us-central1-a.
  core.String zone;

  NodeGroup();

  NodeGroup.fromJson(core.Map _json) {
    if (_json.containsKey("autoscalingPolicy")) {
      autoscalingPolicy =
          new NodeGroupAutoscalingPolicy.fromJson(_json["autoscalingPolicy"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("maintenancePolicy")) {
      maintenancePolicy = _json["maintenancePolicy"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("nodeTemplate")) {
      nodeTemplate = _json["nodeTemplate"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("size")) {
      size = _json["size"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoscalingPolicy != null) {
      _json["autoscalingPolicy"] = (autoscalingPolicy).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (maintenancePolicy != null) {
      _json["maintenancePolicy"] = maintenancePolicy;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (nodeTemplate != null) {
      _json["nodeTemplate"] = nodeTemplate;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (size != null) {
      _json["size"] = size;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class NodeGroupAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeGroupAggregatedListWarningData();

  NodeGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeGroupAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeGroupAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeGroupAggregatedListWarning();

  NodeGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeGroupAggregatedListWarningData>(
              (value) => new NodeGroupAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NodeGroupAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeGroupsScopedList resources.
  core.Map<core.String, NodeGroupsScopedList> items;

  /// [Output Only] Type of resource.Always compute#nodeGroupAggregatedList for
  /// aggregated lists of node groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeGroupAggregatedListWarning warning;

  NodeGroupAggregatedList();

  NodeGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, NodeGroupsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new NodeGroupsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NodeGroupAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<NodeGroupsScopedList, core.Map<core.String, core.Object>>(
              items, (NodeGroupsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NodeGroupAutoscalingPolicy {
  /// The maximum number of nodes that the group should have.
  core.int maxNodes;

  /// The minimum number of nodes that the group should have.
  core.int minNodes;

  /// The autoscaling mode.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED"
  /// - "OFF"
  /// - "ON"
  /// - "ONLY_SCALE_OUT"
  core.String mode;

  NodeGroupAutoscalingPolicy();

  NodeGroupAutoscalingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("maxNodes")) {
      maxNodes = _json["maxNodes"];
    }
    if (_json.containsKey("minNodes")) {
      minNodes = _json["minNodes"];
    }
    if (_json.containsKey("mode")) {
      mode = _json["mode"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (maxNodes != null) {
      _json["maxNodes"] = maxNodes;
    }
    if (minNodes != null) {
      _json["minNodes"] = minNodes;
    }
    if (mode != null) {
      _json["mode"] = mode;
    }
    return _json;
  }
}

class NodeGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeGroupListWarningData();

  NodeGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeGroupListWarning();

  NodeGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeGroupListWarningData>(
              (value) => new NodeGroupListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of nodeGroups.
class NodeGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeGroup resources.
  core.List<NodeGroup> items;

  /// [Output Only] Type of resource.Always compute#nodeGroupList for lists of
  /// node groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeGroupListWarning warning;

  NodeGroupList();

  NodeGroupList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<NodeGroup>((value) => new NodeGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NodeGroupListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NodeGroupNode {
  /// Instances scheduled on this node.
  core.List<core.String> instances;

  /// The name of the node.
  core.String name;

  /// The type of this node.
  core.String nodeType;

  /// Binding properties for the physical server.
  ServerBinding serverBinding;

  /// Server ID associated with this node.
  core.String serverId;

  ///
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  /// - "REPAIRING"
  core.String status;

  NodeGroupNode();

  NodeGroupNode.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("nodeType")) {
      nodeType = _json["nodeType"];
    }
    if (_json.containsKey("serverBinding")) {
      serverBinding = new ServerBinding.fromJson(_json["serverBinding"]);
    }
    if (_json.containsKey("serverId")) {
      serverId = _json["serverId"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (nodeType != null) {
      _json["nodeType"] = nodeType;
    }
    if (serverBinding != null) {
      _json["serverBinding"] = (serverBinding).toJson();
    }
    if (serverId != null) {
      _json["serverId"] = serverId;
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

class NodeGroupsAddNodesRequest {
  /// Count of additional nodes to be added to the node group.
  core.int additionalNodeCount;

  NodeGroupsAddNodesRequest();

  NodeGroupsAddNodesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("additionalNodeCount")) {
      additionalNodeCount = _json["additionalNodeCount"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (additionalNodeCount != null) {
      _json["additionalNodeCount"] = additionalNodeCount;
    }
    return _json;
  }
}

class NodeGroupsDeleteNodesRequest {
  /// Names of the nodes to delete.
  core.List<core.String> nodes;

  NodeGroupsDeleteNodesRequest();

  NodeGroupsDeleteNodesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("nodes")) {
      nodes = (_json["nodes"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (nodes != null) {
      _json["nodes"] = nodes;
    }
    return _json;
  }
}

class NodeGroupsListNodesWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeGroupsListNodesWarningData();

  NodeGroupsListNodesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeGroupsListNodesWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeGroupsListNodesWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeGroupsListNodesWarning();

  NodeGroupsListNodesWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeGroupsListNodesWarningData>(
              (value) => new NodeGroupsListNodesWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NodeGroupsListNodes {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Node resources.
  core.List<NodeGroupNode> items;

  /// [Output Only] The resource type, which is always
  /// compute.nodeGroupsListNodes for the list of nodes in the specified node
  /// group.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeGroupsListNodesWarning warning;

  NodeGroupsListNodes();

  NodeGroupsListNodes.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<NodeGroupNode>((value) => new NodeGroupNode.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NodeGroupsListNodesWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NodeGroupsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeGroupsScopedListWarningData();

  NodeGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the nodeGroup list
/// is empty.
class NodeGroupsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeGroupsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeGroupsScopedListWarning();

  NodeGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeGroupsScopedListWarningData>(
              (value) => new NodeGroupsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NodeGroupsScopedList {
  /// [Output Only] A list of node groups contained in this scope.
  core.List<NodeGroup> nodeGroups;

  /// [Output Only] An informational warning that appears when the nodeGroup
  /// list is empty.
  NodeGroupsScopedListWarning warning;

  NodeGroupsScopedList();

  NodeGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("nodeGroups")) {
      nodeGroups = (_json["nodeGroups"] as core.List)
          .map<NodeGroup>((value) => new NodeGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new NodeGroupsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (nodeGroups != null) {
      _json["nodeGroups"] =
          nodeGroups.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NodeGroupsSetNodeTemplateRequest {
  /// Full or partial URL of the node template resource to be updated for this
  /// node group.
  core.String nodeTemplate;

  NodeGroupsSetNodeTemplateRequest();

  NodeGroupsSetNodeTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("nodeTemplate")) {
      nodeTemplate = _json["nodeTemplate"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (nodeTemplate != null) {
      _json["nodeTemplate"] = nodeTemplate;
    }
    return _json;
  }
}

/// Represent a sole-tenant Node Template resource.
///
/// You can use a template to define properties for nodes in a node group. For
/// more information, read Creating node groups and instances. (== resource_for
/// {$api_version}.nodeTemplates ==) (== NextID: 19 ==)
class NodeTemplate {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#nodeTemplate for
  /// node templates.
  core.String kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// Labels to use for node affinity, which will be used in instance
  /// scheduling.
  core.Map<core.String, core.String> nodeAffinityLabels;

  /// The node type to use for nodes group that are created from this template.
  core.String nodeType;

  /// The flexible properties of the desired node type. Node groups that use
  /// this node template will create nodes of a type that matches these
  /// properties.
  ///
  /// This field is mutually exclusive with the node_type property; you can only
  /// define one or the other, but not both.
  NodeTemplateNodeTypeFlexibility nodeTypeFlexibility;

  /// [Output Only] The name of the region where the node template resides, such
  /// as us-central1.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Sets the binding properties for the physical server. Valid values include:
  /// - [Default] RESTART_NODE_ON_ANY_SERVER: Restarts VMs on any available
  /// physical server
  /// - RESTART_NODE_ON_MINIMAL_SERVER: Restarts VMs on the same physical server
  /// whenever possible
  ///
  /// See Sole-tenant node options for more information.
  ServerBinding serverBinding;

  /// [Output Only] The status of the node template. One of the following
  /// values: CREATING, READY, and DELETING.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String status;

  /// [Output Only] An optional, human-readable explanation of the status.
  core.String statusMessage;

  NodeTemplate();

  NodeTemplate.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("nodeAffinityLabels")) {
      nodeAffinityLabels = (_json["nodeAffinityLabels"] as core.Map)
          .cast<core.String, core.String>();
    }
    if (_json.containsKey("nodeType")) {
      nodeType = _json["nodeType"];
    }
    if (_json.containsKey("nodeTypeFlexibility")) {
      nodeTypeFlexibility = new NodeTemplateNodeTypeFlexibility.fromJson(
          _json["nodeTypeFlexibility"]);
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("serverBinding")) {
      serverBinding = new ServerBinding.fromJson(_json["serverBinding"]);
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusMessage")) {
      statusMessage = _json["statusMessage"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (nodeAffinityLabels != null) {
      _json["nodeAffinityLabels"] = nodeAffinityLabels;
    }
    if (nodeType != null) {
      _json["nodeType"] = nodeType;
    }
    if (nodeTypeFlexibility != null) {
      _json["nodeTypeFlexibility"] = (nodeTypeFlexibility).toJson();
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (serverBinding != null) {
      _json["serverBinding"] = (serverBinding).toJson();
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusMessage != null) {
      _json["statusMessage"] = statusMessage;
    }
    return _json;
  }
}

class NodeTemplateAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTemplateAggregatedListWarningData();

  NodeTemplateAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeTemplateAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTemplateAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTemplateAggregatedListWarning();

  NodeTemplateAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeTemplateAggregatedListWarningData>((value) =>
              new NodeTemplateAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NodeTemplateAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeTemplatesScopedList resources.
  core.Map<core.String, NodeTemplatesScopedList> items;

  /// [Output Only] Type of resource.Always compute#nodeTemplateAggregatedList
  /// for aggregated lists of node templates.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeTemplateAggregatedListWarning warning;

  NodeTemplateAggregatedList();

  NodeTemplateAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, NodeTemplatesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new NodeTemplatesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new NodeTemplateAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<NodeTemplatesScopedList, core.Map<core.String, core.Object>>(
              items, (NodeTemplatesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NodeTemplateListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTemplateListWarningData();

  NodeTemplateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeTemplateListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTemplateListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTemplateListWarning();

  NodeTemplateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeTemplateListWarningData>(
              (value) => new NodeTemplateListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of node templates.
class NodeTemplateList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeTemplate resources.
  core.List<NodeTemplate> items;

  /// [Output Only] Type of resource.Always compute#nodeTemplateList for lists
  /// of node templates.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeTemplateListWarning warning;

  NodeTemplateList();

  NodeTemplateList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<NodeTemplate>((value) => new NodeTemplate.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NodeTemplateListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NodeTemplateNodeTypeFlexibility {
  core.String cpus;
  core.String localSsd;
  core.String memory;

  NodeTemplateNodeTypeFlexibility();

  NodeTemplateNodeTypeFlexibility.fromJson(core.Map _json) {
    if (_json.containsKey("cpus")) {
      cpus = _json["cpus"];
    }
    if (_json.containsKey("localSsd")) {
      localSsd = _json["localSsd"];
    }
    if (_json.containsKey("memory")) {
      memory = _json["memory"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (cpus != null) {
      _json["cpus"] = cpus;
    }
    if (localSsd != null) {
      _json["localSsd"] = localSsd;
    }
    if (memory != null) {
      _json["memory"] = memory;
    }
    return _json;
  }
}

class NodeTemplatesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTemplatesScopedListWarningData();

  NodeTemplatesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the node templates
/// list is empty.
class NodeTemplatesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTemplatesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTemplatesScopedListWarning();

  NodeTemplatesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeTemplatesScopedListWarningData>(
              (value) => new NodeTemplatesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NodeTemplatesScopedList {
  /// [Output Only] A list of node templates contained in this scope.
  core.List<NodeTemplate> nodeTemplates;

  /// [Output Only] An informational warning that appears when the node
  /// templates list is empty.
  NodeTemplatesScopedListWarning warning;

  NodeTemplatesScopedList();

  NodeTemplatesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("nodeTemplates")) {
      nodeTemplates = (_json["nodeTemplates"] as core.List)
          .map<NodeTemplate>((value) => new NodeTemplate.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new NodeTemplatesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (nodeTemplates != null) {
      _json["nodeTemplates"] =
          nodeTemplates.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represent a sole-tenant Node Type resource.
///
/// Each node within a node group must have a node type. A node type specifies
/// the total amount of cores and memory for that node. Currently, the only
/// available node type is n1-node-96-624 node type that has 96 vCPUs and 624 GB
/// of memory, available in multiple zones. For more information read Node
/// types. (== resource_for {$api_version}.nodeTypes ==)
class NodeType {
  /// [Output Only] The CPU platform used by this node type.
  core.String cpuPlatform;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this node type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional textual description of the resource.
  core.String description;

  /// [Output Only] The number of virtual CPUs that are available to the node
  /// type.
  core.int guestCpus;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#nodeType for node
  /// types.
  core.String kind;

  /// [Output Only] Local SSD available to the node type, defined in GB.
  core.int localSsdGb;

  /// [Output Only] The amount of physical memory available to the node type,
  /// defined in MB.
  core.int memoryMb;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The name of the zone where the node type resides, such as
  /// us-central1-a.
  core.String zone;

  NodeType();

  NodeType.fromJson(core.Map _json) {
    if (_json.containsKey("cpuPlatform")) {
      cpuPlatform = _json["cpuPlatform"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("guestCpus")) {
      guestCpus = _json["guestCpus"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("localSsdGb")) {
      localSsdGb = _json["localSsdGb"];
    }
    if (_json.containsKey("memoryMb")) {
      memoryMb = _json["memoryMb"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (cpuPlatform != null) {
      _json["cpuPlatform"] = cpuPlatform;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (guestCpus != null) {
      _json["guestCpus"] = guestCpus;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (localSsdGb != null) {
      _json["localSsdGb"] = localSsdGb;
    }
    if (memoryMb != null) {
      _json["memoryMb"] = memoryMb;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class NodeTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTypeAggregatedListWarningData();

  NodeTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTypeAggregatedListWarning();

  NodeTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeTypeAggregatedListWarningData>(
              (value) => new NodeTypeAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NodeTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeTypesScopedList resources.
  core.Map<core.String, NodeTypesScopedList> items;

  /// [Output Only] Type of resource.Always compute#nodeTypeAggregatedList for
  /// aggregated lists of node types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeTypeAggregatedListWarning warning;

  NodeTypeAggregatedList();

  NodeTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, NodeTypesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new NodeTypesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NodeTypeAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<NodeTypesScopedList, core.Map<core.String, core.Object>>(
              items, (NodeTypesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NodeTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTypeListWarningData();

  NodeTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTypeListWarning();

  NodeTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeTypeListWarningData>(
              (value) => new NodeTypeListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of node types.
class NodeTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeType resources.
  core.List<NodeType> items;

  /// [Output Only] Type of resource.Always compute#nodeTypeList for lists of
  /// node types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeTypeListWarning warning;

  NodeTypeList();

  NodeTypeList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<NodeType>((value) => new NodeType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new NodeTypeListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class NodeTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTypesScopedListWarningData();

  NodeTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the node types list
/// is empty.
class NodeTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTypesScopedListWarning();

  NodeTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<NodeTypesScopedListWarningData>(
              (value) => new NodeTypesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class NodeTypesScopedList {
  /// [Output Only] A list of node types contained in this scope.
  core.List<NodeType> nodeTypes;

  /// [Output Only] An informational warning that appears when the node types
  /// list is empty.
  NodeTypesScopedListWarning warning;

  NodeTypesScopedList();

  NodeTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("nodeTypes")) {
      nodeTypes = (_json["nodeTypes"] as core.List)
          .map<NodeType>((value) => new NodeType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new NodeTypesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (nodeTypes != null) {
      _json["nodeTypes"] = nodeTypes.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class OperationErrorErrors {
  /// [Output Only] The error type identifier for this error.
  core.String code;

  /// [Output Only] Indicates the field in the request that caused the error.
  /// This property is optional.
  core.String location;

  /// [Output Only] An optional, human-readable error message.
  core.String message;

  OperationErrorErrors();

  OperationErrorErrors.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("location")) {
      location = _json["location"];
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (location != null) {
      _json["location"] = location;
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// [Output Only] If errors are generated during processing of the operation,
/// this field will be populated.
class OperationError {
  /// [Output Only] The array of errors encountered while processing this
  /// operation.
  core.List<OperationErrorErrors> errors;

  OperationError();

  OperationError.fromJson(core.Map _json) {
    if (_json.containsKey("errors")) {
      errors = (_json["errors"] as core.List)
          .map<OperationErrorErrors>(
              (value) => new OperationErrorErrors.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (errors != null) {
      _json["errors"] = errors.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class OperationWarningsData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationWarningsData();

  OperationWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

class OperationWarnings {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationWarningsData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationWarnings();

  OperationWarnings.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<OperationWarningsData>(
              (value) => new OperationWarningsData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Represents an Operation resource.
///
/// Google Compute Engine has three Operation resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/globalOperations) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionOperations) *
/// [Zonal](/compute/docs/reference/rest/{$api_version}/zoneOperations)
///
/// You can use an operation resource to manage asynchronous API requests. For
/// more information, read Handling API responses.
///
/// Operations can be global, regional or zonal.
/// - For global operations, use the `globalOperations` resource.
/// - For regional operations, use the `regionOperations` resource.
/// - For zonal operations, use the `zonalOperations` resource.
///
/// For more information, read  Global, Regional, and Zonal Resources. (==
/// resource_for {$api_version}.globalOperations ==) (== resource_for
/// {$api_version}.regionOperations ==) (== resource_for
/// {$api_version}.zoneOperations ==)
class Operation {
  /// [Output Only] The value of `requestId` if you provided it in the request.
  /// Not present otherwise.
  core.String clientOperationId;

  /// [Deprecated] This field is deprecated.
  core.String creationTimestamp;

  /// [Output Only] A textual description of the operation, which is set when
  /// the operation is created.
  core.String description;

  /// [Output Only] The time that this operation was completed. This value is in
  /// RFC3339 text format.
  core.String endTime;

  /// [Output Only] If errors are generated during processing of the operation,
  /// this field will be populated.
  OperationError error;

  /// [Output Only] If the operation fails, this field contains the HTTP error
  /// message that was returned, such as `NOT FOUND`.
  core.String httpErrorMessage;

  /// [Output Only] If the operation fails, this field contains the HTTP error
  /// status code that was returned. For example, a `404` means the resource was
  /// not found.
  core.int httpErrorStatusCode;

  /// [Output Only] The unique identifier for the operation. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The time that this operation was requested. This value is in
  /// RFC3339 text format.
  core.String insertTime;

  /// [Output Only] Type of the resource. Always `compute#operation` for
  /// Operation resources.
  core.String kind;

  /// [Output Only] Name of the operation.
  core.String name;

  /// [Output Only] The type of operation, such as `insert`, `update`, or
  /// `delete`, and so on.
  core.String operationType;

  /// [Output Only] An optional progress indicator that ranges from 0 to 100.
  /// There is no requirement that this be linear or support any granularity of
  /// operations. This should not be used to guess when the operation will be
  /// complete. This number should monotonically increase as the operation
  /// progresses.
  core.int progress;

  /// [Output Only] The URL of the region where the operation resides. Only
  /// applicable when performing regional operations.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The time that this operation was started by the server. This
  /// value is in RFC3339 text format.
  core.String startTime;

  /// [Output Only] The status of the operation, which can be one of the
  /// following: `PENDING`, `RUNNING`, or `DONE`.
  /// Possible string values are:
  /// - "DONE"
  /// - "PENDING"
  /// - "RUNNING"
  core.String status;

  /// [Output Only] An optional textual description of the current status of the
  /// operation.
  core.String statusMessage;

  /// [Output Only] The unique target ID, which identifies a specific
  /// incarnation of the target resource.
  core.String targetId;

  /// [Output Only] The URL of the resource that the operation modifies. For
  /// operations related to creating a snapshot, this points to the persistent
  /// disk that the snapshot was created from.
  core.String targetLink;

  /// [Output Only] User who requested the operation, for example:
  /// `user@example.com`.
  core.String user;

  /// [Output Only] If warning messages are generated during processing of the
  /// operation, this field will be populated.
  core.List<OperationWarnings> warnings;

  /// [Output Only] The URL of the zone where the operation resides. Only
  /// applicable when performing per-zone operations.
  core.String zone;

  Operation();

  Operation.fromJson(core.Map _json) {
    if (_json.containsKey("clientOperationId")) {
      clientOperationId = _json["clientOperationId"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("endTime")) {
      endTime = _json["endTime"];
    }
    if (_json.containsKey("error")) {
      error = new OperationError.fromJson(_json["error"]);
    }
    if (_json.containsKey("httpErrorMessage")) {
      httpErrorMessage = _json["httpErrorMessage"];
    }
    if (_json.containsKey("httpErrorStatusCode")) {
      httpErrorStatusCode = _json["httpErrorStatusCode"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("insertTime")) {
      insertTime = _json["insertTime"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("operationType")) {
      operationType = _json["operationType"];
    }
    if (_json.containsKey("progress")) {
      progress = _json["progress"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("startTime")) {
      startTime = _json["startTime"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("statusMessage")) {
      statusMessage = _json["statusMessage"];
    }
    if (_json.containsKey("targetId")) {
      targetId = _json["targetId"];
    }
    if (_json.containsKey("targetLink")) {
      targetLink = _json["targetLink"];
    }
    if (_json.containsKey("user")) {
      user = _json["user"];
    }
    if (_json.containsKey("warnings")) {
      warnings = (_json["warnings"] as core.List)
          .map<OperationWarnings>(
              (value) => new OperationWarnings.fromJson(value))
          .toList();
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (clientOperationId != null) {
      _json["clientOperationId"] = clientOperationId;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (endTime != null) {
      _json["endTime"] = endTime;
    }
    if (error != null) {
      _json["error"] = (error).toJson();
    }
    if (httpErrorMessage != null) {
      _json["httpErrorMessage"] = httpErrorMessage;
    }
    if (httpErrorStatusCode != null) {
      _json["httpErrorStatusCode"] = httpErrorStatusCode;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (insertTime != null) {
      _json["insertTime"] = insertTime;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (operationType != null) {
      _json["operationType"] = operationType;
    }
    if (progress != null) {
      _json["progress"] = progress;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (startTime != null) {
      _json["startTime"] = startTime;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (statusMessage != null) {
      _json["statusMessage"] = statusMessage;
    }
    if (targetId != null) {
      _json["targetId"] = targetId;
    }
    if (targetLink != null) {
      _json["targetLink"] = targetLink;
    }
    if (user != null) {
      _json["user"] = user;
    }
    if (warnings != null) {
      _json["warnings"] = warnings.map((value) => (value).toJson()).toList();
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class OperationAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationAggregatedListWarningData();

  OperationAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class OperationAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationAggregatedListWarning();

  OperationAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<OperationAggregatedListWarningData>(
              (value) => new OperationAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class OperationAggregatedList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A map of scoped operation lists.
  core.Map<core.String, OperationsScopedList> items;

  /// [Output Only] Type of resource. Always `compute#operationAggregatedList`
  /// for aggregated lists of operations.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than `maxResults`, use
  /// the `nextPageToken` as a value for the query parameter `pageToken` in the
  /// next list request. Subsequent list requests will have their own
  /// `nextPageToken` to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  OperationAggregatedListWarning warning;

  OperationAggregatedList();

  OperationAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, OperationsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new OperationsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new OperationAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<OperationsScopedList, core.Map<core.String, core.Object>>(
              items, (OperationsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class OperationListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationListWarningData();

  OperationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class OperationListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationListWarning();

  OperationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<OperationListWarningData>(
              (value) => new OperationListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Operation resources.
class OperationList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of Operation resources.
  core.List<Operation> items;

  /// [Output Only] Type of resource. Always `compute#operations` for Operations
  /// resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than `maxResults`, use
  /// the `nextPageToken` as a value for the query parameter `pageToken` in the
  /// next list request. Subsequent list requests will have their own
  /// `nextPageToken` to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  OperationListWarning warning;

  OperationList();

  OperationList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Operation>((value) => new Operation.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new OperationListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class OperationsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationsScopedListWarningData();

  OperationsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of operations
/// when the list is empty.
class OperationsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationsScopedListWarning();

  OperationsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<OperationsScopedListWarningData>(
              (value) => new OperationsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class OperationsScopedList {
  /// [Output Only] A list of operations contained in this scope.
  core.List<Operation> operations;

  /// [Output Only] Informational warning which replaces the list of operations
  /// when the list is empty.
  OperationsScopedListWarning warning;

  OperationsScopedList();

  OperationsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("operations")) {
      operations = (_json["operations"] as core.List)
          .map<Operation>((value) => new Operation.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new OperationsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (operations != null) {
      _json["operations"] =
          operations.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Settings controlling the eviction of unhealthy hosts from the load balancing
/// pool for the backend service.
class OutlierDetection {
  /// The base time that a host is ejected for. The real ejection time is equal
  /// to the base ejection time multiplied by the number of times the host has
  /// been ejected. Defaults to 30000ms or 30s.
  Duration baseEjectionTime;

  /// Number of errors before a host is ejected from the connection pool. When
  /// the backend host is accessed over HTTP, a 5xx return code qualifies as an
  /// error. Defaults to 5.
  core.int consecutiveErrors;

  /// The number of consecutive gateway failures (502, 503, 504 status or
  /// connection errors that are mapped to one of those status codes) before a
  /// consecutive gateway failure ejection occurs. Defaults to 3.
  core.int consecutiveGatewayFailure;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through consecutive 5xx. This setting can be used to
  /// disable ejection or to ramp it up slowly. Defaults to 0.
  core.int enforcingConsecutiveErrors;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through consecutive gateway failures. This setting can
  /// be used to disable ejection or to ramp it up slowly. Defaults to 100.
  core.int enforcingConsecutiveGatewayFailure;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through success rate statistics. This setting can be
  /// used to disable ejection or to ramp it up slowly. Defaults to 100.
  core.int enforcingSuccessRate;

  /// Time interval between ejection analysis sweeps. This can result in both
  /// new ejections as well as hosts being returned to service. Defaults to 1
  /// second.
  Duration interval;

  /// Maximum percentage of hosts in the load balancing pool for the backend
  /// service that can be ejected. Defaults to 50%.
  core.int maxEjectionPercent;

  /// The number of hosts in a cluster that must have enough request volume to
  /// detect success rate outliers. If the number of hosts is less than this
  /// setting, outlier detection via success rate statistics is not performed
  /// for any host in the cluster. Defaults to 5.
  core.int successRateMinimumHosts;

  /// The minimum number of total requests that must be collected in one
  /// interval (as defined by the interval duration above) to include this host
  /// in success rate based outlier detection. If the volume is lower than this
  /// setting, outlier detection via success rate statistics is not performed
  /// for that host. Defaults to 100.
  core.int successRateRequestVolume;

  /// This factor is used to determine the ejection threshold for success rate
  /// outlier ejection. The ejection threshold is the difference between the
  /// mean success rate, and the product of this factor and the standard
  /// deviation of the mean success rate: mean - (stdev *
  /// success_rate_stdev_factor). This factor is divided by a thousand to get a
  /// double. That is, if the desired factor is 1.9, the runtime value should be
  /// 1900. Defaults to 1900.
  core.int successRateStdevFactor;

  OutlierDetection();

  OutlierDetection.fromJson(core.Map _json) {
    if (_json.containsKey("baseEjectionTime")) {
      baseEjectionTime = new Duration.fromJson(_json["baseEjectionTime"]);
    }
    if (_json.containsKey("consecutiveErrors")) {
      consecutiveErrors = _json["consecutiveErrors"];
    }
    if (_json.containsKey("consecutiveGatewayFailure")) {
      consecutiveGatewayFailure = _json["consecutiveGatewayFailure"];
    }
    if (_json.containsKey("enforcingConsecutiveErrors")) {
      enforcingConsecutiveErrors = _json["enforcingConsecutiveErrors"];
    }
    if (_json.containsKey("enforcingConsecutiveGatewayFailure")) {
      enforcingConsecutiveGatewayFailure =
          _json["enforcingConsecutiveGatewayFailure"];
    }
    if (_json.containsKey("enforcingSuccessRate")) {
      enforcingSuccessRate = _json["enforcingSuccessRate"];
    }
    if (_json.containsKey("interval")) {
      interval = new Duration.fromJson(_json["interval"]);
    }
    if (_json.containsKey("maxEjectionPercent")) {
      maxEjectionPercent = _json["maxEjectionPercent"];
    }
    if (_json.containsKey("successRateMinimumHosts")) {
      successRateMinimumHosts = _json["successRateMinimumHosts"];
    }
    if (_json.containsKey("successRateRequestVolume")) {
      successRateRequestVolume = _json["successRateRequestVolume"];
    }
    if (_json.containsKey("successRateStdevFactor")) {
      successRateStdevFactor = _json["successRateStdevFactor"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (baseEjectionTime != null) {
      _json["baseEjectionTime"] = (baseEjectionTime).toJson();
    }
    if (consecutiveErrors != null) {
      _json["consecutiveErrors"] = consecutiveErrors;
    }
    if (consecutiveGatewayFailure != null) {
      _json["consecutiveGatewayFailure"] = consecutiveGatewayFailure;
    }
    if (enforcingConsecutiveErrors != null) {
      _json["enforcingConsecutiveErrors"] = enforcingConsecutiveErrors;
    }
    if (enforcingConsecutiveGatewayFailure != null) {
      _json["enforcingConsecutiveGatewayFailure"] =
          enforcingConsecutiveGatewayFailure;
    }
    if (enforcingSuccessRate != null) {
      _json["enforcingSuccessRate"] = enforcingSuccessRate;
    }
    if (interval != null) {
      _json["interval"] = (interval).toJson();
    }
    if (maxEjectionPercent != null) {
      _json["maxEjectionPercent"] = maxEjectionPercent;
    }
    if (successRateMinimumHosts != null) {
      _json["successRateMinimumHosts"] = successRateMinimumHosts;
    }
    if (successRateRequestVolume != null) {
      _json["successRateRequestVolume"] = successRateRequestVolume;
    }
    if (successRateStdevFactor != null) {
      _json["successRateStdevFactor"] = successRateStdevFactor;
    }
    return _json;
  }
}

/// Represents a PacketMirroring resource.
class PacketMirroring {
  /// The Forwarding Rule resource of type loadBalancingScheme=INTERNAL that
  /// will be used as collector for mirrored traffic. The specified forwarding
  /// rule must have isMirroringCollector set to true.
  PacketMirroringForwardingRuleInfo collectorIlb;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Indicates whether or not this packet mirroring takes effect. If set to
  /// FALSE, this packet mirroring policy will not be enforced on the network.
  ///
  /// The default is TRUE.
  /// Possible string values are:
  /// - "FALSE"
  /// - "TRUE"
  core.String enable;

  /// Filter for mirrored traffic. If unspecified, all traffic is mirrored.
  PacketMirroringFilter filter;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#packetMirroring for
  /// packet mirrorings.
  core.String kind;

  /// PacketMirroring mirroredResourceInfos. MirroredResourceInfo specifies a
  /// set of mirrored VM instances, subnetworks and/or tags for which traffic
  /// from/to all VM instances will be mirrored.
  PacketMirroringMirroredResourceInfo mirroredResources;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the mirrored VPC network. Only packets in this network will be
  /// mirrored. All mirrored VMs should have a NIC in the given network. All
  /// mirrored subnetworks should belong to the given network.
  PacketMirroringNetworkInfo network;

  /// The priority of applying this configuration. Priority is used to break
  /// ties in cases where there is more than one matching rule. In the case of
  /// two rules that apply for a given Instance, the one with the
  /// lowest-numbered priority value wins.
  ///
  /// Default value is 1000. Valid range is 0 through 65535.
  core.int priority;

  /// [Output Only] URI of the region where the packetMirroring resides.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  PacketMirroring();

  PacketMirroring.fromJson(core.Map _json) {
    if (_json.containsKey("collectorIlb")) {
      collectorIlb =
          new PacketMirroringForwardingRuleInfo.fromJson(_json["collectorIlb"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enable")) {
      enable = _json["enable"];
    }
    if (_json.containsKey("filter")) {
      filter = new PacketMirroringFilter.fromJson(_json["filter"]);
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("mirroredResources")) {
      mirroredResources = new PacketMirroringMirroredResourceInfo.fromJson(
          _json["mirroredResources"]);
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = new PacketMirroringNetworkInfo.fromJson(_json["network"]);
    }
    if (_json.containsKey("priority")) {
      priority = _json["priority"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (collectorIlb != null) {
      _json["collectorIlb"] = (collectorIlb).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enable != null) {
      _json["enable"] = enable;
    }
    if (filter != null) {
      _json["filter"] = (filter).toJson();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (mirroredResources != null) {
      _json["mirroredResources"] = (mirroredResources).toJson();
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = (network).toJson();
    }
    if (priority != null) {
      _json["priority"] = priority;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class PacketMirroringAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  PacketMirroringAggregatedListWarningData();

  PacketMirroringAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class PacketMirroringAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<PacketMirroringAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  PacketMirroringAggregatedListWarning();

  PacketMirroringAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<PacketMirroringAggregatedListWarningData>((value) =>
              new PacketMirroringAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of packetMirrorings.
class PacketMirroringAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of PacketMirroring resources.
  core.Map<core.String, PacketMirroringsScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  PacketMirroringAggregatedListWarning warning;

  PacketMirroringAggregatedList();

  PacketMirroringAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, PacketMirroringsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new PacketMirroringsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new PacketMirroringAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<PacketMirroringsScopedList,
              core.Map<core.String, core.Object>>(
          items, (PacketMirroringsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class PacketMirroringFilter {
  /// Protocols that apply as filter on mirrored traffic. If no protocols are
  /// specified, all traffic that matches the specified CIDR ranges is mirrored.
  /// If neither cidrRanges nor IPProtocols is specified, all traffic is
  /// mirrored.
  core.List<core.String> IPProtocols;

  /// IP CIDR ranges that apply as filter on the source (ingress) or destination
  /// (egress) IP in the IP header. Only IPv4 is supported. If no ranges are
  /// specified, all traffic that matches the specified IPProtocols is mirrored.
  /// If neither cidrRanges nor IPProtocols is specified, all traffic is
  /// mirrored.
  core.List<core.String> cidrRanges;

  PacketMirroringFilter();

  PacketMirroringFilter.fromJson(core.Map _json) {
    if (_json.containsKey("IPProtocols")) {
      IPProtocols = (_json["IPProtocols"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("cidrRanges")) {
      cidrRanges = (_json["cidrRanges"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (IPProtocols != null) {
      _json["IPProtocols"] = IPProtocols;
    }
    if (cidrRanges != null) {
      _json["cidrRanges"] = cidrRanges;
    }
    return _json;
  }
}

class PacketMirroringForwardingRuleInfo {
  /// [Output Only] Unique identifier for the forwarding rule; defined by the
  /// server.
  core.String canonicalUrl;

  /// Resource URL to the forwarding rule representing the ILB configured as
  /// destination of the mirrored traffic.
  core.String url;

  PacketMirroringForwardingRuleInfo();

  PacketMirroringForwardingRuleInfo.fromJson(core.Map _json) {
    if (_json.containsKey("canonicalUrl")) {
      canonicalUrl = _json["canonicalUrl"];
    }
    if (_json.containsKey("url")) {
      url = _json["url"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (canonicalUrl != null) {
      _json["canonicalUrl"] = canonicalUrl;
    }
    if (url != null) {
      _json["url"] = url;
    }
    return _json;
  }
}

class PacketMirroringListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  PacketMirroringListWarningData();

  PacketMirroringListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class PacketMirroringListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<PacketMirroringListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  PacketMirroringListWarning();

  PacketMirroringListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<PacketMirroringListWarningData>(
              (value) => new PacketMirroringListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of PacketMirroring resources.
class PacketMirroringList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of PacketMirroring resources.
  core.List<PacketMirroring> items;

  /// [Output Only] Type of resource. Always compute#packetMirroring for
  /// packetMirrorings.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  PacketMirroringListWarning warning;

  PacketMirroringList();

  PacketMirroringList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<PacketMirroring>((value) => new PacketMirroring.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new PacketMirroringListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class PacketMirroringMirroredResourceInfo {
  /// A set of virtual machine instances that are being mirrored. They must live
  /// in zones contained in the same region as this packetMirroring.
  ///
  /// Note that this config will apply only to those network interfaces of the
  /// Instances that belong to the network specified in this packetMirroring.
  ///
  /// You may specify a maximum of 50 Instances.
  core.List<PacketMirroringMirroredResourceInfoInstanceInfo> instances;

  /// A set of subnetworks for which traffic from/to all VM instances will be
  /// mirrored. They must live in the same region as this packetMirroring.
  ///
  /// You may specify a maximum of 5 subnetworks.
  core.List<PacketMirroringMirroredResourceInfoSubnetInfo> subnetworks;

  /// A set of mirrored tags. Traffic from/to all VM instances that have one or
  /// more of these tags will be mirrored.
  core.List<core.String> tags;

  PacketMirroringMirroredResourceInfo();

  PacketMirroringMirroredResourceInfo.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List)
          .map<PacketMirroringMirroredResourceInfoInstanceInfo>((value) =>
              new PacketMirroringMirroredResourceInfoInstanceInfo.fromJson(
                  value))
          .toList();
    }
    if (_json.containsKey("subnetworks")) {
      subnetworks = (_json["subnetworks"] as core.List)
          .map<PacketMirroringMirroredResourceInfoSubnetInfo>((value) =>
              new PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(value))
          .toList();
    }
    if (_json.containsKey("tags")) {
      tags = (_json["tags"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    if (subnetworks != null) {
      _json["subnetworks"] =
          subnetworks.map((value) => (value).toJson()).toList();
    }
    if (tags != null) {
      _json["tags"] = tags;
    }
    return _json;
  }
}

class PacketMirroringMirroredResourceInfoInstanceInfo {
  /// [Output Only] Unique identifier for the instance; defined by the server.
  core.String canonicalUrl;

  /// Resource URL to the virtual machine instance which is being mirrored.
  core.String url;

  PacketMirroringMirroredResourceInfoInstanceInfo();

  PacketMirroringMirroredResourceInfoInstanceInfo.fromJson(core.Map _json) {
    if (_json.containsKey("canonicalUrl")) {
      canonicalUrl = _json["canonicalUrl"];
    }
    if (_json.containsKey("url")) {
      url = _json["url"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (canonicalUrl != null) {
      _json["canonicalUrl"] = canonicalUrl;
    }
    if (url != null) {
      _json["url"] = url;
    }
    return _json;
  }
}

class PacketMirroringMirroredResourceInfoSubnetInfo {
  /// [Output Only] Unique identifier for the subnetwork; defined by the server.
  core.String canonicalUrl;

  /// Resource URL to the subnetwork for which traffic from/to all VM instances
  /// will be mirrored.
  core.String url;

  PacketMirroringMirroredResourceInfoSubnetInfo();

  PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(core.Map _json) {
    if (_json.containsKey("canonicalUrl")) {
      canonicalUrl = _json["canonicalUrl"];
    }
    if (_json.containsKey("url")) {
      url = _json["url"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (canonicalUrl != null) {
      _json["canonicalUrl"] = canonicalUrl;
    }
    if (url != null) {
      _json["url"] = url;
    }
    return _json;
  }
}

class PacketMirroringNetworkInfo {
  /// [Output Only] Unique identifier for the network; defined by the server.
  core.String canonicalUrl;

  /// URL of the network resource.
  core.String url;

  PacketMirroringNetworkInfo();

  PacketMirroringNetworkInfo.fromJson(core.Map _json) {
    if (_json.containsKey("canonicalUrl")) {
      canonicalUrl = _json["canonicalUrl"];
    }
    if (_json.containsKey("url")) {
      url = _json["url"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (canonicalUrl != null) {
      _json["canonicalUrl"] = canonicalUrl;
    }
    if (url != null) {
      _json["url"] = url;
    }
    return _json;
  }
}

class PacketMirroringsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  PacketMirroringsScopedListWarningData();

  PacketMirroringsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of packetMirrorings when the
/// list is empty.
class PacketMirroringsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<PacketMirroringsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  PacketMirroringsScopedListWarning();

  PacketMirroringsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<PacketMirroringsScopedListWarningData>((value) =>
              new PacketMirroringsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class PacketMirroringsScopedList {
  /// A list of packetMirrorings contained in this scope.
  core.List<PacketMirroring> packetMirrorings;

  /// Informational warning which replaces the list of packetMirrorings when the
  /// list is empty.
  PacketMirroringsScopedListWarning warning;

  PacketMirroringsScopedList();

  PacketMirroringsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("packetMirrorings")) {
      packetMirrorings = (_json["packetMirrorings"] as core.List)
          .map<PacketMirroring>((value) => new PacketMirroring.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new PacketMirroringsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (packetMirrorings != null) {
      _json["packetMirrorings"] =
          packetMirrorings.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A matcher for the path portion of the URL. The BackendService from the
/// longest-matched rule will serve the URL. If no rule was matched, the default
/// service will be used.
class PathMatcher {
  /// defaultRouteAction takes effect when none of the  pathRules or routeRules
  /// match. The load balancer performs advanced routing actions like URL
  /// rewrites, header transformations, etc. prior to forwarding the request to
  /// the selected backend. If defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be set. Conversely if
  /// defaultService is set, defaultRouteAction cannot contain any
  /// weightedBackendServices.
  /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
  HttpRouteAction defaultRouteAction;

  /// The full or partial URL to the BackendService resource. This will be used
  /// if none of the pathRules or routeRules defined by this PathMatcher are
  /// matched. For example, the following are all valid URLs to a BackendService
  /// resource:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/backendServices/backendService
  /// - compute/v1/projects/project/global/backendServices/backendService
  /// - global/backendServices/backendService  If defaultRouteAction is
  /// additionally specified, advanced routing actions like URL Rewrites, etc.
  /// take effect prior to sending the request to the backend. However, if
  /// defaultService is specified, defaultRouteAction cannot contain any
  /// weightedBackendServices. Conversely, if defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be specified.
  /// Only one of defaultService, defaultUrlRedirect  or
  /// defaultRouteAction.weightedBackendService must be set.
  /// Authorization requires one or more of the following Google IAM permissions
  /// on the specified resource default_service:
  /// - compute.backendBuckets.use
  /// - compute.backendServices.use
  core.String defaultService;

  /// When none of the specified pathRules or routeRules match, the request is
  /// redirected to a URL specified by defaultUrlRedirect.
  /// If defaultUrlRedirect is specified, defaultService or defaultRouteAction
  /// must not be set.
  HttpRedirectAction defaultUrlRedirect;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// HeaderAction specified here are applied after the matching HttpRouteRule
  /// HeaderAction and before the HeaderAction in the UrlMap
  HttpHeaderAction headerAction;

  /// The name to which this PathMatcher is referred by the HostRule.
  core.String name;

  /// The list of path rules. Use this list instead of routeRules when routing
  /// based on simple path matching is all that's required. The order by which
  /// path rules are specified does not matter. Matches are always done on the
  /// longest-path-first basis.
  /// For example: a pathRule with a path /a/b/c / *  will match before /a/b / *
  /// irrespective of the order in which those paths appear in this list.
  /// Within a given pathMatcher, only one of pathRules or routeRules must be
  /// set.
  core.List<PathRule> pathRules;

  /// The list of HTTP route rules. Use this list instead of pathRules when
  /// advanced route matching and routing actions are desired. routeRules are
  /// evaluated in order of priority, from the lowest to highest number.
  /// Within a given pathMatcher, you can set only one of pathRules or
  /// routeRules.
  core.List<HttpRouteRule> routeRules;

  PathMatcher();

  PathMatcher.fromJson(core.Map _json) {
    if (_json.containsKey("defaultRouteAction")) {
      defaultRouteAction =
          new HttpRouteAction.fromJson(_json["defaultRouteAction"]);
    }
    if (_json.containsKey("defaultService")) {
      defaultService = _json["defaultService"];
    }
    if (_json.containsKey("defaultUrlRedirect")) {
      defaultUrlRedirect =
          new HttpRedirectAction.fromJson(_json["defaultUrlRedirect"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("headerAction")) {
      headerAction = new HttpHeaderAction.fromJson(_json["headerAction"]);
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("pathRules")) {
      pathRules = (_json["pathRules"] as core.List)
          .map<PathRule>((value) => new PathRule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("routeRules")) {
      routeRules = (_json["routeRules"] as core.List)
          .map<HttpRouteRule>((value) => new HttpRouteRule.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (defaultRouteAction != null) {
      _json["defaultRouteAction"] = (defaultRouteAction).toJson();
    }
    if (defaultService != null) {
      _json["defaultService"] = defaultService;
    }
    if (defaultUrlRedirect != null) {
      _json["defaultUrlRedirect"] = (defaultUrlRedirect).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (headerAction != null) {
      _json["headerAction"] = (headerAction).toJson();
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (pathRules != null) {
      _json["pathRules"] = pathRules.map((value) => (value).toJson()).toList();
    }
    if (routeRules != null) {
      _json["routeRules"] =
          routeRules.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// A path-matching rule for a URL. If matched, will use the specified
/// BackendService to handle the traffic arriving at this URL.
class PathRule {
  /// The list of path patterns to match. Each must start with / and the only
  /// place a * is allowed is at the end following a /. The string fed to the
  /// path matcher does not include any text after the first ? or #, and those
  /// chars are not allowed here.
  core.List<core.String> paths;

  /// In response to a matching path, the load balancer performs advanced
  /// routing actions like URL rewrites, header transformations, etc. prior to
  /// forwarding the request to the selected backend. If routeAction specifies
  /// any  weightedBackendServices, service must not be set. Conversely if
  /// service is set, routeAction cannot contain any  weightedBackendServices.
  /// Only one of routeAction or urlRedirect must be set.
  HttpRouteAction routeAction;

  /// The full or partial URL of the backend service resource to which traffic
  /// is directed if this rule is matched. If routeAction is additionally
  /// specified, advanced routing actions like URL Rewrites, etc. take effect
  /// prior to sending the request to the backend. However, if service is
  /// specified, routeAction cannot contain any weightedBackendService s.
  /// Conversely, if routeAction specifies any  weightedBackendServices, service
  /// must not be specified.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  core.String service;

  /// When a path pattern is matched, the request is redirected to a URL
  /// specified by urlRedirect.
  /// If urlRedirect is specified, service or routeAction must not be set.
  HttpRedirectAction urlRedirect;

  PathRule();

  PathRule.fromJson(core.Map _json) {
    if (_json.containsKey("paths")) {
      paths = (_json["paths"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("routeAction")) {
      routeAction = new HttpRouteAction.fromJson(_json["routeAction"]);
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
    if (_json.containsKey("urlRedirect")) {
      urlRedirect = new HttpRedirectAction.fromJson(_json["urlRedirect"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (paths != null) {
      _json["paths"] = paths;
    }
    if (routeAction != null) {
      _json["routeAction"] = (routeAction).toJson();
    }
    if (service != null) {
      _json["service"] = service;
    }
    if (urlRedirect != null) {
      _json["urlRedirect"] = (urlRedirect).toJson();
    }
    return _json;
  }
}

class PerInstanceConfig {
  /// Fingerprint of this per-instance config. This field can be used in
  /// optimistic locking. It is ignored when inserting a per-instance config. An
  /// up-to-date fingerprint must be provided in order to update an existing
  /// per-instance config or the field needs to be unset.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The name of a per-instance config and its corresponding instance. Serves
  /// as a merge key during UpdatePerInstanceConfigs operations, that is, if a
  /// per-instance config with the same name exists then it will be updated,
  /// otherwise a new one will be created for the VM instance with the same
  /// name. An attempt to create a per-instance config for a VM instance that
  /// either doesn't exist or is not part of the group will result in an error.
  core.String name;

  PerInstanceConfig();

  PerInstanceConfig.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (name != null) {
      _json["name"] = name;
    }
    return _json;
  }
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
///
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members` to a single `role`. Members can be user accounts, service
/// accounts, Google groups, and domains (such as G Suite). A `role` is a named
/// list of permissions; each `role` can be an IAM predefined role or a
/// user-created custom role.
///
/// Optionally, a `binding` can specify a `condition`, which is a logical
/// expression that allows access to a resource only if the expression evaluates
/// to `true`. A condition can add constraints based on attributes of the
/// request, the resource, or both.
///
/// **JSON example:**
///
/// { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin",
/// "members": [ "user:mike@example.com", "group:admins@example.com",
/// "domain:google.com",
/// "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role":
/// "roles/resourcemanager.organizationViewer", "members":
/// ["user:eve@example.com"], "condition": { "title": "expirable access",
/// "description": "Does not grant access after Sep 2020", "expression":
/// "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
/// "BwWWja0YfJA=", "version": 3 }
///
/// **YAML example:**
///
/// bindings: - members: - user:mike@example.com - group:admins@example.com -
/// domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com
/// role: roles/resourcemanager.organizationAdmin - members: -
/// user:eve@example.com role: roles/resourcemanager.organizationViewer
/// condition: title: expirable access description: Does not grant access after
/// Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') -
/// etag: BwWWja0YfJA= - version: 3
///
/// For a description of IAM and its features, see the [IAM
/// documentation](https://cloud.google.com/iam/docs/).
class Policy {
  /// Specifies cloud audit logging configuration for this policy.
  core.List<AuditConfig> auditConfigs;

  /// Associates a list of `members` to a `role`. Optionally, may specify a
  /// `condition` that determines how and when the `bindings` are applied. Each
  /// of the `bindings` must contain at least one member.
  core.List<Binding> bindings;

  /// `etag` is used for optimistic concurrency control as a way to help prevent
  /// simultaneous updates of a policy from overwriting each other. It is
  /// strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the
  /// policy.
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag`
  /// field whenever you call `setIamPolicy`. If you omit this field, then IAM
  /// allows you to overwrite a version `3` policy with a version `1` policy,
  /// and all of the conditions in the version `3` policy are lost.
  core.String etag;
  core.List<core.int> get etagAsBytes {
    return convert.base64.decode(etag);
  }

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  core.bool iamOwned;

  /// If more than one rule is specified, the rules are applied in the following
  /// manner: - All matching LOG rules are always applied. - If any
  /// DENY/DENY_WITH_LOG rule matches, permission is denied. Logging will be
  /// applied if one or more matching rule requires logging. - Otherwise, if any
  /// ALLOW/ALLOW_WITH_LOG rule matches, permission is granted. Logging will be
  /// applied if one or more matching rule requires logging. - Otherwise, if no
  /// rule applies, permission is denied.
  core.List<Rule> rules;

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected.
  ///
  /// Any operation that affects conditional role bindings must specify version
  /// `3`. This requirement applies to the following operations:
  ///
  /// * Getting a policy that includes a conditional role binding * Adding a
  /// conditional role binding to a policy * Changing a conditional role binding
  /// in a policy * Removing any role binding, with or without a condition, from
  /// a policy that includes conditions
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag`
  /// field whenever you call `setIamPolicy`. If you omit this field, then IAM
  /// allows you to overwrite a version `3` policy with a version `1` policy,
  /// and all of the conditions in the version `3` policy are lost.
  ///
  /// If a policy does not include any conditions, operations on that policy may
  /// specify any valid version or leave the field unset.
  core.int version;

  Policy();

  Policy.fromJson(core.Map _json) {
    if (_json.containsKey("auditConfigs")) {
      auditConfigs = (_json["auditConfigs"] as core.List)
          .map<AuditConfig>((value) => new AuditConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("bindings")) {
      bindings = (_json["bindings"] as core.List)
          .map<Binding>((value) => new Binding.fromJson(value))
          .toList();
    }
    if (_json.containsKey("etag")) {
      etag = _json["etag"];
    }
    if (_json.containsKey("iamOwned")) {
      iamOwned = _json["iamOwned"];
    }
    if (_json.containsKey("rules")) {
      rules = (_json["rules"] as core.List)
          .map<Rule>((value) => new Rule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("version")) {
      version = _json["version"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (auditConfigs != null) {
      _json["auditConfigs"] =
          auditConfigs.map((value) => (value).toJson()).toList();
    }
    if (bindings != null) {
      _json["bindings"] = bindings.map((value) => (value).toJson()).toList();
    }
    if (etag != null) {
      _json["etag"] = etag;
    }
    if (iamOwned != null) {
      _json["iamOwned"] = iamOwned;
    }
    if (rules != null) {
      _json["rules"] = rules.map((value) => (value).toJson()).toList();
    }
    if (version != null) {
      _json["version"] = version;
    }
    return _json;
  }
}

class PreconfiguredWafSet {
  /// List of entities that are currently supported for WAF rules.
  core.List<WafExpressionSet> expressionSets;

  PreconfiguredWafSet();

  PreconfiguredWafSet.fromJson(core.Map _json) {
    if (_json.containsKey("expressionSets")) {
      expressionSets = (_json["expressionSets"] as core.List)
          .map<WafExpressionSet>(
              (value) => new WafExpressionSet.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (expressionSets != null) {
      _json["expressionSets"] =
          expressionSets.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// Represents a Project resource.
///
/// A project is used to organize resources in a Google Cloud Platform
/// environment. For more information, read about the  Resource Hierarchy. (==
/// resource_for {$api_version}.projects ==)
class Project {
  /// Metadata key/value pairs available to all instances contained in this
  /// project. See Custom metadata for more information.
  Metadata commonInstanceMetadata;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// This signifies the default network tier used for configuring resources of
  /// the project and can only take the following values: PREMIUM, STANDARD.
  /// Initially the default network tier is PREMIUM.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String defaultNetworkTier;

  /// [Output Only] Default service account used by VMs running in this project.
  core.String defaultServiceAccount;

  /// An optional textual description of the resource.
  core.String description;

  /// Restricted features enabled for use on this project.
  core.List<core.String> enabledFeatures;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server. This is not the project ID, and is just a unique ID
  /// used by Compute Engine to identify resources.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#project for projects.
  core.String kind;

  /// The project ID. For example: my-example-project. Use the project ID to
  /// make requests to Compute Engine.
  core.String name;

  /// [Output Only] Quotas assigned to this project.
  core.List<Quota> quotas;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// The naming prefix for daily usage reports and the Google Cloud Storage
  /// bucket where they are stored.
  UsageExportLocation usageExportLocation;

  /// [Output Only] The role this project has in a shared VPC configuration.
  /// Currently only HOST projects are differentiated.
  /// Possible string values are:
  /// - "HOST"
  /// - "UNSPECIFIED_XPN_PROJECT_STATUS"
  core.String xpnProjectStatus;

  Project();

  Project.fromJson(core.Map _json) {
    if (_json.containsKey("commonInstanceMetadata")) {
      commonInstanceMetadata =
          new Metadata.fromJson(_json["commonInstanceMetadata"]);
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("defaultNetworkTier")) {
      defaultNetworkTier = _json["defaultNetworkTier"];
    }
    if (_json.containsKey("defaultServiceAccount")) {
      defaultServiceAccount = _json["defaultServiceAccount"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enabledFeatures")) {
      enabledFeatures =
          (_json["enabledFeatures"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("quotas")) {
      quotas = (_json["quotas"] as core.List)
          .map<Quota>((value) => new Quota.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("usageExportLocation")) {
      usageExportLocation =
          new UsageExportLocation.fromJson(_json["usageExportLocation"]);
    }
    if (_json.containsKey("xpnProjectStatus")) {
      xpnProjectStatus = _json["xpnProjectStatus"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (commonInstanceMetadata != null) {
      _json["commonInstanceMetadata"] = (commonInstanceMetadata).toJson();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (defaultNetworkTier != null) {
      _json["defaultNetworkTier"] = defaultNetworkTier;
    }
    if (defaultServiceAccount != null) {
      _json["defaultServiceAccount"] = defaultServiceAccount;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enabledFeatures != null) {
      _json["enabledFeatures"] = enabledFeatures;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (quotas != null) {
      _json["quotas"] = quotas.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (usageExportLocation != null) {
      _json["usageExportLocation"] = (usageExportLocation).toJson();
    }
    if (xpnProjectStatus != null) {
      _json["xpnProjectStatus"] = xpnProjectStatus;
    }
    return _json;
  }
}

class ProjectsDisableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId xpnResource;

  ProjectsDisableXpnResourceRequest();

  ProjectsDisableXpnResourceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("xpnResource")) {
      xpnResource = new XpnResourceId.fromJson(_json["xpnResource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (xpnResource != null) {
      _json["xpnResource"] = (xpnResource).toJson();
    }
    return _json;
  }
}

class ProjectsEnableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId xpnResource;

  ProjectsEnableXpnResourceRequest();

  ProjectsEnableXpnResourceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("xpnResource")) {
      xpnResource = new XpnResourceId.fromJson(_json["xpnResource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (xpnResource != null) {
      _json["xpnResource"] = (xpnResource).toJson();
    }
    return _json;
  }
}

class ProjectsGetXpnResources {
  /// [Output Only] Type of resource. Always compute#projectsGetXpnResources for
  /// lists of service resources (a.k.a service projects)
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// Service resources (a.k.a service projects) attached to this project as
  /// their shared VPC host.
  core.List<XpnResourceId> resources;

  ProjectsGetXpnResources();

  ProjectsGetXpnResources.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("resources")) {
      resources = (_json["resources"] as core.List)
          .map<XpnResourceId>((value) => new XpnResourceId.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (resources != null) {
      _json["resources"] = resources.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class ProjectsListXpnHostsRequest {
  /// Optional organization ID managed by Cloud Resource Manager, for which to
  /// list shared VPC host projects. If not specified, the organization will be
  /// inferred from the project.
  core.String organization;

  ProjectsListXpnHostsRequest();

  ProjectsListXpnHostsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("organization")) {
      organization = _json["organization"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (organization != null) {
      _json["organization"] = organization;
    }
    return _json;
  }
}

class ProjectsSetDefaultNetworkTierRequest {
  /// Default network tier to be set.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String networkTier;

  ProjectsSetDefaultNetworkTierRequest();

  ProjectsSetDefaultNetworkTierRequest.fromJson(core.Map _json) {
    if (_json.containsKey("networkTier")) {
      networkTier = _json["networkTier"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (networkTier != null) {
      _json["networkTier"] = networkTier;
    }
    return _json;
  }
}

/// A quotas entry.
class Quota {
  /// [Output Only] Quota limit for this metric.
  core.double limit;

  /// [Output Only] Name of the quota metric.
  /// Possible string values are:
  /// - "AFFINITY_GROUPS"
  /// - "AUTOSCALERS"
  /// - "BACKEND_BUCKETS"
  /// - "BACKEND_SERVICES"
  /// - "C2_CPUS"
  /// - "COMMITMENTS"
  /// - "COMMITTED_C2_CPUS"
  /// - "COMMITTED_CPUS"
  /// - "COMMITTED_LICENSES"
  /// - "COMMITTED_LOCAL_SSD_TOTAL_GB"
  /// - "COMMITTED_N2D_CPUS"
  /// - "COMMITTED_N2_CPUS"
  /// - "COMMITTED_NVIDIA_K80_GPUS"
  /// - "COMMITTED_NVIDIA_P100_GPUS"
  /// - "COMMITTED_NVIDIA_P4_GPUS"
  /// - "COMMITTED_NVIDIA_T4_GPUS"
  /// - "COMMITTED_NVIDIA_V100_GPUS"
  /// - "CPUS"
  /// - "CPUS_ALL_REGIONS"
  /// - "DISKS_TOTAL_GB"
  /// - "EXTERNAL_VPN_GATEWAYS"
  /// - "FIREWALLS"
  /// - "FORWARDING_RULES"
  /// - "GLOBAL_INTERNAL_ADDRESSES"
  /// - "GPUS_ALL_REGIONS"
  /// - "HEALTH_CHECKS"
  /// - "IMAGES"
  /// - "INSTANCES"
  /// - "INSTANCE_GROUPS"
  /// - "INSTANCE_GROUP_MANAGERS"
  /// - "INSTANCE_TEMPLATES"
  /// - "INTERCONNECTS"
  /// - "INTERCONNECT_ATTACHMENTS_PER_REGION"
  /// - "INTERCONNECT_ATTACHMENTS_TOTAL_MBPS"
  /// - "INTERCONNECT_TOTAL_GBPS"
  /// - "INTERNAL_ADDRESSES"
  /// - "IN_PLACE_SNAPSHOTS"
  /// - "IN_USE_ADDRESSES"
  /// - "IN_USE_BACKUP_SCHEDULES"
  /// - "IN_USE_SNAPSHOT_SCHEDULES"
  /// - "LOCAL_SSD_TOTAL_GB"
  /// - "MACHINE_IMAGES"
  /// - "N2D_CPUS"
  /// - "N2_CPUS"
  /// - "NETWORKS"
  /// - "NETWORK_ENDPOINT_GROUPS"
  /// - "NODE_GROUPS"
  /// - "NODE_TEMPLATES"
  /// - "NVIDIA_K80_GPUS"
  /// - "NVIDIA_P100_GPUS"
  /// - "NVIDIA_P100_VWS_GPUS"
  /// - "NVIDIA_P4_GPUS"
  /// - "NVIDIA_P4_VWS_GPUS"
  /// - "NVIDIA_T4_GPUS"
  /// - "NVIDIA_T4_VWS_GPUS"
  /// - "NVIDIA_V100_GPUS"
  /// - "PACKET_MIRRORINGS"
  /// - "PREEMPTIBLE_CPUS"
  /// - "PREEMPTIBLE_LOCAL_SSD_GB"
  /// - "PREEMPTIBLE_NVIDIA_K80_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P4_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P4_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_T4_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_T4_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_V100_GPUS"
  /// - "PUBLIC_ADVERTISED_PREFIXES"
  /// - "PUBLIC_DELEGATED_PREFIXES"
  /// - "REGIONAL_AUTOSCALERS"
  /// - "REGIONAL_INSTANCE_GROUP_MANAGERS"
  /// - "RESERVATIONS"
  /// - "RESOURCE_POLICIES"
  /// - "ROUTERS"
  /// - "ROUTES"
  /// - "SECURITY_POLICIES"
  /// - "SECURITY_POLICY_CEVAL_RULES"
  /// - "SECURITY_POLICY_RULES"
  /// - "SNAPSHOTS"
  /// - "SSD_TOTAL_GB"
  /// - "SSL_CERTIFICATES"
  /// - "STATIC_ADDRESSES"
  /// - "STATIC_BYOIP_ADDRESSES"
  /// - "SUBNETWORKS"
  /// - "TARGET_HTTPS_PROXIES"
  /// - "TARGET_HTTP_PROXIES"
  /// - "TARGET_INSTANCES"
  /// - "TARGET_POOLS"
  /// - "TARGET_SSL_PROXIES"
  /// - "TARGET_TCP_PROXIES"
  /// - "TARGET_VPN_GATEWAYS"
  /// - "URL_MAPS"
  /// - "VPN_GATEWAYS"
  /// - "VPN_TUNNELS"
  core.String metric;

  /// [Output Only] Owning resource. This is the resource on which this quota is
  /// applied.
  core.String owner;

  /// [Output Only] Current usage of this metric.
  core.double usage;

  Quota();

  Quota.fromJson(core.Map _json) {
    if (_json.containsKey("limit")) {
      limit = _json["limit"].toDouble();
    }
    if (_json.containsKey("metric")) {
      metric = _json["metric"];
    }
    if (_json.containsKey("owner")) {
      owner = _json["owner"];
    }
    if (_json.containsKey("usage")) {
      usage = _json["usage"].toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (limit != null) {
      _json["limit"] = limit;
    }
    if (metric != null) {
      _json["metric"] = metric;
    }
    if (owner != null) {
      _json["owner"] = owner;
    }
    if (usage != null) {
      _json["usage"] = usage;
    }
    return _json;
  }
}

/// Represents a reference to a resource.
class Reference {
  /// [Output Only] Type of the resource. Always compute#reference for
  /// references.
  core.String kind;

  /// A description of the reference type with no implied semantics. Possible
  /// values include:
  /// - MEMBER_OF
  core.String referenceType;

  /// URL of the resource which refers to the target.
  core.String referrer;

  /// URL of the resource to which this reference points.
  core.String target;

  Reference();

  Reference.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("referenceType")) {
      referenceType = _json["referenceType"];
    }
    if (_json.containsKey("referrer")) {
      referrer = _json["referrer"];
    }
    if (_json.containsKey("target")) {
      target = _json["target"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (referenceType != null) {
      _json["referenceType"] = referenceType;
    }
    if (referrer != null) {
      _json["referrer"] = referrer;
    }
    if (target != null) {
      _json["target"] = target;
    }
    return _json;
  }
}

/// Represents a Region resource.
///
/// A region is a geographical area where a resource is located. For more
/// information, read Regions and Zones. (== resource_for {$api_version}.regions
/// ==)
class Region {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this region.
  DeprecationStatus deprecated;

  /// [Output Only] Textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#region for regions.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Quotas assigned to this region.
  core.List<Quota> quotas;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Status of the region, either UP or DOWN.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String status;

  /// [Output Only] A list of zones available in this region, in the form of
  /// resource URLs.
  core.List<core.String> zones;

  Region();

  Region.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("quotas")) {
      quotas = (_json["quotas"] as core.List)
          .map<Quota>((value) => new Quota.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("zones")) {
      zones = (_json["zones"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (quotas != null) {
      _json["quotas"] = quotas.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (zones != null) {
      _json["zones"] = zones;
    }
    return _json;
  }
}

class RegionAutoscalerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionAutoscalerListWarningData();

  RegionAutoscalerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionAutoscalerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionAutoscalerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionAutoscalerListWarning();

  RegionAutoscalerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RegionAutoscalerListWarningData>(
              (value) => new RegionAutoscalerListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of autoscalers.
class RegionAutoscalerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionAutoscalerListWarning warning;

  RegionAutoscalerList();

  RegionAutoscalerList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Autoscaler>((value) => new Autoscaler.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionAutoscalerListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionDiskTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionDiskTypeListWarningData();

  RegionDiskTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionDiskTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionDiskTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionDiskTypeListWarning();

  RegionDiskTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RegionDiskTypeListWarningData>(
              (value) => new RegionDiskTypeListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class RegionDiskTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DiskType resources.
  core.List<DiskType> items;

  /// [Output Only] Type of resource. Always compute#regionDiskTypeList for
  /// region disk types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionDiskTypeListWarning warning;

  RegionDiskTypeList();

  RegionDiskTypeList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<DiskType>((value) => new DiskType.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionDiskTypeListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionDisksAddResourcePoliciesRequest {
  /// Resource policies to be added to this disk.
  core.List<core.String> resourcePolicies;

  RegionDisksAddResourcePoliciesRequest();

  RegionDisksAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    return _json;
  }
}

class RegionDisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String> resourcePolicies;

  RegionDisksRemoveResourcePoliciesRequest();

  RegionDisksRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies =
          (_json["resourcePolicies"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resourcePolicies != null) {
      _json["resourcePolicies"] = resourcePolicies;
    }
    return _json;
  }
}

class RegionDisksResizeRequest {
  /// The new size of the regional persistent disk, which is specified in GB.
  core.String sizeGb;

  RegionDisksResizeRequest();

  RegionDisksResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey("sizeGb")) {
      sizeGb = _json["sizeGb"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sizeGb != null) {
      _json["sizeGb"] = sizeGb;
    }
    return _json;
  }
}

class RegionInstanceGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupListWarningData();

  RegionInstanceGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupListWarning();

  RegionInstanceGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RegionInstanceGroupListWarningData>(
              (value) => new RegionInstanceGroupListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of InstanceGroup resources.
class RegionInstanceGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup> items;

  /// The resource type.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupListWarning warning;

  RegionInstanceGroupList();

  RegionInstanceGroupList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceGroup>((value) => new InstanceGroup.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionInstanceGroupListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupManagerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupManagerListWarningData();

  RegionInstanceGroupManagerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupManagerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupManagerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupManagerListWarning();

  RegionInstanceGroupManagerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RegionInstanceGroupManagerListWarningData>((value) =>
              new RegionInstanceGroupManagerListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of managed instance groups.
class RegionInstanceGroupManagerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerList for a list of managed instance groups
  /// that exist in th regional scope.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupManagerListWarning warning;

  RegionInstanceGroupManagerList();

  RegionInstanceGroupManagerList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceGroupManager>(
              (value) => new InstanceGroupManager.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new RegionInstanceGroupManagerListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersAbandonInstancesRequest();

  RegionInstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

/// InstanceGroupManagers.applyUpdatesToInstances
class RegionInstanceGroupManagersApplyUpdatesRequest {
  /// The list of URLs of one or more instances for which you want to apply
  /// updates. Each URL can be a full URL or a partial URL, such as
  /// zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  /// The minimal action that you want to perform on each instance during the
  /// update:
  /// - REPLACE: At minimum, delete the instance and create it again.
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all.  By default, the minimum
  /// action is NONE. If your update requires a more disruptive action than you
  /// set with this flag, the necessary action is performed to execute the
  /// update.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update:
  /// - REPLACE: Delete the instance and create it again.
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all.  By default, the most
  /// disruptive allowed action is REPLACE. If your update requires a more
  /// disruptive action than you set with this flag, the update request will
  /// fail.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String mostDisruptiveAllowedAction;

  RegionInstanceGroupManagersApplyUpdatesRequest();

  RegionInstanceGroupManagersApplyUpdatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("minimalAction")) {
      minimalAction = _json["minimalAction"];
    }
    if (_json.containsKey("mostDisruptiveAllowedAction")) {
      mostDisruptiveAllowedAction = _json["mostDisruptiveAllowedAction"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    if (minimalAction != null) {
      _json["minimalAction"] = minimalAction;
    }
    if (mostDisruptiveAllowedAction != null) {
      _json["mostDisruptiveAllowedAction"] = mostDisruptiveAllowedAction;
    }
    return _json;
  }
}

/// RegionInstanceGroupManagers.createInstances
class RegionInstanceGroupManagersCreateInstancesRequest {
  /// [Required] List of specifications of per-instance configs.
  core.List<PerInstanceConfig> instances;

  RegionInstanceGroupManagersCreateInstancesRequest();

  RegionInstanceGroupManagersCreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List)
          .map<PerInstanceConfig>(
              (value) => new PerInstanceConfig.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class RegionInstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersDeleteInstancesRequest();

  RegionInstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersListErrorsResponse {
  /// [Output Only] The list of errors of the managed instance group.
  core.List<InstanceManagedByIgmError> items;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  RegionInstanceGroupManagersListErrorsResponse();

  RegionInstanceGroupManagersListErrorsResponse.fromJson(core.Map _json) {
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceManagedByIgmError>(
              (value) => new InstanceManagedByIgmError.fromJson(value))
          .toList();
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersListInstancesResponse {
  /// A list of managed instances.
  core.List<ManagedInstance> managedInstances;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  RegionInstanceGroupManagersListInstancesResponse();

  RegionInstanceGroupManagersListInstancesResponse.fromJson(core.Map _json) {
    if (_json.containsKey("managedInstances")) {
      managedInstances = (_json["managedInstances"] as core.List)
          .map<ManagedInstance>((value) => new ManagedInstance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (managedInstances != null) {
      _json["managedInstances"] =
          managedInstances.map((value) => (value).toJson()).toList();
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersRecreateRequest {
  /// The URLs of one or more instances to recreate. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersRecreateRequest();

  RegionInstanceGroupManagersRecreateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersSetTargetPoolsRequest {
  /// Fingerprint of the target pools information, which is a hash of the
  /// contents. This field is used for optimistic locking when you update the
  /// target pool entries. This field is optional.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The URL of all TargetPool resources to which instances in the
  /// instanceGroup field are added. The target pools automatically apply to all
  /// of the instances in the managed instance group.
  core.List<core.String> targetPools;

  RegionInstanceGroupManagersSetTargetPoolsRequest();

  RegionInstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("targetPools")) {
      targetPools = (_json["targetPools"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (targetPools != null) {
      _json["targetPools"] = targetPools;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersSetTemplateRequest {
  /// URL of the InstanceTemplate resource from which all new instances will be
  /// created.
  core.String instanceTemplate;

  RegionInstanceGroupManagersSetTemplateRequest();

  RegionInstanceGroupManagersSetTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instanceTemplate")) {
      instanceTemplate = _json["instanceTemplate"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceTemplate != null) {
      _json["instanceTemplate"] = instanceTemplate;
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstancesWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupsListInstancesWarningData();

  RegionInstanceGroupsListInstancesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupsListInstancesWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupsListInstancesWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupsListInstancesWarning();

  RegionInstanceGroupsListInstancesWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RegionInstanceGroupsListInstancesWarningData>((value) =>
              new RegionInstanceGroupsListInstancesWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstances {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts> items;

  /// The resource type.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupsListInstancesWarning warning;

  RegionInstanceGroupsListInstances();

  RegionInstanceGroupsListInstances.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<InstanceWithNamedPorts>(
              (value) => new InstanceWithNamedPorts.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionInstanceGroupsListInstancesWarning.fromJson(
          _json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstancesRequest {
  /// Instances in which state should be returned. Valid options are: 'ALL',
  /// 'RUNNING'. By default, it lists all instances.
  /// Possible string values are:
  /// - "ALL"
  /// - "RUNNING"
  core.String instanceState;

  /// Name of port user is interested in. It is optional. If it is set, only
  /// information about this ports will be returned. If it is not set, all the
  /// named ports will be returned. Always lists all instances.
  core.String portName;

  RegionInstanceGroupsListInstancesRequest();

  RegionInstanceGroupsListInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instanceState")) {
      instanceState = _json["instanceState"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceState != null) {
      _json["instanceState"] = instanceState;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    return _json;
  }
}

class RegionInstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort> namedPorts;

  RegionInstanceGroupsSetNamedPortsRequest();

  RegionInstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("namedPorts")) {
      namedPorts = (_json["namedPorts"] as core.List)
          .map<NamedPort>((value) => new NamedPort.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (namedPorts != null) {
      _json["namedPorts"] =
          namedPorts.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class RegionListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionListWarningData();

  RegionListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionListWarning();

  RegionListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RegionListWarningData>(
              (value) => new RegionListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of region resources.
class RegionList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Region resources.
  core.List<Region> items;

  /// [Output Only] Type of resource. Always compute#regionList for lists of
  /// regions.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionListWarning warning;

  RegionList();

  RegionList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Region>((value) => new Region.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RegionListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RegionSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts. The fingerprint is initially generated by Compute Engine
  /// and changes after every request to modify or update labels. You must
  /// always provide an up-to-date fingerprint hash in order to update or change
  /// labels. Make a get() request to the resource to get the latest
  /// fingerprint.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String> labels;

  RegionSetLabelsRequest();

  RegionSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    return _json;
  }
}

class RegionSetPolicyRequest {
  /// Flatten Policy to create a backwacd compatible wire-format. Deprecated.
  /// Use 'policy' to specify bindings.
  core.List<Binding> bindings;

  /// Flatten Policy to create a backward compatible wire-format. Deprecated.
  /// Use 'policy' to specify the etag.
  core.String etag;
  core.List<core.int> get etagAsBytes {
    return convert.base64.decode(etag);
  }

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'. The size of
  /// the policy is limited to a few 10s of KB. An empty policy is in general a
  /// valid policy but certain services (like Projects) might reject them.
  Policy policy;

  RegionSetPolicyRequest();

  RegionSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey("bindings")) {
      bindings = (_json["bindings"] as core.List)
          .map<Binding>((value) => new Binding.fromJson(value))
          .toList();
    }
    if (_json.containsKey("etag")) {
      etag = _json["etag"];
    }
    if (_json.containsKey("policy")) {
      policy = new Policy.fromJson(_json["policy"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bindings != null) {
      _json["bindings"] = bindings.map((value) => (value).toJson()).toList();
    }
    if (etag != null) {
      _json["etag"] = etag;
    }
    if (policy != null) {
      _json["policy"] = (policy).toJson();
    }
    return _json;
  }
}

class RegionTargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource. Currently exactly one SslCertificate resource
  /// must be specified.
  core.List<core.String> sslCertificates;

  RegionTargetHttpsProxiesSetSslCertificatesRequest();

  RegionTargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("sslCertificates")) {
      sslCertificates =
          (_json["sslCertificates"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    return _json;
  }
}

class RegionUrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap resource;

  RegionUrlMapsValidateRequest();

  RegionUrlMapsValidateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resource")) {
      resource = new UrlMap.fromJson(_json["resource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resource != null) {
      _json["resource"] = (resource).toJson();
    }
    return _json;
  }
}

/// A policy that specifies how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait
/// for responses from the shadow service. Prior to sending traffic to the
/// shadow service, the host / authority header is suffixed with -shadow.
class RequestMirrorPolicy {
  /// The full or partial URL to the BackendService resource being mirrored to.
  core.String backendService;

  RequestMirrorPolicy();

  RequestMirrorPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("backendService")) {
      backendService = _json["backendService"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (backendService != null) {
      _json["backendService"] = backendService;
    }
    return _json;
  }
}

/// Represents a reservation resource. A reservation ensures that capacity is
/// held in a specific zone even if the reserved VMs are not running. For more
/// information, read  Reserving zonal resources. (== resource_for
/// {$api_version}.reservations ==)
class Reservation {
  /// [Output Only] Full or partial URL to a parent commitment. This field
  /// displays for reservations that are tied to a commitment.
  core.String commitment;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#reservations for
  /// reservations.
  core.String kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// Reservation for instances with specific machine shapes.
  AllocationSpecificSKUReservation specificReservation;

  /// Indicates whether the reservation can be consumed by VMs with affinity for
  /// "any" reservation. If the field is set, then only VMs that target the
  /// reservation by name can consume from this reservation.
  core.bool specificReservationRequired;

  /// [Output Only] The status of the reservation.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  /// - "UPDATING"
  core.String status;

  /// Zone in which the reservation resides. A zone must be provided if the
  /// reservation is created within a commitment.
  core.String zone;

  Reservation();

  Reservation.fromJson(core.Map _json) {
    if (_json.containsKey("commitment")) {
      commitment = _json["commitment"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("specificReservation")) {
      specificReservation = new AllocationSpecificSKUReservation.fromJson(
          _json["specificReservation"]);
    }
    if (_json.containsKey("specificReservationRequired")) {
      specificReservationRequired = _json["specificReservationRequired"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (commitment != null) {
      _json["commitment"] = commitment;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (specificReservation != null) {
      _json["specificReservation"] = (specificReservation).toJson();
    }
    if (specificReservationRequired != null) {
      _json["specificReservationRequired"] = specificReservationRequired;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

/// Specifies the reservations that this instance can consume from.
class ReservationAffinity {
  /// Specifies the type of reservation from which this instance can consume
  /// resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or
  /// NO_RESERVATION. See  Consuming reserved instances for examples.
  /// Possible string values are:
  /// - "ANY_RESERVATION"
  /// - "NO_RESERVATION"
  /// - "SPECIFIC_RESERVATION"
  /// - "UNSPECIFIED"
  core.String consumeReservationType;

  /// Corresponds to the label key of a reservation resource. To target a
  /// SPECIFIC_RESERVATION by name, specify googleapis.com/reservation-name as
  /// the key and specify the name of your reservation as its value.
  core.String key;

  /// Corresponds to the label values of a reservation resource.
  core.List<core.String> values;

  ReservationAffinity();

  ReservationAffinity.fromJson(core.Map _json) {
    if (_json.containsKey("consumeReservationType")) {
      consumeReservationType = _json["consumeReservationType"];
    }
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("values")) {
      values = (_json["values"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (consumeReservationType != null) {
      _json["consumeReservationType"] = consumeReservationType;
    }
    if (key != null) {
      _json["key"] = key;
    }
    if (values != null) {
      _json["values"] = values;
    }
    return _json;
  }
}

class ReservationAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ReservationAggregatedListWarningData();

  ReservationAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ReservationAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ReservationAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ReservationAggregatedListWarning();

  ReservationAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ReservationAggregatedListWarningData>((value) =>
              new ReservationAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of reservations.
class ReservationAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Allocation resources.
  core.Map<core.String, ReservationsScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ReservationAggregatedListWarning warning;

  ReservationAggregatedList();

  ReservationAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, ReservationsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new ReservationsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ReservationAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<ReservationsScopedList, core.Map<core.String, core.Object>>(
              items, (ReservationsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ReservationListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ReservationListWarningData();

  ReservationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ReservationListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ReservationListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ReservationListWarning();

  ReservationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ReservationListWarningData>(
              (value) => new ReservationListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ReservationList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of Allocation resources.
  core.List<Reservation> items;

  /// [Output Only] Type of resource.Always compute#reservationsList for listsof
  /// reservations
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ReservationListWarning warning;

  ReservationList();

  ReservationList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Reservation>((value) => new Reservation.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ReservationListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ReservationsResizeRequest {
  /// Number of allocated resources can be resized with minimum = 1 and maximum
  /// = 1000.
  core.String specificSkuCount;

  ReservationsResizeRequest();

  ReservationsResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey("specificSkuCount")) {
      specificSkuCount = _json["specificSkuCount"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (specificSkuCount != null) {
      _json["specificSkuCount"] = specificSkuCount;
    }
    return _json;
  }
}

class ReservationsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ReservationsScopedListWarningData();

  ReservationsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of reservations when the list
/// is empty.
class ReservationsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ReservationsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ReservationsScopedListWarning();

  ReservationsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ReservationsScopedListWarningData>(
              (value) => new ReservationsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ReservationsScopedList {
  /// A list of reservations contained in this scope.
  core.List<Reservation> reservations;

  /// Informational warning which replaces the list of reservations when the
  /// list is empty.
  ReservationsScopedListWarning warning;

  ReservationsScopedList();

  ReservationsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("reservations")) {
      reservations = (_json["reservations"] as core.List)
          .map<Reservation>((value) => new Reservation.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new ReservationsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (reservations != null) {
      _json["reservations"] =
          reservations.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Commitment for a particular resource (a Commitment is composed of one or
/// more of these).
class ResourceCommitment {
  /// Name of the accelerator type resource. Applicable only when the type is
  /// ACCELERATOR.
  core.String acceleratorType;

  /// The amount of the resource purchased (in a type-dependent unit, such as
  /// bytes). For vCPUs, this can just be an integer. For memory, this must be
  /// provided in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of
  /// memory per every vCPU.
  core.String amount;

  /// Type of resource for which this commitment applies. Possible values are
  /// VCPU and MEMORY
  /// Possible string values are:
  /// - "ACCELERATOR"
  /// - "LOCAL_SSD"
  /// - "MEMORY"
  /// - "UNSPECIFIED"
  /// - "VCPU"
  core.String type;

  ResourceCommitment();

  ResourceCommitment.fromJson(core.Map _json) {
    if (_json.containsKey("acceleratorType")) {
      acceleratorType = _json["acceleratorType"];
    }
    if (_json.containsKey("amount")) {
      amount = _json["amount"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (acceleratorType != null) {
      _json["acceleratorType"] = acceleratorType;
    }
    if (amount != null) {
      _json["amount"] = amount;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class ResourceGroupReference {
  /// A URI referencing one of the instance groups or network endpoint groups
  /// listed in the backend service.
  core.String group;

  ResourceGroupReference();

  ResourceGroupReference.fromJson(core.Map _json) {
    if (_json.containsKey("group")) {
      group = _json["group"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (group != null) {
      _json["group"] = group;
    }
    return _json;
  }
}

class ResourcePoliciesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ResourcePoliciesScopedListWarningData();

  ResourcePoliciesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of resourcePolicies when the
/// list is empty.
class ResourcePoliciesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ResourcePoliciesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ResourcePoliciesScopedListWarning();

  ResourcePoliciesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ResourcePoliciesScopedListWarningData>((value) =>
              new ResourcePoliciesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ResourcePoliciesScopedList {
  /// A list of resourcePolicies contained in this scope.
  core.List<ResourcePolicy> resourcePolicies;

  /// Informational warning which replaces the list of resourcePolicies when the
  /// list is empty.
  ResourcePoliciesScopedListWarning warning;

  ResourcePoliciesScopedList();

  ResourcePoliciesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("resourcePolicies")) {
      resourcePolicies = (_json["resourcePolicies"] as core.List)
          .map<ResourcePolicy>((value) => new ResourcePolicy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new ResourcePoliciesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resourcePolicies != null) {
      _json["resourcePolicies"] =
          resourcePolicies.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Resource Policy resource. You can use resource policies to
/// schedule actions for some Compute Engine resources. For example, you can use
/// them to schedule persistent disk snapshots.
///
/// (== resource_for {$api_version}.resourcePolicies ==)
class ResourcePolicy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;
  core.String description;

  /// Resource policy for instacnes for placement configuration.
  ResourcePolicyGroupPlacementPolicy groupPlacementPolicy;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#resource_policies for
  /// resource policies.
  core.String kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;
  core.String region;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// Resource policy for persistent disks for creating snapshots.
  ResourcePolicySnapshotSchedulePolicy snapshotSchedulePolicy;

  /// [Output Only] The status of resource policy creation.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String status;

  ResourcePolicy();

  ResourcePolicy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("groupPlacementPolicy")) {
      groupPlacementPolicy = new ResourcePolicyGroupPlacementPolicy.fromJson(
          _json["groupPlacementPolicy"]);
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("snapshotSchedulePolicy")) {
      snapshotSchedulePolicy =
          new ResourcePolicySnapshotSchedulePolicy.fromJson(
              _json["snapshotSchedulePolicy"]);
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (groupPlacementPolicy != null) {
      _json["groupPlacementPolicy"] = (groupPlacementPolicy).toJson();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (snapshotSchedulePolicy != null) {
      _json["snapshotSchedulePolicy"] = (snapshotSchedulePolicy).toJson();
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

class ResourcePolicyAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ResourcePolicyAggregatedListWarningData();

  ResourcePolicyAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ResourcePolicyAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ResourcePolicyAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ResourcePolicyAggregatedListWarning();

  ResourcePolicyAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ResourcePolicyAggregatedListWarningData>((value) =>
              new ResourcePolicyAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of resourcePolicies.
class ResourcePolicyAggregatedList {
  core.String etag;

  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ResourcePolicy resources.
  core.Map<core.String, ResourcePoliciesScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ResourcePolicyAggregatedListWarning warning;

  ResourcePolicyAggregatedList();

  ResourcePolicyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("etag")) {
      etag = _json["etag"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, ResourcePoliciesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new ResourcePoliciesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new ResourcePolicyAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (etag != null) {
      _json["etag"] = etag;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<ResourcePoliciesScopedList,
              core.Map<core.String, core.Object>>(
          items, (ResourcePoliciesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Time window specified for daily operations.
class ResourcePolicyDailyCycle {
  /// Defines a schedule with units measured in months. The value determines how
  /// many months pass between the start of each cycle.
  core.int daysInCycle;

  /// [Output only] A predetermined duration for the window, automatically
  /// chosen to be the smallest possible in the given scenario.
  core.String duration;

  /// Start time of the window. This must be in UTC format that resolves to one
  /// of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5
  /// and 08:00 are valid.
  core.String startTime;

  ResourcePolicyDailyCycle();

  ResourcePolicyDailyCycle.fromJson(core.Map _json) {
    if (_json.containsKey("daysInCycle")) {
      daysInCycle = _json["daysInCycle"];
    }
    if (_json.containsKey("duration")) {
      duration = _json["duration"];
    }
    if (_json.containsKey("startTime")) {
      startTime = _json["startTime"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (daysInCycle != null) {
      _json["daysInCycle"] = daysInCycle;
    }
    if (duration != null) {
      _json["duration"] = duration;
    }
    if (startTime != null) {
      _json["startTime"] = startTime;
    }
    return _json;
  }
}

/// A GroupPlacementPolicy specifies resource placement configuration. It
/// specifies the failure bucket separation as well as network locality
class ResourcePolicyGroupPlacementPolicy {
  /// The number of availability domains instances will be spread across. If two
  /// instances are in different availability domain, they will not be put in
  /// the same low latency network
  core.int availabilityDomainCount;

  /// Specifies network collocation
  /// Possible string values are:
  /// - "COLLOCATED"
  /// - "UNSPECIFIED_COLLOCATION"
  core.String collocation;

  /// Number of vms in this placement group
  core.int vmCount;

  ResourcePolicyGroupPlacementPolicy();

  ResourcePolicyGroupPlacementPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("availabilityDomainCount")) {
      availabilityDomainCount = _json["availabilityDomainCount"];
    }
    if (_json.containsKey("collocation")) {
      collocation = _json["collocation"];
    }
    if (_json.containsKey("vmCount")) {
      vmCount = _json["vmCount"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (availabilityDomainCount != null) {
      _json["availabilityDomainCount"] = availabilityDomainCount;
    }
    if (collocation != null) {
      _json["collocation"] = collocation;
    }
    if (vmCount != null) {
      _json["vmCount"] = vmCount;
    }
    return _json;
  }
}

/// Time window specified for hourly operations.
class ResourcePolicyHourlyCycle {
  /// [Output only] Duration of the time window, automatically chosen to be
  /// smallest possible in the given scenario.
  core.String duration;

  /// Defines a schedule with units measured in hours. The value determines how
  /// many hours pass between the start of each cycle.
  core.int hoursInCycle;

  /// Time within the window to start the operations. It must be in format
  /// "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
  core.String startTime;

  ResourcePolicyHourlyCycle();

  ResourcePolicyHourlyCycle.fromJson(core.Map _json) {
    if (_json.containsKey("duration")) {
      duration = _json["duration"];
    }
    if (_json.containsKey("hoursInCycle")) {
      hoursInCycle = _json["hoursInCycle"];
    }
    if (_json.containsKey("startTime")) {
      startTime = _json["startTime"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (duration != null) {
      _json["duration"] = duration;
    }
    if (hoursInCycle != null) {
      _json["hoursInCycle"] = hoursInCycle;
    }
    if (startTime != null) {
      _json["startTime"] = startTime;
    }
    return _json;
  }
}

class ResourcePolicyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ResourcePolicyListWarningData();

  ResourcePolicyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ResourcePolicyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ResourcePolicyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ResourcePolicyListWarning();

  ResourcePolicyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ResourcePolicyListWarningData>(
              (value) => new ResourcePolicyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class ResourcePolicyList {
  core.String etag;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of ResourcePolicy resources.
  core.List<ResourcePolicy> items;

  /// [Output Only] Type of resource.Always compute#resourcePoliciesList for
  /// listsof resourcePolicies
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ResourcePolicyListWarning warning;

  ResourcePolicyList();

  ResourcePolicyList.fromJson(core.Map _json) {
    if (_json.containsKey("etag")) {
      etag = _json["etag"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<ResourcePolicy>((value) => new ResourcePolicy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ResourcePolicyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (etag != null) {
      _json["etag"] = etag;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A snapshot schedule policy specifies when and how frequently snapshots are
/// to be created for the target disk. Also specifies how many and how long
/// these scheduled snapshots should be retained.
class ResourcePolicySnapshotSchedulePolicy {
  /// Retention policy applied to snapshots created by this resource policy.
  ResourcePolicySnapshotSchedulePolicyRetentionPolicy retentionPolicy;

  /// A Vm Maintenance Policy specifies what kind of infrastructure maintenance
  /// we are allowed to perform on this VM and when. Schedule that is applied to
  /// disks covered by this policy.
  ResourcePolicySnapshotSchedulePolicySchedule schedule;

  /// Properties with which snapshots are created such as labels, encryption
  /// keys.
  ResourcePolicySnapshotSchedulePolicySnapshotProperties snapshotProperties;

  ResourcePolicySnapshotSchedulePolicy();

  ResourcePolicySnapshotSchedulePolicy.fromJson(core.Map _json) {
    if (_json.containsKey("retentionPolicy")) {
      retentionPolicy =
          new ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(
              _json["retentionPolicy"]);
    }
    if (_json.containsKey("schedule")) {
      schedule = new ResourcePolicySnapshotSchedulePolicySchedule.fromJson(
          _json["schedule"]);
    }
    if (_json.containsKey("snapshotProperties")) {
      snapshotProperties =
          new ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
              _json["snapshotProperties"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (retentionPolicy != null) {
      _json["retentionPolicy"] = (retentionPolicy).toJson();
    }
    if (schedule != null) {
      _json["schedule"] = (schedule).toJson();
    }
    if (snapshotProperties != null) {
      _json["snapshotProperties"] = (snapshotProperties).toJson();
    }
    return _json;
  }
}

/// Policy for retention of scheduled snapshots.
class ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
  /// Maximum age of the snapshot that is allowed to be kept.
  core.int maxRetentionDays;

  /// Specifies the behavior to apply to scheduled snapshots when the source
  /// disk is deleted.
  /// Possible string values are:
  /// - "APPLY_RETENTION_POLICY"
  /// - "KEEP_AUTO_SNAPSHOTS"
  /// - "UNSPECIFIED_ON_SOURCE_DISK_DELETE"
  core.String onSourceDiskDelete;

  ResourcePolicySnapshotSchedulePolicyRetentionPolicy();

  ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("maxRetentionDays")) {
      maxRetentionDays = _json["maxRetentionDays"];
    }
    if (_json.containsKey("onSourceDiskDelete")) {
      onSourceDiskDelete = _json["onSourceDiskDelete"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (maxRetentionDays != null) {
      _json["maxRetentionDays"] = maxRetentionDays;
    }
    if (onSourceDiskDelete != null) {
      _json["onSourceDiskDelete"] = onSourceDiskDelete;
    }
    return _json;
  }
}

/// A schedule for disks where the schedueled operations are performed.
class ResourcePolicySnapshotSchedulePolicySchedule {
  ResourcePolicyDailyCycle dailySchedule;
  ResourcePolicyHourlyCycle hourlySchedule;
  ResourcePolicyWeeklyCycle weeklySchedule;

  ResourcePolicySnapshotSchedulePolicySchedule();

  ResourcePolicySnapshotSchedulePolicySchedule.fromJson(core.Map _json) {
    if (_json.containsKey("dailySchedule")) {
      dailySchedule =
          new ResourcePolicyDailyCycle.fromJson(_json["dailySchedule"]);
    }
    if (_json.containsKey("hourlySchedule")) {
      hourlySchedule =
          new ResourcePolicyHourlyCycle.fromJson(_json["hourlySchedule"]);
    }
    if (_json.containsKey("weeklySchedule")) {
      weeklySchedule =
          new ResourcePolicyWeeklyCycle.fromJson(_json["weeklySchedule"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (dailySchedule != null) {
      _json["dailySchedule"] = (dailySchedule).toJson();
    }
    if (hourlySchedule != null) {
      _json["hourlySchedule"] = (hourlySchedule).toJson();
    }
    if (weeklySchedule != null) {
      _json["weeklySchedule"] = (weeklySchedule).toJson();
    }
    return _json;
  }
}

/// Specified snapshot properties for scheduled snapshots created by this
/// policy.
class ResourcePolicySnapshotSchedulePolicySnapshotProperties {
  /// Indication to perform a 'guest aware' snapshot.
  core.bool guestFlush;

  /// Labels to apply to scheduled snapshots. These can be later modified by the
  /// setLabels method. Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// Cloud Storage bucket storage location of the auto snapshot (regional or
  /// multi-regional).
  core.List<core.String> storageLocations;

  ResourcePolicySnapshotSchedulePolicySnapshotProperties();

  ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
      core.Map _json) {
    if (_json.containsKey("guestFlush")) {
      guestFlush = _json["guestFlush"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("storageLocations")) {
      storageLocations =
          (_json["storageLocations"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (guestFlush != null) {
      _json["guestFlush"] = guestFlush;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (storageLocations != null) {
      _json["storageLocations"] = storageLocations;
    }
    return _json;
  }
}

/// Time window specified for weekly operations.
class ResourcePolicyWeeklyCycle {
  /// Up to 7 intervals/windows, one for each day of the week.
  core.List<ResourcePolicyWeeklyCycleDayOfWeek> dayOfWeeks;

  ResourcePolicyWeeklyCycle();

  ResourcePolicyWeeklyCycle.fromJson(core.Map _json) {
    if (_json.containsKey("dayOfWeeks")) {
      dayOfWeeks = (_json["dayOfWeeks"] as core.List)
          .map<ResourcePolicyWeeklyCycleDayOfWeek>(
              (value) => new ResourcePolicyWeeklyCycleDayOfWeek.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (dayOfWeeks != null) {
      _json["dayOfWeeks"] =
          dayOfWeeks.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class ResourcePolicyWeeklyCycleDayOfWeek {
  /// Defines a schedule that runs on specific days of the week. Specify one or
  /// more days. The following options are available: MONDAY, TUESDAY,
  /// WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
  /// Possible string values are:
  /// - "FRIDAY"
  /// - "INVALID"
  /// - "MONDAY"
  /// - "SATURDAY"
  /// - "SUNDAY"
  /// - "THURSDAY"
  /// - "TUESDAY"
  /// - "WEDNESDAY"
  core.String day;

  /// [Output only] Duration of the time window, automatically chosen to be
  /// smallest possible in the given scenario.
  core.String duration;

  /// Time within the window to start the operations. It must be in format
  /// "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
  core.String startTime;

  ResourcePolicyWeeklyCycleDayOfWeek();

  ResourcePolicyWeeklyCycleDayOfWeek.fromJson(core.Map _json) {
    if (_json.containsKey("day")) {
      day = _json["day"];
    }
    if (_json.containsKey("duration")) {
      duration = _json["duration"];
    }
    if (_json.containsKey("startTime")) {
      startTime = _json["startTime"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (day != null) {
      _json["day"] = day;
    }
    if (duration != null) {
      _json["duration"] = duration;
    }
    if (startTime != null) {
      _json["startTime"] = startTime;
    }
    return _json;
  }
}

class RouteWarningsData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouteWarningsData();

  RouteWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

class RouteWarnings {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouteWarningsData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouteWarnings();

  RouteWarnings.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RouteWarningsData>(
              (value) => new RouteWarningsData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Represents a Route resource.
///
/// A route defines a path from VM instances in the VPC network to a specific
/// destination. This destination can be inside or outside the VPC network. For
/// more information, read the Routes overview. (== resource_for
/// {$api_version}.routes ==)
class Route {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this field when you
  /// create the resource.
  core.String description;

  /// The destination range of outgoing packets that this route applies to. Only
  /// IPv4 is supported.
  core.String destRange;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of this resource. Always compute#routes for Route
  /// resources.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
  /// lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String name;

  /// Fully-qualified URL of the network that this route applies to.
  core.String network;

  /// The URL to a gateway that should handle matching packets. You can only
  /// specify the internet gateway using a full or partial valid URL:
  /// projects/project/global/gateways/default-internet-gateway
  core.String nextHopGateway;

  /// The URL to a forwarding rule of type loadBalancingScheme=INTERNAL that
  /// should handle matching packets. You can only specify the forwarding rule
  /// as a partial or full URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
  /// - regions/region/forwardingRules/forwardingRule
  core.String nextHopIlb;

  /// The URL to an instance that should handle matching packets. You can
  /// specify this as a full or partial URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/
  core.String nextHopInstance;

  /// The network IP address of an instance that should handle matching packets.
  /// Only IPv4 is supported.
  core.String nextHopIp;

  /// The URL of the local network if it should handle matching packets.
  core.String nextHopNetwork;

  /// [Output Only] The network peering name that should handle matching
  /// packets, which should conform to RFC1035.
  core.String nextHopPeering;

  /// The URL to a VpnTunnel that should handle matching packets.
  core.String nextHopVpnTunnel;

  /// The priority of this route. Priority is used to break ties in cases where
  /// there is more than one matching route of equal prefix length. In cases
  /// where multiple routes have equal prefix length, the one with the
  /// lowest-numbered priority value wins. The default value is `1000`. The
  /// priority value must be from `0` to `65535`, inclusive.
  core.int priority;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// A list of instance tags to which this route applies.
  core.List<core.String> tags;

  /// [Output Only] If potential misconfigurations are detected for this route,
  /// this field will be populated with warning messages.
  core.List<RouteWarnings> warnings;

  Route();

  Route.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("destRange")) {
      destRange = _json["destRange"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("nextHopGateway")) {
      nextHopGateway = _json["nextHopGateway"];
    }
    if (_json.containsKey("nextHopIlb")) {
      nextHopIlb = _json["nextHopIlb"];
    }
    if (_json.containsKey("nextHopInstance")) {
      nextHopInstance = _json["nextHopInstance"];
    }
    if (_json.containsKey("nextHopIp")) {
      nextHopIp = _json["nextHopIp"];
    }
    if (_json.containsKey("nextHopNetwork")) {
      nextHopNetwork = _json["nextHopNetwork"];
    }
    if (_json.containsKey("nextHopPeering")) {
      nextHopPeering = _json["nextHopPeering"];
    }
    if (_json.containsKey("nextHopVpnTunnel")) {
      nextHopVpnTunnel = _json["nextHopVpnTunnel"];
    }
    if (_json.containsKey("priority")) {
      priority = _json["priority"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("tags")) {
      tags = (_json["tags"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("warnings")) {
      warnings = (_json["warnings"] as core.List)
          .map<RouteWarnings>((value) => new RouteWarnings.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (destRange != null) {
      _json["destRange"] = destRange;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (nextHopGateway != null) {
      _json["nextHopGateway"] = nextHopGateway;
    }
    if (nextHopIlb != null) {
      _json["nextHopIlb"] = nextHopIlb;
    }
    if (nextHopInstance != null) {
      _json["nextHopInstance"] = nextHopInstance;
    }
    if (nextHopIp != null) {
      _json["nextHopIp"] = nextHopIp;
    }
    if (nextHopNetwork != null) {
      _json["nextHopNetwork"] = nextHopNetwork;
    }
    if (nextHopPeering != null) {
      _json["nextHopPeering"] = nextHopPeering;
    }
    if (nextHopVpnTunnel != null) {
      _json["nextHopVpnTunnel"] = nextHopVpnTunnel;
    }
    if (priority != null) {
      _json["priority"] = priority;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (tags != null) {
      _json["tags"] = tags;
    }
    if (warnings != null) {
      _json["warnings"] = warnings.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class RouteListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouteListWarningData();

  RouteListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouteListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouteListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouteListWarning();

  RouteListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RouteListWarningData>(
              (value) => new RouteListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Route resources.
class RouteList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Route resources.
  core.List<Route> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RouteListWarning warning;

  RouteList();

  RouteList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Route>((value) => new Route.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RouteListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Cloud Router resource.
///
/// For more information about Cloud Router, read the the Cloud Router overview.
class Router {
  /// BGP information specific to this router.
  RouterBgp bgp;

  /// BGP information that must be configured into the routing stack to
  /// establish BGP peering. This information must specify the peer ASN and
  /// either the interface name, IP address, or peer IP address. Please refer to
  /// RFC4273.
  core.List<RouterBgpPeer> bgpPeers;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Router interfaces. Each interface requires either one linked resource,
  /// (for example, linkedVpnTunnel), or IP address and IP address range (for
  /// example, ipRange), or both.
  core.List<RouterInterface> interfaces;

  /// [Output Only] Type of resource. Always compute#router for routers.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// A list of NAT services created in this router.
  core.List<RouterNat> nats;

  /// URI of the network to which this router belongs.
  core.String network;

  /// [Output Only] URI of the region where the router resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  Router();

  Router.fromJson(core.Map _json) {
    if (_json.containsKey("bgp")) {
      bgp = new RouterBgp.fromJson(_json["bgp"]);
    }
    if (_json.containsKey("bgpPeers")) {
      bgpPeers = (_json["bgpPeers"] as core.List)
          .map<RouterBgpPeer>((value) => new RouterBgpPeer.fromJson(value))
          .toList();
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("interfaces")) {
      interfaces = (_json["interfaces"] as core.List)
          .map<RouterInterface>((value) => new RouterInterface.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("nats")) {
      nats = (_json["nats"] as core.List)
          .map<RouterNat>((value) => new RouterNat.fromJson(value))
          .toList();
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bgp != null) {
      _json["bgp"] = (bgp).toJson();
    }
    if (bgpPeers != null) {
      _json["bgpPeers"] = bgpPeers.map((value) => (value).toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (interfaces != null) {
      _json["interfaces"] =
          interfaces.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (nats != null) {
      _json["nats"] = nats.map((value) => (value).toJson()).toList();
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

/// Description-tagged IP ranges for the router to advertise.
class RouterAdvertisedIpRange {
  /// User-specified description for the IP range.
  core.String description;

  /// The IP range to advertise. The value must be a CIDR-formatted string.
  core.String range;

  RouterAdvertisedIpRange();

  RouterAdvertisedIpRange.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("range")) {
      range = _json["range"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (range != null) {
      _json["range"] = range;
    }
    return _json;
  }
}

class RouterAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouterAggregatedListWarningData();

  RouterAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouterAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouterAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouterAggregatedListWarning();

  RouterAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RouterAggregatedListWarningData>(
              (value) => new RouterAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of routers.
class RouterAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Router resources.
  core.Map<core.String, RoutersScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RouterAggregatedListWarning warning;

  RouterAggregatedList();

  RouterAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, RoutersScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new RoutersScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RouterAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] =
          commons.mapMap<RoutersScopedList, core.Map<core.String, core.Object>>(
              items, (RoutersScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class RouterBgp {
  /// User-specified flag to indicate which mode to use for advertisement. The
  /// options are DEFAULT or CUSTOM.
  /// Possible string values are:
  /// - "CUSTOM"
  /// - "DEFAULT"
  core.String advertiseMode;

  /// User-specified list of prefix groups to advertise in custom mode. This
  /// field can only be populated if advertise_mode is CUSTOM and is advertised
  /// to all peers of the router. These groups will be advertised in addition to
  /// any specified prefixes. Leave this field blank to advertise no custom
  /// groups.
  core.List<core.String> advertisedGroups;

  /// User-specified list of individual IP ranges to advertise in custom mode.
  /// This field can only be populated if advertise_mode is CUSTOM and is
  /// advertised to all peers of the router. These IP ranges will be advertised
  /// in addition to any specified groups. Leave this field blank to advertise
  /// no custom IP ranges.
  core.List<RouterAdvertisedIpRange> advertisedIpRanges;

  /// Local BGP Autonomous System Number (ASN). Must be an RFC6996 private ASN,
  /// either 16-bit or 32-bit. The value will be fixed for this router resource.
  /// All VPN tunnels that link to this router will have the same local ASN.
  core.int asn;

  RouterBgp();

  RouterBgp.fromJson(core.Map _json) {
    if (_json.containsKey("advertiseMode")) {
      advertiseMode = _json["advertiseMode"];
    }
    if (_json.containsKey("advertisedGroups")) {
      advertisedGroups =
          (_json["advertisedGroups"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("advertisedIpRanges")) {
      advertisedIpRanges = (_json["advertisedIpRanges"] as core.List)
          .map<RouterAdvertisedIpRange>(
              (value) => new RouterAdvertisedIpRange.fromJson(value))
          .toList();
    }
    if (_json.containsKey("asn")) {
      asn = _json["asn"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (advertiseMode != null) {
      _json["advertiseMode"] = advertiseMode;
    }
    if (advertisedGroups != null) {
      _json["advertisedGroups"] = advertisedGroups;
    }
    if (advertisedIpRanges != null) {
      _json["advertisedIpRanges"] =
          advertisedIpRanges.map((value) => (value).toJson()).toList();
    }
    if (asn != null) {
      _json["asn"] = asn;
    }
    return _json;
  }
}

class RouterBgpPeer {
  /// User-specified flag to indicate which mode to use for advertisement.
  /// Possible string values are:
  /// - "CUSTOM"
  /// - "DEFAULT"
  core.String advertiseMode;

  /// User-specified list of prefix groups to advertise in custom mode, which
  /// can take one of the following options:
  /// - ALL_SUBNETS: Advertises all available subnets, including peer VPC
  /// subnets.
  /// - ALL_VPC_SUBNETS: Advertises the router's own VPC subnets.
  /// - ALL_PEER_VPC_SUBNETS: Advertises peer subnets of the router's VPC
  /// network. Note that this field can only be populated if advertise_mode is
  /// CUSTOM and overrides the list defined for the router (in the "bgp"
  /// message). These groups are advertised in addition to any specified
  /// prefixes. Leave this field blank to advertise no custom groups.
  core.List<core.String> advertisedGroups;

  /// User-specified list of individual IP ranges to advertise in custom mode.
  /// This field can only be populated if advertise_mode is CUSTOM and overrides
  /// the list defined for the router (in the "bgp" message). These IP ranges
  /// are advertised in addition to any specified groups. Leave this field blank
  /// to advertise no custom IP ranges.
  core.List<RouterAdvertisedIpRange> advertisedIpRanges;

  /// The priority of routes advertised to this BGP peer. Where there is more
  /// than one matching route of maximum length, the routes with the lowest
  /// priority value win.
  core.int advertisedRoutePriority;

  /// Name of the interface the BGP peer is associated with.
  core.String interfaceName;

  /// IP address of the interface inside Google Cloud Platform. Only IPv4 is
  /// supported.
  core.String ipAddress;

  /// [Output Only] The resource that configures and manages this BGP peer.
  /// - MANAGED_BY_USER is the default value and can be managed by you or other
  /// users
  /// - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed by
  /// Cloud Interconnect, specifically by an InterconnectAttachment of type
  /// PARTNER. Google automatically creates, updates, and deletes this type of
  /// BGP peer when the PARTNER InterconnectAttachment is created, updated, or
  /// deleted.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT"
  /// - "MANAGED_BY_USER"
  core.String managementType;

  /// Name of this BGP peer. The name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// Peer BGP Autonomous System Number (ASN). Each BGP interface may use a
  /// different value.
  core.int peerAsn;

  /// IP address of the BGP interface outside Google Cloud Platform. Only IPv4
  /// is supported.
  core.String peerIpAddress;

  RouterBgpPeer();

  RouterBgpPeer.fromJson(core.Map _json) {
    if (_json.containsKey("advertiseMode")) {
      advertiseMode = _json["advertiseMode"];
    }
    if (_json.containsKey("advertisedGroups")) {
      advertisedGroups =
          (_json["advertisedGroups"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("advertisedIpRanges")) {
      advertisedIpRanges = (_json["advertisedIpRanges"] as core.List)
          .map<RouterAdvertisedIpRange>(
              (value) => new RouterAdvertisedIpRange.fromJson(value))
          .toList();
    }
    if (_json.containsKey("advertisedRoutePriority")) {
      advertisedRoutePriority = _json["advertisedRoutePriority"];
    }
    if (_json.containsKey("interfaceName")) {
      interfaceName = _json["interfaceName"];
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
    if (_json.containsKey("managementType")) {
      managementType = _json["managementType"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peerAsn")) {
      peerAsn = _json["peerAsn"];
    }
    if (_json.containsKey("peerIpAddress")) {
      peerIpAddress = _json["peerIpAddress"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (advertiseMode != null) {
      _json["advertiseMode"] = advertiseMode;
    }
    if (advertisedGroups != null) {
      _json["advertisedGroups"] = advertisedGroups;
    }
    if (advertisedIpRanges != null) {
      _json["advertisedIpRanges"] =
          advertisedIpRanges.map((value) => (value).toJson()).toList();
    }
    if (advertisedRoutePriority != null) {
      _json["advertisedRoutePriority"] = advertisedRoutePriority;
    }
    if (interfaceName != null) {
      _json["interfaceName"] = interfaceName;
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    if (managementType != null) {
      _json["managementType"] = managementType;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peerAsn != null) {
      _json["peerAsn"] = peerAsn;
    }
    if (peerIpAddress != null) {
      _json["peerIpAddress"] = peerIpAddress;
    }
    return _json;
  }
}

class RouterInterface {
  /// IP address and range of the interface. The IP range must be in the RFC3927
  /// link-local IP address space. The value must be a CIDR-formatted string,
  /// for example: 169.254.0.1/30. NOTE: Do not truncate the address as it
  /// represents the IP address of the interface.
  core.String ipRange;

  /// URI of the linked Interconnect attachment. It must be in the same region
  /// as the router. Each interface can have one linked resource, which can be a
  /// VPN tunnel, an Interconnect attachment, or a virtual machine instance.
  core.String linkedInterconnectAttachment;

  /// URI of the linked VPN tunnel, which must be in the same region as the
  /// router. Each interface can have one linked resource, which can be a VPN
  /// tunnel, an Interconnect attachment, or a virtual machine instance.
  core.String linkedVpnTunnel;

  /// [Output Only] The resource that configures and manages this interface.
  /// - MANAGED_BY_USER is the default value and can be managed directly by
  /// users.
  /// - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by
  /// Cloud Interconnect, specifically, by an InterconnectAttachment of type
  /// PARTNER. Google automatically creates, updates, and deletes this type of
  /// interface when the PARTNER InterconnectAttachment is created, updated, or
  /// deleted.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT"
  /// - "MANAGED_BY_USER"
  core.String managementType;

  /// Name of this interface entry. The name must be 1-63 characters long, and
  /// comply with RFC1035. Specifically, the name must be 1-63 characters long
  /// and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
  /// the first character must be a lowercase letter, and all following
  /// characters must be a dash, lowercase letter, or digit, except the last
  /// character, which cannot be a dash.
  core.String name;

  RouterInterface();

  RouterInterface.fromJson(core.Map _json) {
    if (_json.containsKey("ipRange")) {
      ipRange = _json["ipRange"];
    }
    if (_json.containsKey("linkedInterconnectAttachment")) {
      linkedInterconnectAttachment = _json["linkedInterconnectAttachment"];
    }
    if (_json.containsKey("linkedVpnTunnel")) {
      linkedVpnTunnel = _json["linkedVpnTunnel"];
    }
    if (_json.containsKey("managementType")) {
      managementType = _json["managementType"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipRange != null) {
      _json["ipRange"] = ipRange;
    }
    if (linkedInterconnectAttachment != null) {
      _json["linkedInterconnectAttachment"] = linkedInterconnectAttachment;
    }
    if (linkedVpnTunnel != null) {
      _json["linkedVpnTunnel"] = linkedVpnTunnel;
    }
    if (managementType != null) {
      _json["managementType"] = managementType;
    }
    if (name != null) {
      _json["name"] = name;
    }
    return _json;
  }
}

class RouterListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouterListWarningData();

  RouterListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouterListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouterListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouterListWarning();

  RouterListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RouterListWarningData>(
              (value) => new RouterListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Router resources.
class RouterList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Router resources.
  core.List<Router> items;

  /// [Output Only] Type of resource. Always compute#router for routers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RouterListWarning warning;

  RouterList();

  RouterList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Router>((value) => new Router.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new RouterListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Nat resource. It enables the VMs within the specified
/// subnetworks to access Internet without external IP addresses. It specifies a
/// list of subnetworks (and the ranges within) that want to use NAT. Customers
/// can also provide the external IPs that would be used for NAT. GCP would
/// auto-allocate ephemeral IPs if no external IPs are provided.
class RouterNat {
  /// A list of URLs of the IP resources to be drained. These IPs must be valid
  /// static external IPs that have been assigned to the NAT. These IPs should
  /// be used for updating/patching a NAT only.
  core.List<core.String> drainNatIps;

  /// Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.
  core.int icmpIdleTimeoutSec;

  /// Configure logging on this NAT.
  RouterNatLogConfig logConfig;

  /// Minimum number of ports allocated to a VM from this NAT config. If not
  /// set, a default number of ports is allocated to a VM. This is rounded up to
  /// the nearest power of 2. For example, if the value of this field is 50, at
  /// least 64 ports are allocated to a VM.
  core.int minPortsPerVm;

  /// Unique name of this Nat service. The name must be 1-63 characters long and
  /// comply with RFC1035.
  core.String name;

  /// Specify the NatIpAllocateOption, which can take one of the following
  /// values:
  /// - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When
  /// there are not enough specified Nat IPs, the Nat service fails for new VMs.
  /// - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers
  /// can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be
  /// empty.
  /// Possible string values are:
  /// - "AUTO_ONLY"
  /// - "MANUAL_ONLY"
  core.String natIpAllocateOption;

  /// A list of URLs of the IP resources used for this Nat service. These IP
  /// addresses must be valid static external IP addresses assigned to the
  /// project.
  core.List<core.String> natIps;

  /// Specify the Nat option, which can take one of the following values:
  /// - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork
  /// are allowed to Nat.
  /// - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in
  /// every Subnetwork are allowed to Nat.
  /// - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified
  /// in the field subnetwork below) The default is
  /// SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field
  /// contains ALL_SUBNETWORKS_ALL_IP_RANGES or
  /// ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other
  /// Router.Nat section in any Router for this network in this region.
  /// Possible string values are:
  /// - "ALL_SUBNETWORKS_ALL_IP_RANGES"
  /// - "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES"
  /// - "LIST_OF_SUBNETWORKS"
  core.String sourceSubnetworkIpRangesToNat;

  /// A list of Subnetwork resources whose traffic should be translated by NAT
  /// Gateway. It is used only when LIST_OF_SUBNETWORKS is selected for the
  /// SubnetworkIpRangeToNatOption above.
  core.List<RouterNatSubnetworkToNat> subnetworks;

  /// Timeout (in seconds) for TCP established connections. Defaults to 1200s if
  /// not set.
  core.int tcpEstablishedIdleTimeoutSec;

  /// Timeout (in seconds) for TCP transitory connections. Defaults to 30s if
  /// not set.
  core.int tcpTransitoryIdleTimeoutSec;

  /// Timeout (in seconds) for UDP connections. Defaults to 30s if not set.
  core.int udpIdleTimeoutSec;

  RouterNat();

  RouterNat.fromJson(core.Map _json) {
    if (_json.containsKey("drainNatIps")) {
      drainNatIps = (_json["drainNatIps"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("icmpIdleTimeoutSec")) {
      icmpIdleTimeoutSec = _json["icmpIdleTimeoutSec"];
    }
    if (_json.containsKey("logConfig")) {
      logConfig = new RouterNatLogConfig.fromJson(_json["logConfig"]);
    }
    if (_json.containsKey("minPortsPerVm")) {
      minPortsPerVm = _json["minPortsPerVm"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("natIpAllocateOption")) {
      natIpAllocateOption = _json["natIpAllocateOption"];
    }
    if (_json.containsKey("natIps")) {
      natIps = (_json["natIps"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("sourceSubnetworkIpRangesToNat")) {
      sourceSubnetworkIpRangesToNat = _json["sourceSubnetworkIpRangesToNat"];
    }
    if (_json.containsKey("subnetworks")) {
      subnetworks = (_json["subnetworks"] as core.List)
          .map<RouterNatSubnetworkToNat>(
              (value) => new RouterNatSubnetworkToNat.fromJson(value))
          .toList();
    }
    if (_json.containsKey("tcpEstablishedIdleTimeoutSec")) {
      tcpEstablishedIdleTimeoutSec = _json["tcpEstablishedIdleTimeoutSec"];
    }
    if (_json.containsKey("tcpTransitoryIdleTimeoutSec")) {
      tcpTransitoryIdleTimeoutSec = _json["tcpTransitoryIdleTimeoutSec"];
    }
    if (_json.containsKey("udpIdleTimeoutSec")) {
      udpIdleTimeoutSec = _json["udpIdleTimeoutSec"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (drainNatIps != null) {
      _json["drainNatIps"] = drainNatIps;
    }
    if (icmpIdleTimeoutSec != null) {
      _json["icmpIdleTimeoutSec"] = icmpIdleTimeoutSec;
    }
    if (logConfig != null) {
      _json["logConfig"] = (logConfig).toJson();
    }
    if (minPortsPerVm != null) {
      _json["minPortsPerVm"] = minPortsPerVm;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (natIpAllocateOption != null) {
      _json["natIpAllocateOption"] = natIpAllocateOption;
    }
    if (natIps != null) {
      _json["natIps"] = natIps;
    }
    if (sourceSubnetworkIpRangesToNat != null) {
      _json["sourceSubnetworkIpRangesToNat"] = sourceSubnetworkIpRangesToNat;
    }
    if (subnetworks != null) {
      _json["subnetworks"] =
          subnetworks.map((value) => (value).toJson()).toList();
    }
    if (tcpEstablishedIdleTimeoutSec != null) {
      _json["tcpEstablishedIdleTimeoutSec"] = tcpEstablishedIdleTimeoutSec;
    }
    if (tcpTransitoryIdleTimeoutSec != null) {
      _json["tcpTransitoryIdleTimeoutSec"] = tcpTransitoryIdleTimeoutSec;
    }
    if (udpIdleTimeoutSec != null) {
      _json["udpIdleTimeoutSec"] = udpIdleTimeoutSec;
    }
    return _json;
  }
}

/// Configuration of logging on a NAT.
class RouterNatLogConfig {
  /// Indicates whether or not to export logs. This is false by default.
  core.bool enable;

  /// Specify the desired filtering of logs on this NAT. If unspecified, logs
  /// are exported for all connections handled by this NAT. This option can take
  /// one of the following values:
  /// - ERRORS_ONLY: Export logs only for connection failures.
  /// - TRANSLATIONS_ONLY: Export logs only for successful connections.
  /// - ALL: Export logs for all connections, successful and unsuccessful.
  /// Possible string values are:
  /// - "ALL"
  /// - "ERRORS_ONLY"
  /// - "TRANSLATIONS_ONLY"
  core.String filter;

  RouterNatLogConfig();

  RouterNatLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey("enable")) {
      enable = _json["enable"];
    }
    if (_json.containsKey("filter")) {
      filter = _json["filter"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (enable != null) {
      _json["enable"] = enable;
    }
    if (filter != null) {
      _json["filter"] = filter;
    }
    return _json;
  }
}

/// Defines the IP ranges that want to use NAT for a subnetwork.
class RouterNatSubnetworkToNat {
  /// URL for the subnetwork resource that will use NAT.
  core.String name;

  /// A list of the secondary ranges of the Subnetwork that are allowed to use
  /// NAT. This can be populated only if "LIST_OF_SECONDARY_IP_RANGES" is one of
  /// the values in source_ip_ranges_to_nat.
  core.List<core.String> secondaryIpRangeNames;

  /// Specify the options for NAT ranges in the Subnetwork. All options of a
  /// single value are valid except NAT_IP_RANGE_OPTION_UNSPECIFIED. The only
  /// valid option with multiple values is: ["PRIMARY_IP_RANGE",
  /// "LIST_OF_SECONDARY_IP_RANGES"] Default: [ALL_IP_RANGES]
  core.List<core.String> sourceIpRangesToNat;

  RouterNatSubnetworkToNat();

  RouterNatSubnetworkToNat.fromJson(core.Map _json) {
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("secondaryIpRangeNames")) {
      secondaryIpRangeNames =
          (_json["secondaryIpRangeNames"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("sourceIpRangesToNat")) {
      sourceIpRangesToNat =
          (_json["sourceIpRangesToNat"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (name != null) {
      _json["name"] = name;
    }
    if (secondaryIpRangeNames != null) {
      _json["secondaryIpRangeNames"] = secondaryIpRangeNames;
    }
    if (sourceIpRangesToNat != null) {
      _json["sourceIpRangesToNat"] = sourceIpRangesToNat;
    }
    return _json;
  }
}

class RouterStatus {
  /// Best routes for this router's network.
  core.List<Route> bestRoutes;

  /// Best routes learned by this router.
  core.List<Route> bestRoutesForRouter;
  core.List<RouterStatusBgpPeerStatus> bgpPeerStatus;
  core.List<RouterStatusNatStatus> natStatus;

  /// URI of the network to which this router belongs.
  core.String network;

  RouterStatus();

  RouterStatus.fromJson(core.Map _json) {
    if (_json.containsKey("bestRoutes")) {
      bestRoutes = (_json["bestRoutes"] as core.List)
          .map<Route>((value) => new Route.fromJson(value))
          .toList();
    }
    if (_json.containsKey("bestRoutesForRouter")) {
      bestRoutesForRouter = (_json["bestRoutesForRouter"] as core.List)
          .map<Route>((value) => new Route.fromJson(value))
          .toList();
    }
    if (_json.containsKey("bgpPeerStatus")) {
      bgpPeerStatus = (_json["bgpPeerStatus"] as core.List)
          .map<RouterStatusBgpPeerStatus>(
              (value) => new RouterStatusBgpPeerStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("natStatus")) {
      natStatus = (_json["natStatus"] as core.List)
          .map<RouterStatusNatStatus>(
              (value) => new RouterStatusNatStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bestRoutes != null) {
      _json["bestRoutes"] =
          bestRoutes.map((value) => (value).toJson()).toList();
    }
    if (bestRoutesForRouter != null) {
      _json["bestRoutesForRouter"] =
          bestRoutesForRouter.map((value) => (value).toJson()).toList();
    }
    if (bgpPeerStatus != null) {
      _json["bgpPeerStatus"] =
          bgpPeerStatus.map((value) => (value).toJson()).toList();
    }
    if (natStatus != null) {
      _json["natStatus"] = natStatus.map((value) => (value).toJson()).toList();
    }
    if (network != null) {
      _json["network"] = network;
    }
    return _json;
  }
}

class RouterStatusBgpPeerStatus {
  /// Routes that were advertised to the remote BGP peer
  core.List<Route> advertisedRoutes;

  /// IP address of the local BGP interface.
  core.String ipAddress;

  /// URL of the VPN tunnel that this BGP peer controls.
  core.String linkedVpnTunnel;

  /// Name of this BGP peer. Unique within the Routers resource.
  core.String name;

  /// Number of routes learned from the remote BGP Peer.
  core.int numLearnedRoutes;

  /// IP address of the remote BGP interface.
  core.String peerIpAddress;

  /// BGP state as specified in RFC1771.
  core.String state;

  /// Status of the BGP peer: {UP, DOWN}
  /// Possible string values are:
  /// - "DOWN"
  /// - "UNKNOWN"
  /// - "UP"
  core.String status;

  /// Time this session has been up. Format: 14 years, 51 weeks, 6 days, 23
  /// hours, 59 minutes, 59 seconds
  core.String uptime;

  /// Time this session has been up, in seconds. Format: 145
  core.String uptimeSeconds;

  RouterStatusBgpPeerStatus();

  RouterStatusBgpPeerStatus.fromJson(core.Map _json) {
    if (_json.containsKey("advertisedRoutes")) {
      advertisedRoutes = (_json["advertisedRoutes"] as core.List)
          .map<Route>((value) => new Route.fromJson(value))
          .toList();
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
    if (_json.containsKey("linkedVpnTunnel")) {
      linkedVpnTunnel = _json["linkedVpnTunnel"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("numLearnedRoutes")) {
      numLearnedRoutes = _json["numLearnedRoutes"];
    }
    if (_json.containsKey("peerIpAddress")) {
      peerIpAddress = _json["peerIpAddress"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("uptime")) {
      uptime = _json["uptime"];
    }
    if (_json.containsKey("uptimeSeconds")) {
      uptimeSeconds = _json["uptimeSeconds"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (advertisedRoutes != null) {
      _json["advertisedRoutes"] =
          advertisedRoutes.map((value) => (value).toJson()).toList();
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    if (linkedVpnTunnel != null) {
      _json["linkedVpnTunnel"] = linkedVpnTunnel;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (numLearnedRoutes != null) {
      _json["numLearnedRoutes"] = numLearnedRoutes;
    }
    if (peerIpAddress != null) {
      _json["peerIpAddress"] = peerIpAddress;
    }
    if (state != null) {
      _json["state"] = state;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (uptime != null) {
      _json["uptime"] = uptime;
    }
    if (uptimeSeconds != null) {
      _json["uptimeSeconds"] = uptimeSeconds;
    }
    return _json;
  }
}

/// Status of a NAT contained in this router. Next tag: 9
class RouterStatusNatStatus {
  /// A list of IPs auto-allocated for NAT. Example: ["1.1.1.1", "129.2.16.89"]
  core.List<core.String> autoAllocatedNatIps;

  /// A list of IPs auto-allocated for NAT that are in drain mode. Example:
  /// ["1.1.1.1", "179.12.26.133"].
  core.List<core.String> drainAutoAllocatedNatIps;

  /// A list of IPs user-allocated for NAT that are in drain mode. Example:
  /// ["1.1.1.1", "179.12.26.133"].
  core.List<core.String> drainUserAllocatedNatIps;

  /// The number of extra IPs to allocate. This will be greater than 0 only if
  /// user-specified IPs are NOT enough to allow all configured VMs to use NAT.
  /// This value is meaningful only when auto-allocation of NAT IPs is *not*
  /// used.
  core.int minExtraNatIpsNeeded;

  /// Unique name of this NAT.
  core.String name;

  /// Number of VM endpoints (i.e., Nics) that can use NAT.
  core.int numVmEndpointsWithNatMappings;

  /// A list of fully qualified URLs of reserved IP address resources.
  core.List<core.String> userAllocatedNatIpResources;

  /// A list of IPs user-allocated for NAT. They will be raw IP strings like
  /// "179.12.26.133".
  core.List<core.String> userAllocatedNatIps;

  RouterStatusNatStatus();

  RouterStatusNatStatus.fromJson(core.Map _json) {
    if (_json.containsKey("autoAllocatedNatIps")) {
      autoAllocatedNatIps =
          (_json["autoAllocatedNatIps"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("drainAutoAllocatedNatIps")) {
      drainAutoAllocatedNatIps =
          (_json["drainAutoAllocatedNatIps"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("drainUserAllocatedNatIps")) {
      drainUserAllocatedNatIps =
          (_json["drainUserAllocatedNatIps"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("minExtraNatIpsNeeded")) {
      minExtraNatIpsNeeded = _json["minExtraNatIpsNeeded"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("numVmEndpointsWithNatMappings")) {
      numVmEndpointsWithNatMappings = _json["numVmEndpointsWithNatMappings"];
    }
    if (_json.containsKey("userAllocatedNatIpResources")) {
      userAllocatedNatIpResources =
          (_json["userAllocatedNatIpResources"] as core.List)
              .cast<core.String>();
    }
    if (_json.containsKey("userAllocatedNatIps")) {
      userAllocatedNatIps =
          (_json["userAllocatedNatIps"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoAllocatedNatIps != null) {
      _json["autoAllocatedNatIps"] = autoAllocatedNatIps;
    }
    if (drainAutoAllocatedNatIps != null) {
      _json["drainAutoAllocatedNatIps"] = drainAutoAllocatedNatIps;
    }
    if (drainUserAllocatedNatIps != null) {
      _json["drainUserAllocatedNatIps"] = drainUserAllocatedNatIps;
    }
    if (minExtraNatIpsNeeded != null) {
      _json["minExtraNatIpsNeeded"] = minExtraNatIpsNeeded;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (numVmEndpointsWithNatMappings != null) {
      _json["numVmEndpointsWithNatMappings"] = numVmEndpointsWithNatMappings;
    }
    if (userAllocatedNatIpResources != null) {
      _json["userAllocatedNatIpResources"] = userAllocatedNatIpResources;
    }
    if (userAllocatedNatIps != null) {
      _json["userAllocatedNatIps"] = userAllocatedNatIps;
    }
    return _json;
  }
}

class RouterStatusResponse {
  /// Type of resource.
  core.String kind;
  RouterStatus result;

  RouterStatusResponse();

  RouterStatusResponse.fromJson(core.Map _json) {
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("result")) {
      result = new RouterStatus.fromJson(_json["result"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (result != null) {
      _json["result"] = (result).toJson();
    }
    return _json;
  }
}

class RoutersPreviewResponse {
  /// Preview of given router.
  Router resource;

  RoutersPreviewResponse();

  RoutersPreviewResponse.fromJson(core.Map _json) {
    if (_json.containsKey("resource")) {
      resource = new Router.fromJson(_json["resource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resource != null) {
      _json["resource"] = (resource).toJson();
    }
    return _json;
  }
}

class RoutersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RoutersScopedListWarningData();

  RoutersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of routers when the list is
/// empty.
class RoutersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RoutersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RoutersScopedListWarning();

  RoutersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<RoutersScopedListWarningData>(
              (value) => new RoutersScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class RoutersScopedList {
  /// A list of routers contained in this scope.
  core.List<Router> routers;

  /// Informational warning which replaces the list of routers when the list is
  /// empty.
  RoutersScopedListWarning warning;

  RoutersScopedList();

  RoutersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("routers")) {
      routers = (_json["routers"] as core.List)
          .map<Router>((value) => new Router.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new RoutersScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (routers != null) {
      _json["routers"] = routers.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A rule to be applied in a Policy.
class Rule {
  /// Required
  /// Possible string values are:
  /// - "ALLOW"
  /// - "ALLOW_WITH_LOG"
  /// - "DENY"
  /// - "DENY_WITH_LOG"
  /// - "LOG"
  /// - "NO_ACTION"
  core.String action;

  /// Additional restrictions that must be met. All conditions must pass for the
  /// rule to match.
  core.List<Condition> conditions;

  /// Human-readable description of the rule.
  core.String description;

  /// If one or more 'in' clauses are specified, the rule matches if the
  /// PRINCIPAL/AUTHORITY_SELECTOR is in at least one of these entries.
  core.List<core.String> ins;

  /// The config returned to callers of tech.iam.IAM.CheckPolicy for any entries
  /// that match the LOG action.
  core.List<LogConfig> logConfigs;

  /// If one or more 'not_in' clauses are specified, the rule matches if the
  /// PRINCIPAL/AUTHORITY_SELECTOR is in none of the entries.
  core.List<core.String> notIns;

  /// A permission is a string of form '..' (e.g., 'storage.buckets.list'). A
  /// value of '*' matches all permissions, and a verb part of '*' (e.g.,
  /// 'storage.buckets.*') matches all verbs.
  core.List<core.String> permissions;

  Rule();

  Rule.fromJson(core.Map _json) {
    if (_json.containsKey("action")) {
      action = _json["action"];
    }
    if (_json.containsKey("conditions")) {
      conditions = (_json["conditions"] as core.List)
          .map<Condition>((value) => new Condition.fromJson(value))
          .toList();
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("ins")) {
      ins = (_json["ins"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("logConfigs")) {
      logConfigs = (_json["logConfigs"] as core.List)
          .map<LogConfig>((value) => new LogConfig.fromJson(value))
          .toList();
    }
    if (_json.containsKey("notIns")) {
      notIns = (_json["notIns"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("permissions")) {
      permissions = (_json["permissions"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (action != null) {
      _json["action"] = action;
    }
    if (conditions != null) {
      _json["conditions"] =
          conditions.map((value) => (value).toJson()).toList();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (ins != null) {
      _json["ins"] = ins;
    }
    if (logConfigs != null) {
      _json["logConfigs"] =
          logConfigs.map((value) => (value).toJson()).toList();
    }
    if (notIns != null) {
      _json["notIns"] = notIns;
    }
    if (permissions != null) {
      _json["permissions"] = permissions;
    }
    return _json;
  }
}

class SSLHealthCheck {
  /// The TCP port number for the health check request. The default value is
  /// 443. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, SSL health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The application data to send once the SSL connection has been established
  /// (default value is empty). If both request and response are empty, the
  /// connection establishment alone will indicate health. The request data can
  /// only be ASCII.
  core.String request;

  /// The bytes to match against the beginning of the response data. If left
  /// empty (the default value), any response will indicate health. The response
  /// data can only be ASCII.
  core.String response;

  SSLHealthCheck();

  SSLHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("portSpecification")) {
      portSpecification = _json["portSpecification"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("request")) {
      request = _json["request"];
    }
    if (_json.containsKey("response")) {
      response = _json["response"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (portSpecification != null) {
      _json["portSpecification"] = portSpecification;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (request != null) {
      _json["request"] = request;
    }
    if (response != null) {
      _json["response"] = response;
    }
    return _json;
  }
}

/// Sets the scheduling options for an Instance. NextID: 10
class Scheduling {
  /// Specifies whether the instance should be automatically restarted if it is
  /// terminated by Compute Engine (not terminated by a user). You can only set
  /// the automatic restart option for standard instances. Preemptible instances
  /// cannot be automatically restarted.
  ///
  /// By default, this is set to true so an instance is automatically restarted
  /// if it is terminated by Compute Engine.
  core.bool automaticRestart;

  /// A set of node affinity and anti-affinity configurations. Refer to
  /// Configuring node affinity for more information. Overrides
  /// reservationAffinity.
  core.List<SchedulingNodeAffinity> nodeAffinities;

  /// Defines the maintenance behavior for this instance. For standard
  /// instances, the default behavior is MIGRATE. For preemptible instances, the
  /// default and only possible behavior is TERMINATE. For more information, see
  /// Setting Instance Scheduling Options.
  /// Possible string values are:
  /// - "MIGRATE"
  /// - "TERMINATE"
  core.String onHostMaintenance;

  /// Defines whether the instance is preemptible. This can only be set during
  /// instance creation, it cannot be set or changed after the instance has been
  /// created.
  core.bool preemptible;

  Scheduling();

  Scheduling.fromJson(core.Map _json) {
    if (_json.containsKey("automaticRestart")) {
      automaticRestart = _json["automaticRestart"];
    }
    if (_json.containsKey("nodeAffinities")) {
      nodeAffinities = (_json["nodeAffinities"] as core.List)
          .map<SchedulingNodeAffinity>(
              (value) => new SchedulingNodeAffinity.fromJson(value))
          .toList();
    }
    if (_json.containsKey("onHostMaintenance")) {
      onHostMaintenance = _json["onHostMaintenance"];
    }
    if (_json.containsKey("preemptible")) {
      preemptible = _json["preemptible"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (automaticRestart != null) {
      _json["automaticRestart"] = automaticRestart;
    }
    if (nodeAffinities != null) {
      _json["nodeAffinities"] =
          nodeAffinities.map((value) => (value).toJson()).toList();
    }
    if (onHostMaintenance != null) {
      _json["onHostMaintenance"] = onHostMaintenance;
    }
    if (preemptible != null) {
      _json["preemptible"] = preemptible;
    }
    return _json;
  }
}

/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled.
class SchedulingNodeAffinity {
  /// Corresponds to the label key of Node resource.
  core.String key;

  /// Defines the operation of node selection. Valid operators are IN for
  /// affinity and NOT_IN for anti-affinity.
  /// Possible string values are:
  /// - "IN"
  /// - "NOT_IN"
  /// - "OPERATOR_UNSPECIFIED"
  core.String operator;

  /// Corresponds to the label values of Node resource.
  core.List<core.String> values;

  SchedulingNodeAffinity();

  SchedulingNodeAffinity.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("operator")) {
      operator = _json["operator"];
    }
    if (_json.containsKey("values")) {
      values = (_json["values"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (operator != null) {
      _json["operator"] = operator;
    }
    if (values != null) {
      _json["values"] = values;
    }
    return _json;
  }
}

class SecurityPoliciesListPreconfiguredExpressionSetsResponse {
  SecurityPoliciesWafConfig preconfiguredExpressionSets;

  SecurityPoliciesListPreconfiguredExpressionSetsResponse();

  SecurityPoliciesListPreconfiguredExpressionSetsResponse.fromJson(
      core.Map _json) {
    if (_json.containsKey("preconfiguredExpressionSets")) {
      preconfiguredExpressionSets = new SecurityPoliciesWafConfig.fromJson(
          _json["preconfiguredExpressionSets"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (preconfiguredExpressionSets != null) {
      _json["preconfiguredExpressionSets"] =
          (preconfiguredExpressionSets).toJson();
    }
    return _json;
  }
}

class SecurityPoliciesWafConfig {
  PreconfiguredWafSet wafRules;

  SecurityPoliciesWafConfig();

  SecurityPoliciesWafConfig.fromJson(core.Map _json) {
    if (_json.containsKey("wafRules")) {
      wafRules = new PreconfiguredWafSet.fromJson(_json["wafRules"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (wafRules != null) {
      _json["wafRules"] = (wafRules).toJson();
    }
    return _json;
  }
}

/// Represents a Cloud Armor Security Policy resource.
///
/// Only external backend services that use load balancers can reference a
/// Security Policy. For more information, read  Cloud Armor Security Policy
/// Concepts. (== resource_for {$api_version}.securityPolicies ==)
class SecurityPolicy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking. The fingerprint
  /// is initially generated by Compute Engine and changes after every request
  /// to modify or update metadata. You must always provide an up-to-date
  /// fingerprint hash in order to update or change metadata, otherwise the
  /// request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make get() request to the security policy.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output only] Type of the resource. Always compute#securityPolicyfor
  /// security policies
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// A list of rules that belong to this policy. There must always be a default
  /// rule (rule with priority 2147483647 and match "*"). If no rules are
  /// provided when creating a security policy, a default rule with action
  /// "allow" will be added.
  core.List<SecurityPolicyRule> rules;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  SecurityPolicy();

  SecurityPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("rules")) {
      rules = (_json["rules"] as core.List)
          .map<SecurityPolicyRule>(
              (value) => new SecurityPolicyRule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (rules != null) {
      _json["rules"] = rules.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class SecurityPolicyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SecurityPolicyListWarningData();

  SecurityPolicyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SecurityPolicyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SecurityPolicyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SecurityPolicyListWarning();

  SecurityPolicyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SecurityPolicyListWarningData>(
              (value) => new SecurityPolicyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class SecurityPolicyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SecurityPolicy resources.
  core.List<SecurityPolicy> items;

  /// [Output Only] Type of resource. Always compute#securityPolicyList for
  /// listsof securityPolicies
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Informational warning message.
  SecurityPolicyListWarning warning;

  SecurityPolicyList();

  SecurityPolicyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<SecurityPolicy>((value) => new SecurityPolicy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("warning")) {
      warning = new SecurityPolicyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SecurityPolicyReference {
  core.String securityPolicy;

  SecurityPolicyReference();

  SecurityPolicyReference.fromJson(core.Map _json) {
    if (_json.containsKey("securityPolicy")) {
      securityPolicy = _json["securityPolicy"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (securityPolicy != null) {
      _json["securityPolicy"] = securityPolicy;
    }
    return _json;
  }
}

/// Represents a rule that describes one or more match conditions along with the
/// action to be taken when traffic matches this condition (allow or deny).
class SecurityPolicyRule {
  /// The Action to preform when the client connection triggers the rule. Can
  /// currently be either "allow" or "deny()" where valid values for status are
  /// 403, 404, and 502.
  core.String action;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output only] Type of the resource. Always compute#securityPolicyRule for
  /// security policy rules
  core.String kind;

  /// A match condition that incoming traffic is evaluated against. If it
  /// evaluates to true, the corresponding 'action' is enforced.
  SecurityPolicyRuleMatcher match;

  /// If set to true, the specified action is not enforced.
  core.bool preview;

  /// An integer indicating the priority of a rule in the list. The priority
  /// must be a positive value between 0 and 2147483647. Rules are evaluated
  /// from highest to lowest priority where 0 is the highest priority and
  /// 2147483647 is the lowest prority.
  core.int priority;

  SecurityPolicyRule();

  SecurityPolicyRule.fromJson(core.Map _json) {
    if (_json.containsKey("action")) {
      action = _json["action"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("match")) {
      match = new SecurityPolicyRuleMatcher.fromJson(_json["match"]);
    }
    if (_json.containsKey("preview")) {
      preview = _json["preview"];
    }
    if (_json.containsKey("priority")) {
      priority = _json["priority"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (action != null) {
      _json["action"] = action;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (match != null) {
      _json["match"] = (match).toJson();
    }
    if (preview != null) {
      _json["preview"] = preview;
    }
    if (priority != null) {
      _json["priority"] = priority;
    }
    return _json;
  }
}

/// Represents a match condition that incoming traffic is evaluated against.
/// Exactly one field must be specified.
class SecurityPolicyRuleMatcher {
  /// The configuration options available when specifying versioned_expr. This
  /// field must be specified if versioned_expr is specified and cannot be
  /// specified if versioned_expr is not specified.
  SecurityPolicyRuleMatcherConfig config;

  /// User defined CEVAL expression. A CEVAL expression is used to specify match
  /// criteria such as origin.ip, source.region_code and contents in the request
  /// header.
  Expr expr;

  /// Preconfigured versioned expression. If this field is specified, config
  /// must also be specified. Available preconfigured expressions along with
  /// their requirements are: SRC_IPS_V1 - must specify the corresponding
  /// src_ip_range field in config.
  /// Possible string values are:
  /// - "SRC_IPS_V1"
  core.String versionedExpr;

  SecurityPolicyRuleMatcher();

  SecurityPolicyRuleMatcher.fromJson(core.Map _json) {
    if (_json.containsKey("config")) {
      config = new SecurityPolicyRuleMatcherConfig.fromJson(_json["config"]);
    }
    if (_json.containsKey("expr")) {
      expr = new Expr.fromJson(_json["expr"]);
    }
    if (_json.containsKey("versionedExpr")) {
      versionedExpr = _json["versionedExpr"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (config != null) {
      _json["config"] = (config).toJson();
    }
    if (expr != null) {
      _json["expr"] = (expr).toJson();
    }
    if (versionedExpr != null) {
      _json["versionedExpr"] = versionedExpr;
    }
    return _json;
  }
}

class SecurityPolicyRuleMatcherConfig {
  /// CIDR IP address range.
  core.List<core.String> srcIpRanges;

  SecurityPolicyRuleMatcherConfig();

  SecurityPolicyRuleMatcherConfig.fromJson(core.Map _json) {
    if (_json.containsKey("srcIpRanges")) {
      srcIpRanges = (_json["srcIpRanges"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (srcIpRanges != null) {
      _json["srcIpRanges"] = srcIpRanges;
    }
    return _json;
  }
}

/// An instance's serial console output.
class SerialPortOutput {
  /// [Output Only] The contents of the console output.
  core.String contents;

  /// [Output Only] Type of the resource. Always compute#serialPortOutput for
  /// serial port output.
  core.String kind;

  /// [Output Only] The position of the next byte of content from the serial
  /// console output. Use this value in the next request as the start parameter.
  core.String next;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// The starting byte position of the output that was returned. This should
  /// match the start parameter sent with the request. If the serial console
  /// output exceeds the size of the buffer, older output will be overwritten by
  /// newer content and the start values will be mismatched.
  core.String start;

  SerialPortOutput();

  SerialPortOutput.fromJson(core.Map _json) {
    if (_json.containsKey("contents")) {
      contents = _json["contents"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("next")) {
      next = _json["next"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("start")) {
      start = _json["start"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (contents != null) {
      _json["contents"] = contents;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (next != null) {
      _json["next"] = next;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (start != null) {
      _json["start"] = start;
    }
    return _json;
  }
}

class ServerBinding {
  ///
  /// Possible string values are:
  /// - "RESTART_NODE_ON_ANY_SERVER"
  /// - "RESTART_NODE_ON_MINIMAL_SERVERS"
  /// - "SERVER_BINDING_TYPE_UNSPECIFIED"
  core.String type;

  ServerBinding();

  ServerBinding.fromJson(core.Map _json) {
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

/// A service account.
class ServiceAccount {
  /// Email address of the service account.
  core.String email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String> scopes;

  ServiceAccount();

  ServiceAccount.fromJson(core.Map _json) {
    if (_json.containsKey("email")) {
      email = _json["email"];
    }
    if (_json.containsKey("scopes")) {
      scopes = (_json["scopes"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (email != null) {
      _json["email"] = email;
    }
    if (scopes != null) {
      _json["scopes"] = scopes;
    }
    return _json;
  }
}

/// A set of Shielded Instance options.
class ShieldedInstanceConfig {
  /// Defines whether the instance has integrity monitoring enabled.
  core.bool enableIntegrityMonitoring;

  /// Defines whether the instance has Secure Boot enabled.
  core.bool enableSecureBoot;

  /// Defines whether the instance has the vTPM enabled.
  core.bool enableVtpm;

  ShieldedInstanceConfig();

  ShieldedInstanceConfig.fromJson(core.Map _json) {
    if (_json.containsKey("enableIntegrityMonitoring")) {
      enableIntegrityMonitoring = _json["enableIntegrityMonitoring"];
    }
    if (_json.containsKey("enableSecureBoot")) {
      enableSecureBoot = _json["enableSecureBoot"];
    }
    if (_json.containsKey("enableVtpm")) {
      enableVtpm = _json["enableVtpm"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (enableIntegrityMonitoring != null) {
      _json["enableIntegrityMonitoring"] = enableIntegrityMonitoring;
    }
    if (enableSecureBoot != null) {
      _json["enableSecureBoot"] = enableSecureBoot;
    }
    if (enableVtpm != null) {
      _json["enableVtpm"] = enableVtpm;
    }
    return _json;
  }
}

/// A shielded Instance identity entry.
class ShieldedInstanceIdentity {
  /// An Endorsement Key (EK) made by the RSA 2048 algorithm issued to the
  /// Shielded Instance's vTPM.
  ShieldedInstanceIdentityEntry encryptionKey;

  /// [Output Only] Type of the resource. Always
  /// compute#shieldedInstanceIdentity for shielded Instance identity entry.
  core.String kind;

  /// An Attestation Key (AK) made by the RSA 2048 algorithm issued to the
  /// Shielded Instance's vTPM.
  ShieldedInstanceIdentityEntry signingKey;

  ShieldedInstanceIdentity();

  ShieldedInstanceIdentity.fromJson(core.Map _json) {
    if (_json.containsKey("encryptionKey")) {
      encryptionKey =
          new ShieldedInstanceIdentityEntry.fromJson(_json["encryptionKey"]);
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("signingKey")) {
      signingKey =
          new ShieldedInstanceIdentityEntry.fromJson(_json["signingKey"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (encryptionKey != null) {
      _json["encryptionKey"] = (encryptionKey).toJson();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (signingKey != null) {
      _json["signingKey"] = (signingKey).toJson();
    }
    return _json;
  }
}

/// A Shielded Instance Identity Entry.
class ShieldedInstanceIdentityEntry {
  /// A PEM-encoded X.509 certificate. This field can be empty.
  core.String ekCert;

  /// A PEM-encoded public key.
  core.String ekPub;

  ShieldedInstanceIdentityEntry();

  ShieldedInstanceIdentityEntry.fromJson(core.Map _json) {
    if (_json.containsKey("ekCert")) {
      ekCert = _json["ekCert"];
    }
    if (_json.containsKey("ekPub")) {
      ekPub = _json["ekPub"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ekCert != null) {
      _json["ekCert"] = ekCert;
    }
    if (ekPub != null) {
      _json["ekPub"] = ekPub;
    }
    return _json;
  }
}

/// The policy describes the baseline against which Instance boot integrity is
/// measured.
class ShieldedInstanceIntegrityPolicy {
  /// Updates the integrity policy baseline using the measurements from the VM
  /// instance's most recent boot.
  core.bool updateAutoLearnPolicy;

  ShieldedInstanceIntegrityPolicy();

  ShieldedInstanceIntegrityPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("updateAutoLearnPolicy")) {
      updateAutoLearnPolicy = _json["updateAutoLearnPolicy"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (updateAutoLearnPolicy != null) {
      _json["updateAutoLearnPolicy"] = updateAutoLearnPolicy;
    }
    return _json;
  }
}

/// Represents a customer-supplied Signing Key used by Cloud CDN Signed URLs
class SignedUrlKey {
  /// Name of the key. The name must be 1-63 characters long, and comply with
  /// RFC1035. Specifically, the name must be 1-63 characters long and match the
  /// regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
  /// character must be a lowercase letter, and all following characters must be
  /// a dash, lowercase letter, or digit, except the last character, which
  /// cannot be a dash.
  core.String keyName;

  /// 128-bit key value used for signing the URL. The key value must be a valid
  /// RFC 4648 Section 5 base64url encoded string.
  core.String keyValue;

  SignedUrlKey();

  SignedUrlKey.fromJson(core.Map _json) {
    if (_json.containsKey("keyName")) {
      keyName = _json["keyName"];
    }
    if (_json.containsKey("keyValue")) {
      keyValue = _json["keyValue"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (keyName != null) {
      _json["keyName"] = keyName;
    }
    if (keyValue != null) {
      _json["keyValue"] = keyValue;
    }
    return _json;
  }
}

/// Represents a Persistent Disk Snapshot resource.
///
/// You can use snapshots to back up data on a regular interval. For more
/// information, read  Creating persistent disk snapshots. (== resource_for
/// {$api_version}.snapshots ==)
class Snapshot {
  /// [Output Only] Set to true if snapshots are automatically created by
  /// applying resource policy on the target disk.
  core.bool autoCreated;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Size of the source disk, specified in GB.
  core.String diskSizeGb;

  /// [Output Only] Number of bytes downloaded to restore a snapshot to a disk.
  core.String downloadBytes;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#snapshot for Snapshot
  /// resources.
  core.String kind;

  /// A fingerprint for the labels being applied to this snapshot, which is
  /// essentially a hash of the labels set used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// snapshot.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels to apply to this snapshot. These can be later modified by the
  /// setLabels method. Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// [Output Only] Integer license codes indicating which licenses are attached
  /// to this snapshot.
  core.List<core.String> licenseCodes;

  /// [Output Only] A list of public visible licenses that apply to this
  /// snapshot. This can be because the original image had licenses attached
  /// (such as a Windows image).
  core.List<core.String> licenses;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Encrypts the snapshot using a customer-supplied encryption key.
  ///
  /// After you encrypt a snapshot using a customer-supplied key, you must
  /// provide the same key if you use the snapshot later. For example, you must
  /// provide the encryption key when you create a disk from the encrypted
  /// snapshot in a future request.
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// snapshot.
  ///
  /// If you do not provide an encryption key when creating the snapshot, then
  /// the snapshot will be encrypted using an automatically generated key and
  /// you do not need to provide a key to use the snapshot later.
  CustomerEncryptionKey snapshotEncryptionKey;

  /// [Output Only] The source disk used to create this snapshot.
  core.String sourceDisk;

  /// The customer-supplied encryption key of the source disk. Required if the
  /// source disk is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceDiskEncryptionKey;

  /// [Output Only] The ID value of the disk used to create this snapshot. This
  /// value may be used to determine whether the snapshot was taken from the
  /// current or a previous instance of a given disk name.
  core.String sourceDiskId;

  /// [Output Only] The status of the snapshot. This can be CREATING, DELETING,
  /// FAILED, READY, or UPLOADING.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  /// - "UPLOADING"
  core.String status;

  /// [Output Only] A size of the storage used by the snapshot. As snapshots
  /// share storage, this number is expected to change with snapshot
  /// creation/deletion.
  core.String storageBytes;

  /// [Output Only] An indicator whether storageBytes is in a stable state or it
  /// is being adjusted as a result of shared storage reallocation. This status
  /// can either be UPDATING, meaning the size of the snapshot is being updated,
  /// or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
  /// Possible string values are:
  /// - "UPDATING"
  /// - "UP_TO_DATE"
  core.String storageBytesStatus;

  /// Cloud Storage bucket storage location of the snapshot (regional or
  /// multi-regional).
  core.List<core.String> storageLocations;

  Snapshot();

  Snapshot.fromJson(core.Map _json) {
    if (_json.containsKey("autoCreated")) {
      autoCreated = _json["autoCreated"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("diskSizeGb")) {
      diskSizeGb = _json["diskSizeGb"];
    }
    if (_json.containsKey("downloadBytes")) {
      downloadBytes = _json["downloadBytes"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("licenseCodes")) {
      licenseCodes = (_json["licenseCodes"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("licenses")) {
      licenses = (_json["licenses"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("snapshotEncryptionKey")) {
      snapshotEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["snapshotEncryptionKey"]);
    }
    if (_json.containsKey("sourceDisk")) {
      sourceDisk = _json["sourceDisk"];
    }
    if (_json.containsKey("sourceDiskEncryptionKey")) {
      sourceDiskEncryptionKey =
          new CustomerEncryptionKey.fromJson(_json["sourceDiskEncryptionKey"]);
    }
    if (_json.containsKey("sourceDiskId")) {
      sourceDiskId = _json["sourceDiskId"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("storageBytes")) {
      storageBytes = _json["storageBytes"];
    }
    if (_json.containsKey("storageBytesStatus")) {
      storageBytesStatus = _json["storageBytesStatus"];
    }
    if (_json.containsKey("storageLocations")) {
      storageLocations =
          (_json["storageLocations"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (autoCreated != null) {
      _json["autoCreated"] = autoCreated;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (diskSizeGb != null) {
      _json["diskSizeGb"] = diskSizeGb;
    }
    if (downloadBytes != null) {
      _json["downloadBytes"] = downloadBytes;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (licenseCodes != null) {
      _json["licenseCodes"] = licenseCodes;
    }
    if (licenses != null) {
      _json["licenses"] = licenses;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (snapshotEncryptionKey != null) {
      _json["snapshotEncryptionKey"] = (snapshotEncryptionKey).toJson();
    }
    if (sourceDisk != null) {
      _json["sourceDisk"] = sourceDisk;
    }
    if (sourceDiskEncryptionKey != null) {
      _json["sourceDiskEncryptionKey"] = (sourceDiskEncryptionKey).toJson();
    }
    if (sourceDiskId != null) {
      _json["sourceDiskId"] = sourceDiskId;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (storageBytes != null) {
      _json["storageBytes"] = storageBytes;
    }
    if (storageBytesStatus != null) {
      _json["storageBytesStatus"] = storageBytesStatus;
    }
    if (storageLocations != null) {
      _json["storageLocations"] = storageLocations;
    }
    return _json;
  }
}

class SnapshotListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SnapshotListWarningData();

  SnapshotListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SnapshotListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SnapshotListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SnapshotListWarning();

  SnapshotListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SnapshotListWarningData>(
              (value) => new SnapshotListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Snapshot resources.
class SnapshotList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Snapshot resources.
  core.List<Snapshot> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SnapshotListWarning warning;

  SnapshotList();

  SnapshotList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Snapshot>((value) => new Snapshot.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SnapshotListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// A specification of the parameters to use when creating the instance template
/// from a source instance.
class SourceInstanceParams {
  /// Attached disks configuration. If not provided, defaults are applied: For
  /// boot disk and any other R/W disks, new custom images will be created from
  /// each disk. For read-only disks, they will be attached in read-only mode.
  /// Local SSD disks will be created as blank volumes.
  core.List<DiskInstantiationConfig> diskConfigs;

  SourceInstanceParams();

  SourceInstanceParams.fromJson(core.Map _json) {
    if (_json.containsKey("diskConfigs")) {
      diskConfigs = (_json["diskConfigs"] as core.List)
          .map<DiskInstantiationConfig>(
              (value) => new DiskInstantiationConfig.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (diskConfigs != null) {
      _json["diskConfigs"] =
          diskConfigs.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// Represents an SSL Certificate resource.
///
/// Google Compute Engine has two SSL Certificate resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/sslCertificates) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionSslCertificates)
///
///
///
/// The sslCertificates are used by:
/// - external HTTPS load balancers
/// - SSL proxy load balancers
///
/// The regionSslCertificates are used by internal HTTPS load balancers.
///
/// Optionally, certificate file contents that you upload can contain a set of
/// up to five PEM-encoded certificates. The API call creates an object
/// (sslCertificate) that holds this data. You can use SSL keys and certificates
/// to secure connections to a load balancer. For more information, read
/// Creating and using SSL certificates and SSL certificates quotas and limits.
/// (== resource_for {$api_version}.sslCertificates ==) (== resource_for
/// {$api_version}.regionSslCertificates ==)
class SslCertificate {
  /// A local certificate file. The certificate must be in PEM format. The
  /// certificate chain must be no greater than 5 certs long. The chain must
  /// include at least one intermediate cert.
  core.String certificate;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Expire time of the certificate. RFC3339
  core.String expireTime;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#sslCertificate for SSL
  /// certificates.
  core.String kind;

  /// Configuration and status of a managed SSL certificate.
  SslCertificateManagedSslCertificate managed;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// A write-only private key in PEM format. Only insert requests will include
  /// this field.
  core.String privateKey;

  /// [Output Only] URL of the region where the regional SSL Certificate
  /// resides. This field is not applicable to global SSL Certificate.
  core.String region;

  /// [Output only] Server-defined URL for the resource.
  core.String selfLink;

  /// Configuration and status of a self-managed SSL certificate.
  SslCertificateSelfManagedSslCertificate selfManaged;

  /// [Output Only] Domains associated with the certificate via Subject
  /// Alternative Name.
  core.List<core.String> subjectAlternativeNames;

  /// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or
  /// "MANAGED". If not specified, the certificate is self-managed and the
  /// fields certificate and private_key are used.
  /// Possible string values are:
  /// - "MANAGED"
  /// - "SELF_MANAGED"
  /// - "TYPE_UNSPECIFIED"
  core.String type;

  SslCertificate();

  SslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey("certificate")) {
      certificate = _json["certificate"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("expireTime")) {
      expireTime = _json["expireTime"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("managed")) {
      managed =
          new SslCertificateManagedSslCertificate.fromJson(_json["managed"]);
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("privateKey")) {
      privateKey = _json["privateKey"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("selfManaged")) {
      selfManaged = new SslCertificateSelfManagedSslCertificate.fromJson(
          _json["selfManaged"]);
    }
    if (_json.containsKey("subjectAlternativeNames")) {
      subjectAlternativeNames =
          (_json["subjectAlternativeNames"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (certificate != null) {
      _json["certificate"] = certificate;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (expireTime != null) {
      _json["expireTime"] = expireTime;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (managed != null) {
      _json["managed"] = (managed).toJson();
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (privateKey != null) {
      _json["privateKey"] = privateKey;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (selfManaged != null) {
      _json["selfManaged"] = (selfManaged).toJson();
    }
    if (subjectAlternativeNames != null) {
      _json["subjectAlternativeNames"] = subjectAlternativeNames;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

class SslCertificateAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslCertificateAggregatedListWarningData();

  SslCertificateAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SslCertificateAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslCertificateAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslCertificateAggregatedListWarning();

  SslCertificateAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SslCertificateAggregatedListWarningData>((value) =>
              new SslCertificateAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class SslCertificateAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SslCertificatesScopedList resources.
  core.Map<core.String, SslCertificatesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#sslCertificateAggregatedList for lists of SSL Certificates.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SslCertificateAggregatedListWarning warning;

  SslCertificateAggregatedList();

  SslCertificateAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, SslCertificatesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new SslCertificatesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new SslCertificateAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<SslCertificatesScopedList,
              core.Map<core.String, core.Object>>(
          items, (SslCertificatesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SslCertificateListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslCertificateListWarningData();

  SslCertificateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SslCertificateListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslCertificateListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslCertificateListWarning();

  SslCertificateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SslCertificateListWarningData>(
              (value) => new SslCertificateListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of SslCertificate resources.
class SslCertificateList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SslCertificate resources.
  core.List<SslCertificate> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SslCertificateListWarning warning;

  SslCertificateList();

  SslCertificateList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<SslCertificate>((value) => new SslCertificate.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SslCertificateListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Configuration and status of a managed SSL certificate.
class SslCertificateManagedSslCertificate {
  /// [Output only] Detailed statuses of the domains specified for managed
  /// certificate resource.
  core.Map<core.String, core.String> domainStatus;

  /// The domains for which a managed SSL certificate will be generated.
  /// Currently only single-domain certs are supported.
  core.List<core.String> domains;

  /// [Output only] Status of the managed certificate resource.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED"
  /// - "PROVISIONING"
  /// - "PROVISIONING_FAILED"
  /// - "PROVISIONING_FAILED_PERMANENTLY"
  /// - "RENEWAL_FAILED"
  core.String status;

  SslCertificateManagedSslCertificate();

  SslCertificateManagedSslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey("domainStatus")) {
      domainStatus =
          (_json["domainStatus"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("domains")) {
      domains = (_json["domains"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (domainStatus != null) {
      _json["domainStatus"] = domainStatus;
    }
    if (domains != null) {
      _json["domains"] = domains;
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

/// Configuration and status of a self-managed SSL certificate.
class SslCertificateSelfManagedSslCertificate {
  /// A local certificate file. The certificate must be in PEM format. The
  /// certificate chain must be no greater than 5 certs long. The chain must
  /// include at least one intermediate cert.
  core.String certificate;

  /// A write-only private key in PEM format. Only insert requests will include
  /// this field.
  core.String privateKey;

  SslCertificateSelfManagedSslCertificate();

  SslCertificateSelfManagedSslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey("certificate")) {
      certificate = _json["certificate"];
    }
    if (_json.containsKey("privateKey")) {
      privateKey = _json["privateKey"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (certificate != null) {
      _json["certificate"] = certificate;
    }
    if (privateKey != null) {
      _json["privateKey"] = privateKey;
    }
    return _json;
  }
}

class SslCertificatesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslCertificatesScopedListWarningData();

  SslCertificatesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class SslCertificatesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslCertificatesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslCertificatesScopedListWarning();

  SslCertificatesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SslCertificatesScopedListWarningData>((value) =>
              new SslCertificatesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class SslCertificatesScopedList {
  /// List of SslCertificates contained in this scope.
  core.List<SslCertificate> sslCertificates;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  SslCertificatesScopedListWarning warning;

  SslCertificatesScopedList();

  SslCertificatesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("sslCertificates")) {
      sslCertificates = (_json["sslCertificates"] as core.List)
          .map<SslCertificate>((value) => new SslCertificate.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new SslCertificatesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sslCertificates != null) {
      _json["sslCertificates"] =
          sslCertificates.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SslPoliciesListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslPoliciesListWarningData();

  SslPoliciesListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SslPoliciesListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslPoliciesListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslPoliciesListWarning();

  SslPoliciesListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SslPoliciesListWarningData>(
              (value) => new SslPoliciesListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class SslPoliciesList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SslPolicy resources.
  core.List<SslPolicy> items;

  /// [Output Only] Type of the resource. Always compute#sslPoliciesList for
  /// lists of sslPolicies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SslPoliciesListWarning warning;

  SslPoliciesList();

  SslPoliciesList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<SslPolicy>((value) => new SslPolicy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SslPoliciesListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SslPoliciesListAvailableFeaturesResponse {
  core.List<core.String> features;

  SslPoliciesListAvailableFeaturesResponse();

  SslPoliciesListAvailableFeaturesResponse.fromJson(core.Map _json) {
    if (_json.containsKey("features")) {
      features = (_json["features"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (features != null) {
      _json["features"] = features;
    }
    return _json;
  }
}

class SslPolicyWarningsData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslPolicyWarningsData();

  SslPolicyWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

class SslPolicyWarnings {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslPolicyWarningsData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslPolicyWarnings();

  SslPolicyWarnings.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SslPolicyWarningsData>(
              (value) => new SslPolicyWarningsData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Represents a Cloud Armor Security Policy resource.
///
/// Only external backend services used by HTTP or HTTPS load balancers can
/// reference a Security Policy. For more information, read read  Cloud Armor
/// Security Policy Concepts. (== resource_for {$api_version}.sslPolicies ==)
class SslPolicy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// A list of features enabled when the selected profile is CUSTOM. The
  /// - method returns the set of features that can be specified in this list.
  /// This field must be empty if the profile is not CUSTOM.
  core.List<core.String> customFeatures;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The list of features enabled in the SSL policy.
  core.List<core.String> enabledFeatures;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a SslPolicy. An up-to-date fingerprint must be
  /// provided in order to update the SslPolicy, otherwise the request will fail
  /// with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// SslPolicy.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output only] Type of the resource. Always compute#sslPolicyfor SSL
  /// policies.
  core.String kind;

  /// The minimum version of SSL protocol that can be used by the clients to
  /// establish a connection with the load balancer. This can be one of TLS_1_0,
  /// TLS_1_1, TLS_1_2.
  /// Possible string values are:
  /// - "TLS_1_0"
  /// - "TLS_1_1"
  /// - "TLS_1_2"
  core.String minTlsVersion;

  /// Name of the resource. The name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// Profile specifies the set of SSL features that can be used by the load
  /// balancer when negotiating SSL with clients. This can be one of COMPATIBLE,
  /// MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of SSL features to
  /// enable must be specified in the customFeatures field.
  /// Possible string values are:
  /// - "COMPATIBLE"
  /// - "CUSTOM"
  /// - "MODERN"
  /// - "RESTRICTED"
  core.String profile;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] If potential misconfigurations are detected for this SSL
  /// policy, this field will be populated with warning messages.
  core.List<SslPolicyWarnings> warnings;

  SslPolicy();

  SslPolicy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("customFeatures")) {
      customFeatures =
          (_json["customFeatures"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enabledFeatures")) {
      enabledFeatures =
          (_json["enabledFeatures"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("minTlsVersion")) {
      minTlsVersion = _json["minTlsVersion"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("profile")) {
      profile = _json["profile"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warnings")) {
      warnings = (_json["warnings"] as core.List)
          .map<SslPolicyWarnings>(
              (value) => new SslPolicyWarnings.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (customFeatures != null) {
      _json["customFeatures"] = customFeatures;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enabledFeatures != null) {
      _json["enabledFeatures"] = enabledFeatures;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (minTlsVersion != null) {
      _json["minTlsVersion"] = minTlsVersion;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (profile != null) {
      _json["profile"] = profile;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warnings != null) {
      _json["warnings"] = warnings.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class SslPolicyReference {
  /// URL of the SSL policy resource. Set this to empty string to clear any
  /// existing SSL policy associated with the target proxy resource.
  core.String sslPolicy;

  SslPolicyReference();

  SslPolicyReference.fromJson(core.Map _json) {
    if (_json.containsKey("sslPolicy")) {
      sslPolicy = _json["sslPolicy"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sslPolicy != null) {
      _json["sslPolicy"] = sslPolicy;
    }
    return _json;
  }
}

/// Represents a Subnetwork resource.
///
/// A subnetwork (also known as a subnet) is a logical partition of a Virtual
/// Private Cloud network with one primary IP range and zero or more secondary
/// IP ranges. For more information, read  Virtual Private Cloud (VPC) Network.
/// (== resource_for {$api_version}.subnetworks ==)
class Subnetwork {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource. This field can be set only at resource creation time.
  core.String description;

  /// Whether to enable flow logging for this subnetwork. If this field is not
  /// explicitly set, it will not appear in get listings. If not set the default
  /// behavior is to disable flow logging.
  core.bool enableFlowLogs;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a Subnetwork. An up-to-date fingerprint must be
  /// provided in order to update the Subnetwork, otherwise the request will
  /// fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// Subnetwork.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// [Output Only] The gateway address for default routes to reach destination
  /// addresses outside this subnetwork.
  core.String gatewayAddress;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The range of internal addresses that are owned by this subnetwork. Provide
  /// this property when you create the subnetwork. For example, 10.0.0.0/8 or
  /// 192.168.0.0/16. Ranges must be unique and non-overlapping within a
  /// network. Only IPv4 is supported. This field can be set only at resource
  /// creation time.
  core.String ipCidrRange;

  /// [Output Only] Type of the resource. Always compute#subnetwork for
  /// Subnetwork resources.
  core.String kind;

  /// This field denotes the VPC flow logging options for this subnetwork. If
  /// logging is enabled, logs are exported to Stackdriver.
  SubnetworkLogConfig logConfig;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The name must be 1-63 characters long, and comply with
  /// RFC1035. Specifically, the name must be 1-63 characters long and match the
  /// regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
  /// character must be a lowercase letter, and all following characters must be
  /// a dash, lowercase letter, or digit, except the last character, which
  /// cannot be a dash.
  core.String name;

  /// The URL of the network to which this subnetwork belongs, provided by the
  /// client when initially creating the subnetwork. Only networks that are in
  /// the distributed mode can have subnetworks. This field can be set only at
  /// resource creation time.
  core.String network;

  /// Whether the VMs in this subnet can access Google services without assigned
  /// external IP addresses. This field can be both set at resource creation
  /// time and updated using setPrivateIpGoogleAccess.
  core.bool privateIpGoogleAccess;

  /// The purpose of the resource. This field can be either PRIVATE_RFC_1918 or
  /// INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to
  /// INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is reserved
  /// for Internal HTTP(S) Load Balancing. If unspecified, the purpose defaults
  /// to PRIVATE_RFC_1918.
  /// Possible string values are:
  /// - "INTERNAL_HTTPS_LOAD_BALANCER"
  /// - "PRIVATE"
  /// - "PRIVATE_RFC_1918"
  core.String purpose;

  /// URL of the region where the Subnetwork resides. This field can be set only
  /// at resource creation time.
  core.String region;

  /// The role of subnetwork. Currently, this field is only used when purpose =
  /// INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An
  /// ACTIVE subnetwork is one that is currently being used for Internal HTTP(S)
  /// Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to
  /// ACTIVE or is currently draining. This field can be updated with a patch
  /// request.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "BACKUP"
  core.String role;

  /// An array of configurations for secondary IP ranges for VM instances
  /// contained in this subnetwork. The primary IP of such VM must belong to the
  /// primary ipCidrRange of the subnetwork. The alias IPs may belong to either
  /// primary or secondary ranges. This field can be updated with a patch
  /// request.
  core.List<SubnetworkSecondaryRange> secondaryIpRanges;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The state of the subnetwork, which can be one of READY or
  /// DRAINING. A subnetwork that is READY is ready to be used. The state of
  /// DRAINING is only applicable to subnetworks that have the purpose set to
  /// INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load
  /// balancer are being drained. A subnetwork that is draining cannot be used
  /// or modified until it reaches a status of READY.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "READY"
  core.String state;

  Subnetwork();

  Subnetwork.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("enableFlowLogs")) {
      enableFlowLogs = _json["enableFlowLogs"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("gatewayAddress")) {
      gatewayAddress = _json["gatewayAddress"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("logConfig")) {
      logConfig = new SubnetworkLogConfig.fromJson(_json["logConfig"]);
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("privateIpGoogleAccess")) {
      privateIpGoogleAccess = _json["privateIpGoogleAccess"];
    }
    if (_json.containsKey("purpose")) {
      purpose = _json["purpose"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("role")) {
      role = _json["role"];
    }
    if (_json.containsKey("secondaryIpRanges")) {
      secondaryIpRanges = (_json["secondaryIpRanges"] as core.List)
          .map<SubnetworkSecondaryRange>(
              (value) => new SubnetworkSecondaryRange.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (enableFlowLogs != null) {
      _json["enableFlowLogs"] = enableFlowLogs;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (gatewayAddress != null) {
      _json["gatewayAddress"] = gatewayAddress;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (logConfig != null) {
      _json["logConfig"] = (logConfig).toJson();
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (privateIpGoogleAccess != null) {
      _json["privateIpGoogleAccess"] = privateIpGoogleAccess;
    }
    if (purpose != null) {
      _json["purpose"] = purpose;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (role != null) {
      _json["role"] = role;
    }
    if (secondaryIpRanges != null) {
      _json["secondaryIpRanges"] =
          secondaryIpRanges.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (state != null) {
      _json["state"] = state;
    }
    return _json;
  }
}

class SubnetworkAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworkAggregatedListWarningData();

  SubnetworkAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SubnetworkAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworkAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworkAggregatedListWarning();

  SubnetworkAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SubnetworkAggregatedListWarningData>((value) =>
              new SubnetworkAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class SubnetworkAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SubnetworksScopedList resources.
  core.Map<core.String, SubnetworksScopedList> items;

  /// [Output Only] Type of resource. Always compute#subnetworkAggregatedList
  /// for aggregated lists of subnetworks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SubnetworkAggregatedListWarning warning;

  SubnetworkAggregatedList();

  SubnetworkAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, SubnetworksScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new SubnetworksScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SubnetworkAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<SubnetworksScopedList, core.Map<core.String, core.Object>>(
              items, (SubnetworksScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SubnetworkListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworkListWarningData();

  SubnetworkListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SubnetworkListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworkListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworkListWarning();

  SubnetworkListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SubnetworkListWarningData>(
              (value) => new SubnetworkListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of Subnetwork resources.
class SubnetworkList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Subnetwork resources.
  core.List<Subnetwork> items;

  /// [Output Only] Type of resource. Always compute#subnetworkList for lists of
  /// subnetworks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SubnetworkListWarning warning;

  SubnetworkList();

  SubnetworkList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Subnetwork>((value) => new Subnetwork.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new SubnetworkListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// The available logging options for this subnetwork.
class SubnetworkLogConfig {
  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  /// Toggles the aggregation interval for collecting flow logs. Increasing the
  /// interval time will reduce the amount of generated flow logs for long
  /// lasting connections. Default is an interval of 5 seconds per connection.
  /// Possible string values are:
  /// - "INTERVAL_10_MIN"
  /// - "INTERVAL_15_MIN"
  /// - "INTERVAL_1_MIN"
  /// - "INTERVAL_30_SEC"
  /// - "INTERVAL_5_MIN"
  /// - "INTERVAL_5_SEC"
  core.String aggregationInterval;

  /// Whether to enable flow logging for this subnetwork. If this field is not
  /// explicitly set, it will not appear in get listings. If not set the default
  /// behavior is to disable flow logging.
  core.bool enable;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  /// Export filter used to define which VPC flow logs should be logged.
  core.String filterExpr;

  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  /// The value of the field must be in [0, 1]. Set the sampling rate of VPC
  /// flow logs within the subnetwork where 1.0 means all collected logs are
  /// reported and 0.0 means no logs are reported. Default is 0.5, which means
  /// half of all collected logs are reported.
  core.double flowSampling;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  /// Configures whether all, none or a subset of metadata fields should be
  /// added to the reported VPC flow logs. Default is INCLUDE_ALL_METADATA.
  /// Possible string values are:
  /// - "CUSTOM_METADATA"
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String metadata;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled and
  /// "metadata" was set to CUSTOM_METADATA.
  core.List<core.String> metadataFields;

  SubnetworkLogConfig();

  SubnetworkLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey("aggregationInterval")) {
      aggregationInterval = _json["aggregationInterval"];
    }
    if (_json.containsKey("enable")) {
      enable = _json["enable"];
    }
    if (_json.containsKey("filterExpr")) {
      filterExpr = _json["filterExpr"];
    }
    if (_json.containsKey("flowSampling")) {
      flowSampling = _json["flowSampling"].toDouble();
    }
    if (_json.containsKey("metadata")) {
      metadata = _json["metadata"];
    }
    if (_json.containsKey("metadataFields")) {
      metadataFields =
          (_json["metadataFields"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (aggregationInterval != null) {
      _json["aggregationInterval"] = aggregationInterval;
    }
    if (enable != null) {
      _json["enable"] = enable;
    }
    if (filterExpr != null) {
      _json["filterExpr"] = filterExpr;
    }
    if (flowSampling != null) {
      _json["flowSampling"] = flowSampling;
    }
    if (metadata != null) {
      _json["metadata"] = metadata;
    }
    if (metadataFields != null) {
      _json["metadataFields"] = metadataFields;
    }
    return _json;
  }
}

/// Represents a secondary IP range of a subnetwork.
class SubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  /// Provide this property when you create the subnetwork. Ranges must be
  /// unique and non-overlapping with all primary and secondary IP ranges within
  /// a network. Only IPv4 is supported.
  core.String ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance. The name must be 1-63 characters long,
  /// and comply with RFC1035. The name must be unique within the subnetwork.
  core.String rangeName;

  SubnetworkSecondaryRange();

  SubnetworkSecondaryRange.fromJson(core.Map _json) {
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
    if (_json.containsKey("rangeName")) {
      rangeName = _json["rangeName"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    if (rangeName != null) {
      _json["rangeName"] = rangeName;
    }
    return _json;
  }
}

class SubnetworksExpandIpCidrRangeRequest {
  /// The IP (in CIDR format or netmask) of internal addresses that are legal on
  /// this Subnetwork. This range should be disjoint from other subnetworks
  /// within this network. This range can only be larger than (i.e. a superset
  /// of) the range previously defined before the update.
  core.String ipCidrRange;

  SubnetworksExpandIpCidrRangeRequest();

  SubnetworksExpandIpCidrRangeRequest.fromJson(core.Map _json) {
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    return _json;
  }
}

class SubnetworksScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworksScopedListWarningData();

  SubnetworksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// An informational warning that appears when the list of addresses is empty.
class SubnetworksScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworksScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworksScopedListWarning();

  SubnetworksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<SubnetworksScopedListWarningData>(
              (value) => new SubnetworksScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class SubnetworksScopedList {
  /// A list of subnetworks contained in this scope.
  core.List<Subnetwork> subnetworks;

  /// An informational warning that appears when the list of addresses is empty.
  SubnetworksScopedListWarning warning;

  SubnetworksScopedList();

  SubnetworksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("subnetworks")) {
      subnetworks = (_json["subnetworks"] as core.List)
          .map<Subnetwork>((value) => new Subnetwork.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new SubnetworksScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (subnetworks != null) {
      _json["subnetworks"] =
          subnetworks.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class SubnetworksSetPrivateIpGoogleAccessRequest {
  core.bool privateIpGoogleAccess;

  SubnetworksSetPrivateIpGoogleAccessRequest();

  SubnetworksSetPrivateIpGoogleAccessRequest.fromJson(core.Map _json) {
    if (_json.containsKey("privateIpGoogleAccess")) {
      privateIpGoogleAccess = _json["privateIpGoogleAccess"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (privateIpGoogleAccess != null) {
      _json["privateIpGoogleAccess"] = privateIpGoogleAccess;
    }
    return _json;
  }
}

class TCPHealthCheck {
  /// The TCP port number for the health check request. The default value is 80.
  /// Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, TCP health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The application data to send once the TCP connection has been established
  /// (default value is empty). If both request and response are empty, the
  /// connection establishment alone will indicate health. The request data can
  /// only be ASCII.
  core.String request;

  /// The bytes to match against the beginning of the response data. If left
  /// empty (the default value), any response will indicate health. The response
  /// data can only be ASCII.
  core.String response;

  TCPHealthCheck();

  TCPHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey("port")) {
      port = _json["port"];
    }
    if (_json.containsKey("portName")) {
      portName = _json["portName"];
    }
    if (_json.containsKey("portSpecification")) {
      portSpecification = _json["portSpecification"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("request")) {
      request = _json["request"];
    }
    if (_json.containsKey("response")) {
      response = _json["response"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (port != null) {
      _json["port"] = port;
    }
    if (portName != null) {
      _json["portName"] = portName;
    }
    if (portSpecification != null) {
      _json["portSpecification"] = portSpecification;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (request != null) {
      _json["request"] = request;
    }
    if (response != null) {
      _json["response"] = response;
    }
    return _json;
  }
}

/// A set of instance tags.
class Tags {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the tags' contents and used for optimistic locking. The fingerprint is
  /// initially generated by Compute Engine and changes after every request to
  /// modify or update tags. You must always provide an up-to-date fingerprint
  /// hash in order to update or change tags.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// An array of tags. Each tag must be 1-63 characters long, and comply with
  /// RFC1035.
  core.List<core.String> items;

  Tags();

  Tags.fromJson(core.Map _json) {
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (items != null) {
      _json["items"] = items;
    }
    return _json;
  }
}

class TargetHttpProxiesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpProxiesScopedListWarningData();

  TargetHttpProxiesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class TargetHttpProxiesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpProxiesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpProxiesScopedListWarning();

  TargetHttpProxiesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetHttpProxiesScopedListWarningData>((value) =>
              new TargetHttpProxiesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetHttpProxiesScopedList {
  /// A list of TargetHttpProxies contained in this scope.
  core.List<TargetHttpProxy> targetHttpProxies;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  TargetHttpProxiesScopedListWarning warning;

  TargetHttpProxiesScopedList();

  TargetHttpProxiesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("targetHttpProxies")) {
      targetHttpProxies = (_json["targetHttpProxies"] as core.List)
          .map<TargetHttpProxy>((value) => new TargetHttpProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetHttpProxiesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (targetHttpProxies != null) {
      _json["targetHttpProxies"] =
          targetHttpProxies.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Target HTTP Proxy resource.
///
/// Google Compute Engine has two Target HTTP Proxy resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/targetHttpProxies) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionTargetHttpProxies)
///
/// A target HTTP proxy is a component of GCP HTTP load balancers.
///
/// * targetHttpProxies are used by external HTTP load balancers and Traffic
/// Director. * regionTargetHttpProxies are used by internal HTTP load
/// balancers.
///
/// Forwarding rules reference a target HTTP proxy, and the target proxy then
/// references a URL map. For more information, read Using Target Proxies and
/// Forwarding rule concepts. (== resource_for {$api_version}.targetHttpProxies
/// ==) (== resource_for {$api_version}.regionTargetHttpProxies ==)
class TargetHttpProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetHttpProxy for target
  /// HTTP proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] URL of the region where the regional Target HTTP Proxy
  /// resides. This field is not applicable to global Target HTTP Proxies.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService.
  core.String urlMap;

  TargetHttpProxy();

  TargetHttpProxy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("urlMap")) {
      urlMap = _json["urlMap"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (urlMap != null) {
      _json["urlMap"] = urlMap;
    }
    return _json;
  }
}

class TargetHttpProxyAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpProxiesScopedList resources.
  core.Map<core.String, TargetHttpProxiesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#targetHttpProxyAggregatedList for lists of Target HTTP Proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  TargetHttpProxyAggregatedList();

  TargetHttpProxyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, TargetHttpProxiesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new TargetHttpProxiesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<TargetHttpProxiesScopedList,
              core.Map<core.String, core.Object>>(
          items, (TargetHttpProxiesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    return _json;
  }
}

class TargetHttpProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpProxyListWarningData();

  TargetHttpProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetHttpProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpProxyListWarning();

  TargetHttpProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetHttpProxyListWarningData>(
              (value) => new TargetHttpProxyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// A list of TargetHttpProxy resources.
class TargetHttpProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpProxy resources.
  core.List<TargetHttpProxy> items;

  /// Type of resource. Always compute#targetHttpProxyList for lists of target
  /// HTTP proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetHttpProxyListWarning warning;

  TargetHttpProxyList();

  TargetHttpProxyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<TargetHttpProxy>((value) => new TargetHttpProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetHttpProxyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetHttpsProxiesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpsProxiesScopedListWarningData();

  TargetHttpsProxiesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class TargetHttpsProxiesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpsProxiesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpsProxiesScopedListWarning();

  TargetHttpsProxiesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetHttpsProxiesScopedListWarningData>((value) =>
              new TargetHttpsProxiesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetHttpsProxiesScopedList {
  /// A list of TargetHttpsProxies contained in this scope.
  core.List<TargetHttpsProxy> targetHttpsProxies;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  TargetHttpsProxiesScopedListWarning warning;

  TargetHttpsProxiesScopedList();

  TargetHttpsProxiesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("targetHttpsProxies")) {
      targetHttpsProxies = (_json["targetHttpsProxies"] as core.List)
          .map<TargetHttpsProxy>(
              (value) => new TargetHttpsProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetHttpsProxiesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (targetHttpsProxies != null) {
      _json["targetHttpsProxies"] =
          targetHttpsProxies.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetHttpsProxiesSetQuicOverrideRequest {
  /// QUIC policy for the TargetHttpsProxy resource.
  /// Possible string values are:
  /// - "DISABLE"
  /// - "ENABLE"
  /// - "NONE"
  core.String quicOverride;

  TargetHttpsProxiesSetQuicOverrideRequest();

  TargetHttpsProxiesSetQuicOverrideRequest.fromJson(core.Map _json) {
    if (_json.containsKey("quicOverride")) {
      quicOverride = _json["quicOverride"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (quicOverride != null) {
      _json["quicOverride"] = quicOverride;
    }
    return _json;
  }
}

class TargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource. Currently exactly one SslCertificate resource
  /// must be specified.
  core.List<core.String> sslCertificates;

  TargetHttpsProxiesSetSslCertificatesRequest();

  TargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("sslCertificates")) {
      sslCertificates =
          (_json["sslCertificates"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    return _json;
  }
}

/// Represents a Target HTTPS Proxy resource.
///
/// Google Compute Engine has two Target HTTPS Proxy resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/targetHttpsProxies) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionTargetHttpsProxies)
///
/// A target HTTPS proxy is a component of GCP HTTPS load balancers.
///
/// * targetHttpsProxies are used by external HTTPS load balancers. *
/// regionTargetHttpsProxies are used by internal HTTPS load balancers.
///
/// Forwarding rules reference a target HTTPS proxy, and the target proxy then
/// references a URL map. For more information, read Using Target Proxies and
/// Forwarding rule concepts. (== resource_for {$api_version}.targetHttpsProxies
/// ==) (== resource_for {$api_version}.regionTargetHttpsProxies ==)
class TargetHttpsProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetHttpsProxy for target
  /// HTTPS proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the QUIC override policy for this TargetHttpsProxy resource.
  /// This setting determines whether the load balancer attempts to negotiate
  /// QUIC with clients. You can specify NONE, ENABLE, or DISABLE.
  /// - When quic-override is set to NONE, Google manages whether QUIC is used.
  /// - When quic-override is set to ENABLE, the load balancer uses QUIC when
  /// possible.
  /// - When quic-override is set to DISABLE, the load balancer doesn't use
  /// QUIC.
  /// - If the quic-override flag is not specified, NONE is implied.
  /// -
  /// Possible string values are:
  /// - "DISABLE"
  /// - "ENABLE"
  /// - "NONE"
  core.String quicOverride;

  /// [Output Only] URL of the region where the regional TargetHttpsProxy
  /// resides. This field is not applicable to global TargetHttpsProxies.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// between users and the load balancer. At least one SSL certificate must be
  /// specified. Currently, you may specify up to 15 SSL certificates.
  core.List<core.String> sslCertificates;

  /// URL of SslPolicy resource that will be associated with the
  /// TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource has
  /// no SSL policy configured.
  core.String sslPolicy;

  /// A fully-qualified or valid partial URL to the UrlMap resource that defines
  /// the mapping from URL to the BackendService. For example, the following are
  /// all valid URLs for specifying a URL map:
  /// -
  /// https://www.googleapis.compute/v1/projects/project/global/urlMaps/url-map
  /// - projects/project/global/urlMaps/url-map
  /// - global/urlMaps/url-map
  core.String urlMap;

  TargetHttpsProxy();

  TargetHttpsProxy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("quicOverride")) {
      quicOverride = _json["quicOverride"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sslCertificates")) {
      sslCertificates =
          (_json["sslCertificates"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("sslPolicy")) {
      sslPolicy = _json["sslPolicy"];
    }
    if (_json.containsKey("urlMap")) {
      urlMap = _json["urlMap"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (quicOverride != null) {
      _json["quicOverride"] = quicOverride;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    if (sslPolicy != null) {
      _json["sslPolicy"] = sslPolicy;
    }
    if (urlMap != null) {
      _json["urlMap"] = urlMap;
    }
    return _json;
  }
}

class TargetHttpsProxyAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpsProxyAggregatedListWarningData();

  TargetHttpsProxyAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetHttpsProxyAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpsProxyAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpsProxyAggregatedListWarning();

  TargetHttpsProxyAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetHttpsProxyAggregatedListWarningData>((value) =>
              new TargetHttpsProxyAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetHttpsProxyAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpsProxiesScopedList resources.
  core.Map<core.String, TargetHttpsProxiesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#targetHttpsProxyAggregatedList for lists of Target HTTP Proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetHttpsProxyAggregatedListWarning warning;

  TargetHttpsProxyAggregatedList();

  TargetHttpsProxyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, TargetHttpsProxiesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new TargetHttpsProxiesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetHttpsProxyAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<TargetHttpsProxiesScopedList,
              core.Map<core.String, core.Object>>(
          items, (TargetHttpsProxiesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetHttpsProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpsProxyListWarningData();

  TargetHttpsProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetHttpsProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpsProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpsProxyListWarning();

  TargetHttpsProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetHttpsProxyListWarningData>(
              (value) => new TargetHttpsProxyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetHttpsProxy resources.
class TargetHttpsProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpsProxy resources.
  core.List<TargetHttpsProxy> items;

  /// Type of resource. Always compute#targetHttpsProxyList for lists of target
  /// HTTPS proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetHttpsProxyListWarning warning;

  TargetHttpsProxyList();

  TargetHttpsProxyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<TargetHttpsProxy>(
              (value) => new TargetHttpsProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetHttpsProxyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Target Instance resource.
///
/// You can use a target instance to handle traffic for one or more forwarding
/// rules, which is ideal for forwarding protocol traffic that is managed by a
/// single source. For example, ESP, AH, TCP, or UDP. For more information, read
/// Target instances. (== resource_for {$api_version}.targetInstances ==)
class TargetInstance {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// A URL to the virtual machine instance that handles traffic for this target
  /// instance. When creating a target instance, you can provide the
  /// fully-qualified URL or a valid partial URL to the desired virtual machine.
  /// For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  /// - zones/zone/instances/instance
  core.String instance;

  /// [Output Only] The type of the resource. Always compute#targetInstance for
  /// target instances.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// NAT option controlling how IPs are NAT'ed to the instance. Currently only
  /// NO_NAT (default value) is supported.
  /// Possible string values are:
  /// - "NO_NAT"
  core.String natPolicy;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] URL of the zone where the target instance resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String zone;

  TargetInstance();

  TargetInstance.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("instance")) {
      instance = _json["instance"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("natPolicy")) {
      natPolicy = _json["natPolicy"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("zone")) {
      zone = _json["zone"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (instance != null) {
      _json["instance"] = instance;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (natPolicy != null) {
      _json["natPolicy"] = natPolicy;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (zone != null) {
      _json["zone"] = zone;
    }
    return _json;
  }
}

class TargetInstanceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstanceAggregatedListWarningData();

  TargetInstanceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetInstanceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstanceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstanceAggregatedListWarning();

  TargetInstanceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetInstanceAggregatedListWarningData>((value) =>
              new TargetInstanceAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetInstanceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetInstance resources.
  core.Map<core.String, TargetInstancesScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetInstanceAggregatedListWarning warning;

  TargetInstanceAggregatedList();

  TargetInstanceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, TargetInstancesScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new TargetInstancesScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetInstanceAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<TargetInstancesScopedList,
              core.Map<core.String, core.Object>>(
          items, (TargetInstancesScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetInstanceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstanceListWarningData();

  TargetInstanceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetInstanceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstanceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstanceListWarning();

  TargetInstanceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetInstanceListWarningData>(
              (value) => new TargetInstanceListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetInstance resources.
class TargetInstanceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetInstance resources.
  core.List<TargetInstance> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetInstanceListWarning warning;

  TargetInstanceList();

  TargetInstanceList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<TargetInstance>((value) => new TargetInstance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetInstanceListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetInstancesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstancesScopedListWarningData();

  TargetInstancesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetInstancesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstancesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstancesScopedListWarning();

  TargetInstancesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetInstancesScopedListWarningData>((value) =>
              new TargetInstancesScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetInstancesScopedList {
  /// A list of target instances contained in this scope.
  core.List<TargetInstance> targetInstances;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetInstancesScopedListWarning warning;

  TargetInstancesScopedList();

  TargetInstancesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("targetInstances")) {
      targetInstances = (_json["targetInstances"] as core.List)
          .map<TargetInstance>((value) => new TargetInstance.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new TargetInstancesScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (targetInstances != null) {
      _json["targetInstances"] =
          targetInstances.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Target Pool resource.
///
/// Target pools are used for network TCP/UDP load balancing. A target pool
/// references member instances, an associated legacy HttpHealthCheck resource,
/// and, optionally, a backup target pool. For more information, read Using
/// target pools. (== resource_for {$api_version}.targetPools ==)
class TargetPool {
  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool, and its failoverRatio field is
  /// properly set to a value between [0, 1].
  ///
  /// backupPool and failoverRatio together define the fallback behavior of the
  /// primary target pool: if the ratio of the healthy instances in the primary
  /// pool is at or below failoverRatio, traffic arriving at the load-balanced
  /// IP will be directed to the backup pool.
  ///
  /// In case where failoverRatio and backupPool are not set, or all the
  /// instances in the backup pool are unhealthy, the traffic will be directed
  /// back to the primary pool in the "force" mode, where traffic will be spread
  /// to the healthy instances with the best effort, or to all instances when no
  /// instance is healthy.
  core.String backupPool;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool (i.e., not as a backup pool to some
  /// other target pool). The value of the field must be in [0, 1].
  ///
  /// If set, backupPool must also be set. They together define the fallback
  /// behavior of the primary target pool: if the ratio of the healthy instances
  /// in the primary pool is at or below this number, traffic arriving at the
  /// load-balanced IP will be directed to the backup pool.
  ///
  /// In case where failoverRatio is not set or all the instances in the backup
  /// pool are unhealthy, the traffic will be directed back to the primary pool
  /// in the "force" mode, where traffic will be spread to the healthy instances
  /// with the best effort, or to all instances when no instance is healthy.
  core.double failoverRatio;

  /// The URL of the HttpHealthCheck resource. A member instance in this pool is
  /// considered healthy if and only if the health checks pass. An empty list
  /// means all member instances will be considered healthy at all times. Only
  /// HttpHealthChecks are supported. Only one health check may be specified.
  core.List<core.String> healthChecks;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// A list of resource URLs to the virtual machine instances serving this
  /// pool. They must live in zones contained in the same region as this pool.
  core.List<core.String> instances;

  /// [Output Only] Type of the resource. Always compute#targetPool for target
  /// pools.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] URL of the region where the target pool resides.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Session affinity option, must be one of the following values:
  /// NONE: Connections from the same client IP may go to any instance in the
  /// pool.
  /// CLIENT_IP: Connections from the same client IP will go to the same
  /// instance in the pool while that instance remains healthy.
  /// CLIENT_IP_PROTO: Connections from the same client IP with the same IP
  /// protocol will go to the same instance in the pool while that instance
  /// remains healthy.
  /// Possible string values are:
  /// - "CLIENT_IP"
  /// - "CLIENT_IP_PORT_PROTO"
  /// - "CLIENT_IP_PROTO"
  /// - "GENERATED_COOKIE"
  /// - "HEADER_FIELD"
  /// - "HTTP_COOKIE"
  /// - "NONE"
  core.String sessionAffinity;

  TargetPool();

  TargetPool.fromJson(core.Map _json) {
    if (_json.containsKey("backupPool")) {
      backupPool = _json["backupPool"];
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("failoverRatio")) {
      failoverRatio = _json["failoverRatio"].toDouble();
    }
    if (_json.containsKey("healthChecks")) {
      healthChecks = (_json["healthChecks"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sessionAffinity")) {
      sessionAffinity = _json["sessionAffinity"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (backupPool != null) {
      _json["backupPool"] = backupPool;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (failoverRatio != null) {
      _json["failoverRatio"] = failoverRatio;
    }
    if (healthChecks != null) {
      _json["healthChecks"] = healthChecks;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (instances != null) {
      _json["instances"] = instances;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sessionAffinity != null) {
      _json["sessionAffinity"] = sessionAffinity;
    }
    return _json;
  }
}

class TargetPoolAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolAggregatedListWarningData();

  TargetPoolAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetPoolAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolAggregatedListWarning();

  TargetPoolAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetPoolAggregatedListWarningData>((value) =>
              new TargetPoolAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetPoolAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetPool resources.
  core.Map<core.String, TargetPoolsScopedList> items;

  /// [Output Only] Type of resource. Always compute#targetPoolAggregatedList
  /// for aggregated lists of target pools.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetPoolAggregatedListWarning warning;

  TargetPoolAggregatedList();

  TargetPoolAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, TargetPoolsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new TargetPoolsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetPoolAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<TargetPoolsScopedList, core.Map<core.String, core.Object>>(
              items, (TargetPoolsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetPoolInstanceHealth {
  core.List<HealthStatus> healthStatus;

  /// [Output Only] Type of resource. Always compute#targetPoolInstanceHealth
  /// when checking the health of an instance.
  core.String kind;

  TargetPoolInstanceHealth();

  TargetPoolInstanceHealth.fromJson(core.Map _json) {
    if (_json.containsKey("healthStatus")) {
      healthStatus = (_json["healthStatus"] as core.List)
          .map<HealthStatus>((value) => new HealthStatus.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthStatus != null) {
      _json["healthStatus"] =
          healthStatus.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    return _json;
  }
}

class TargetPoolListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolListWarningData();

  TargetPoolListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetPoolListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolListWarning();

  TargetPoolListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetPoolListWarningData>(
              (value) => new TargetPoolListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetPool resources.
class TargetPoolList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetPool resources.
  core.List<TargetPool> items;

  /// [Output Only] Type of resource. Always compute#targetPoolList for lists of
  /// target pools.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetPoolListWarning warning;

  TargetPoolList();

  TargetPoolList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<TargetPool>((value) => new TargetPool.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetPoolListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetPoolsAddHealthCheckRequest {
  /// The HttpHealthCheck to add to the target pool.
  core.List<HealthCheckReference> healthChecks;

  TargetPoolsAddHealthCheckRequest();

  TargetPoolsAddHealthCheckRequest.fromJson(core.Map _json) {
    if (_json.containsKey("healthChecks")) {
      healthChecks = (_json["healthChecks"] as core.List)
          .map<HealthCheckReference>(
              (value) => new HealthCheckReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthChecks != null) {
      _json["healthChecks"] =
          healthChecks.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsAddInstanceRequest {
  /// A full or partial URL to an instance to add to this target pool. This can
  /// be a full or partial URL. For example, the following are valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project-id/zones/zone/instances/instance-name
  /// - projects/project-id/zones/zone/instances/instance-name
  /// - zones/zone/instances/instance-name
  core.List<InstanceReference> instances;

  TargetPoolsAddInstanceRequest();

  TargetPoolsAddInstanceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List)
          .map<InstanceReference>(
              (value) => new InstanceReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsRemoveHealthCheckRequest {
  /// Health check URL to be removed. This can be a full or valid partial URL.
  /// For example, the following are valid URLs:
  /// -
  /// https://www.googleapis.com/compute/beta/projects/project/global/httpHealthChecks/health-check
  /// - projects/project/global/httpHealthChecks/health-check
  /// - global/httpHealthChecks/health-check
  core.List<HealthCheckReference> healthChecks;

  TargetPoolsRemoveHealthCheckRequest();

  TargetPoolsRemoveHealthCheckRequest.fromJson(core.Map _json) {
    if (_json.containsKey("healthChecks")) {
      healthChecks = (_json["healthChecks"] as core.List)
          .map<HealthCheckReference>(
              (value) => new HealthCheckReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (healthChecks != null) {
      _json["healthChecks"] =
          healthChecks.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsRemoveInstanceRequest {
  /// URLs of the instances to be removed from target pool.
  core.List<InstanceReference> instances;

  TargetPoolsRemoveInstanceRequest();

  TargetPoolsRemoveInstanceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("instances")) {
      instances = (_json["instances"] as core.List)
          .map<InstanceReference>(
              (value) => new InstanceReference.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instances != null) {
      _json["instances"] = instances.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolsScopedListWarningData();

  TargetPoolsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetPoolsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolsScopedListWarning();

  TargetPoolsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetPoolsScopedListWarningData>(
              (value) => new TargetPoolsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetPoolsScopedList {
  /// A list of target pools contained in this scope.
  core.List<TargetPool> targetPools;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetPoolsScopedListWarning warning;

  TargetPoolsScopedList();

  TargetPoolsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("targetPools")) {
      targetPools = (_json["targetPools"] as core.List)
          .map<TargetPool>((value) => new TargetPool.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new TargetPoolsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (targetPools != null) {
      _json["targetPools"] =
          targetPools.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetReference {
  core.String target;

  TargetReference();

  TargetReference.fromJson(core.Map _json) {
    if (_json.containsKey("target")) {
      target = _json["target"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (target != null) {
      _json["target"] = target;
    }
    return _json;
  }
}

class TargetSslProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetSslProxy.
  core.String service;

  TargetSslProxiesSetBackendServiceRequest();

  TargetSslProxiesSetBackendServiceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

class TargetSslProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  TargetSslProxiesSetProxyHeaderRequest();

  TargetSslProxiesSetProxyHeaderRequest.fromJson(core.Map _json) {
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    return _json;
  }
}

class TargetSslProxiesSetSslCertificatesRequest {
  /// New set of URLs to SslCertificate resources to associate with this
  /// TargetSslProxy. Currently exactly one ssl certificate must be specified.
  core.List<core.String> sslCertificates;

  TargetSslProxiesSetSslCertificatesRequest();

  TargetSslProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey("sslCertificates")) {
      sslCertificates =
          (_json["sslCertificates"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    return _json;
  }
}

/// Represents a Target SSL Proxy resource.
///
/// A target SSL proxy is a component of a SSL Proxy load balancer. Global
/// forwarding rules reference a target SSL proxy, and the target proxy then
/// references an external backend service. For more information, read Using
/// Target Proxies. (== resource_for {$api_version}.targetSslProxies ==)
class TargetSslProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#targetSslProxy for
  /// target SSL proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the BackendService resource.
  core.String service;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// to Backends. At least one SSL certificate must be specified. Currently,
  /// you may specify up to 15 SSL certificates.
  core.List<core.String> sslCertificates;

  /// URL of SslPolicy resource that will be associated with the TargetSslProxy
  /// resource. If not set, the TargetSslProxy resource will not have any SSL
  /// policy configured.
  core.String sslPolicy;

  TargetSslProxy();

  TargetSslProxy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
    if (_json.containsKey("sslCertificates")) {
      sslCertificates =
          (_json["sslCertificates"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("sslPolicy")) {
      sslPolicy = _json["sslPolicy"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (service != null) {
      _json["service"] = service;
    }
    if (sslCertificates != null) {
      _json["sslCertificates"] = sslCertificates;
    }
    if (sslPolicy != null) {
      _json["sslPolicy"] = sslPolicy;
    }
    return _json;
  }
}

class TargetSslProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetSslProxyListWarningData();

  TargetSslProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetSslProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetSslProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetSslProxyListWarning();

  TargetSslProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetSslProxyListWarningData>(
              (value) => new TargetSslProxyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetSslProxy resources.
class TargetSslProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetSslProxy resources.
  core.List<TargetSslProxy> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetSslProxyListWarning warning;

  TargetSslProxyList();

  TargetSslProxyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<TargetSslProxy>((value) => new TargetSslProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetSslProxyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetTcpProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetTcpProxy.
  core.String service;

  TargetTcpProxiesSetBackendServiceRequest();

  TargetTcpProxiesSetBackendServiceRequest.fromJson(core.Map _json) {
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

class TargetTcpProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  TargetTcpProxiesSetProxyHeaderRequest();

  TargetTcpProxiesSetProxyHeaderRequest.fromJson(core.Map _json) {
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    return _json;
  }
}

/// Represents a Target TCP Proxy resource.
///
/// A target TCP proxy is a component of a TCP Proxy load balancer. Global
/// forwarding rules reference target TCP proxy, and the target proxy then
/// references an external backend service. For more information, read TCP Proxy
/// Load Balancing overview. (== resource_for {$api_version}.targetTcpProxies
/// ==)
class TargetTcpProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#targetTcpProxy for
  /// target TCP proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the BackendService resource.
  core.String service;

  TargetTcpProxy();

  TargetTcpProxy.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("proxyHeader")) {
      proxyHeader = _json["proxyHeader"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (proxyHeader != null) {
      _json["proxyHeader"] = proxyHeader;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

class TargetTcpProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetTcpProxyListWarningData();

  TargetTcpProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetTcpProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetTcpProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetTcpProxyListWarning();

  TargetTcpProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetTcpProxyListWarningData>(
              (value) => new TargetTcpProxyListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetTcpProxy resources.
class TargetTcpProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetTcpProxy resources.
  core.List<TargetTcpProxy> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetTcpProxyListWarning warning;

  TargetTcpProxyList();

  TargetTcpProxyList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<TargetTcpProxy>((value) => new TargetTcpProxy.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetTcpProxyListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Target VPN Gateway resource.
///
/// The target VPN gateway resource represents a Classic Cloud VPN gateway. For
/// more information, read the the Cloud VPN Overview. (== resource_for
/// {$api_version}.targetVpnGateways ==)
class TargetVpnGateway {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] A list of URLs to the ForwardingRule resources.
  /// ForwardingRules are created using compute.forwardingRules.insert and
  /// associated with a VPN gateway.
  core.List<core.String> forwardingRules;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URL of the network to which this VPN gateway is attached. Provided by the
  /// client when the VPN gateway is created.
  core.String network;

  /// [Output Only] URL of the region where the target VPN gateway resides. You
  /// must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the VPN gateway, which can be one of the
  /// following: CREATING, READY, FAILED, or DELETING.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  core.String status;

  /// [Output Only] A list of URLs to VpnTunnel resources. VpnTunnels are
  /// created using the compute.vpntunnels.insert method and associated with a
  /// VPN gateway.
  core.List<core.String> tunnels;

  TargetVpnGateway();

  TargetVpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("forwardingRules")) {
      forwardingRules =
          (_json["forwardingRules"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("tunnels")) {
      tunnels = (_json["tunnels"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (forwardingRules != null) {
      _json["forwardingRules"] = forwardingRules;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (tunnels != null) {
      _json["tunnels"] = tunnels;
    }
    return _json;
  }
}

class TargetVpnGatewayAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewayAggregatedListWarningData();

  TargetVpnGatewayAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetVpnGatewayAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewayAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewayAggregatedListWarning();

  TargetVpnGatewayAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetVpnGatewayAggregatedListWarningData>((value) =>
              new TargetVpnGatewayAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetVpnGatewayAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetVpnGateway resources.
  core.Map<core.String, TargetVpnGatewaysScopedList> items;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetVpnGatewayAggregatedListWarning warning;

  TargetVpnGatewayAggregatedList();

  TargetVpnGatewayAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, TargetVpnGatewaysScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new TargetVpnGatewaysScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetVpnGatewayAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons.mapMap<TargetVpnGatewaysScopedList,
              core.Map<core.String, core.Object>>(
          items, (TargetVpnGatewaysScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetVpnGatewayListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewayListWarningData();

  TargetVpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetVpnGatewayListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewayListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewayListWarning();

  TargetVpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetVpnGatewayListWarningData>(
              (value) => new TargetVpnGatewayListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetVpnGateway resources.
class TargetVpnGatewayList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetVpnGateway resources.
  core.List<TargetVpnGateway> items;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetVpnGatewayListWarning warning;

  TargetVpnGatewayList();

  TargetVpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<TargetVpnGateway>(
              (value) => new TargetVpnGateway.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new TargetVpnGatewayListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TargetVpnGatewaysScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewaysScopedListWarningData();

  TargetVpnGatewaysScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of addresses
/// when the list is empty.
class TargetVpnGatewaysScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewaysScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewaysScopedListWarning();

  TargetVpnGatewaysScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<TargetVpnGatewaysScopedListWarningData>((value) =>
              new TargetVpnGatewaysScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class TargetVpnGatewaysScopedList {
  /// [Output Only] A list of target VPN gateways contained in this scope.
  core.List<TargetVpnGateway> targetVpnGateways;

  /// [Output Only] Informational warning which replaces the list of addresses
  /// when the list is empty.
  TargetVpnGatewaysScopedListWarning warning;

  TargetVpnGatewaysScopedList();

  TargetVpnGatewaysScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("targetVpnGateways")) {
      targetVpnGateways = (_json["targetVpnGateways"] as core.List)
          .map<TargetVpnGateway>(
              (value) => new TargetVpnGateway.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning =
          new TargetVpnGatewaysScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (targetVpnGateways != null) {
      _json["targetVpnGateways"] =
          targetVpnGateways.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class TestFailure {
  core.String actualService;
  core.String expectedService;
  core.String host;
  core.String path;

  TestFailure();

  TestFailure.fromJson(core.Map _json) {
    if (_json.containsKey("actualService")) {
      actualService = _json["actualService"];
    }
    if (_json.containsKey("expectedService")) {
      expectedService = _json["expectedService"];
    }
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("path")) {
      path = _json["path"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (actualService != null) {
      _json["actualService"] = actualService;
    }
    if (expectedService != null) {
      _json["expectedService"] = expectedService;
    }
    if (host != null) {
      _json["host"] = host;
    }
    if (path != null) {
      _json["path"] = path;
    }
    return _json;
  }
}

class TestPermissionsRequest {
  /// The set of permissions to check for the 'resource'. Permissions with
  /// wildcards (such as '*' or 'storage.*') are not allowed.
  core.List<core.String> permissions;

  TestPermissionsRequest();

  TestPermissionsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("permissions")) {
      permissions = (_json["permissions"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (permissions != null) {
      _json["permissions"] = permissions;
    }
    return _json;
  }
}

class TestPermissionsResponse {
  /// A subset of `TestPermissionsRequest.permissions` that the caller is
  /// allowed.
  core.List<core.String> permissions;

  TestPermissionsResponse();

  TestPermissionsResponse.fromJson(core.Map _json) {
    if (_json.containsKey("permissions")) {
      permissions = (_json["permissions"] as core.List).cast<core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (permissions != null) {
      _json["permissions"] = permissions;
    }
    return _json;
  }
}

/// Represents a URL Map resource.
///
/// Google Compute Engine has two URL Map resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/urlMaps) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionUrlMaps)
///
/// A URL map resource is a component of certain types of GCP load balancers and
/// Traffic Director.
///
/// * urlMaps are used by external HTTP(S) load balancers and Traffic Director.
/// * regionUrlMaps are used by internal HTTP(S) load balancers.
///
/// This resource defines mappings from host names and URL paths to either a
/// backend service or a backend bucket.
///
/// To use the global urlMaps resource, the backend service must have a
/// loadBalancingScheme of either EXTERNAL or INTERNAL_SELF_MANAGED. To use the
/// regionUrlMaps resource, the backend service must have a loadBalancingScheme
/// of INTERNAL_MANAGED. For more information, read URL Map Concepts.
class UrlMap {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// defaultRouteAction takes effect when none of the  hostRules match. The
  /// load balancer performs advanced routing actions like URL rewrites, header
  /// transformations, etc. prior to forwarding the request to the selected
  /// backend. If defaultRouteAction specifies any weightedBackendServices,
  /// defaultService must not be set. Conversely if defaultService is set,
  /// defaultRouteAction cannot contain any  weightedBackendServices.
  /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
  HttpRouteAction defaultRouteAction;

  /// The full or partial URL of the defaultService resource to which traffic is
  /// directed if none of the hostRules match. If defaultRouteAction is
  /// additionally specified, advanced routing actions like URL Rewrites, etc.
  /// take effect prior to sending the request to the backend. However, if
  /// defaultService is specified, defaultRouteAction cannot contain any
  /// weightedBackendServices. Conversely, if routeAction specifies any
  /// weightedBackendServices, service must not be specified.
  /// Only one of defaultService, defaultUrlRedirect  or
  /// defaultRouteAction.weightedBackendService must be set.
  core.String defaultService;

  /// When none of the specified hostRules match, the request is redirected to a
  /// URL specified by defaultUrlRedirect.
  /// If defaultUrlRedirect is specified, defaultService or defaultRouteAction
  /// must not be set.
  HttpRedirectAction defaultUrlRedirect;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a UrlMap. An up-to-date fingerprint must be
  /// provided in order to update the UrlMap, otherwise the request will fail
  /// with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a UrlMap.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes {
    return convert.base64.decode(fingerprint);
  }

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// The headerAction specified here take effect after headerAction specified
  /// under pathMatcher.
  HttpHeaderAction headerAction;

  /// The list of HostRules to use against the URL.
  core.List<HostRule> hostRules;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#urlMaps for url maps.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The list of named PathMatchers to use against the URL.
  core.List<PathMatcher> pathMatchers;

  /// [Output Only] URL of the region where the regional URL map resides. This
  /// field is not applicable to global URL maps. You must specify this field as
  /// part of the HTTP request URL. It is not settable as a field in the request
  /// body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// The list of expected URL mapping tests. Request to update this UrlMap will
  /// succeed only if all of the test cases pass. You can specify a maximum of
  /// 100 tests per UrlMap.
  core.List<UrlMapTest> tests;

  UrlMap();

  UrlMap.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("defaultRouteAction")) {
      defaultRouteAction =
          new HttpRouteAction.fromJson(_json["defaultRouteAction"]);
    }
    if (_json.containsKey("defaultService")) {
      defaultService = _json["defaultService"];
    }
    if (_json.containsKey("defaultUrlRedirect")) {
      defaultUrlRedirect =
          new HttpRedirectAction.fromJson(_json["defaultUrlRedirect"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("fingerprint")) {
      fingerprint = _json["fingerprint"];
    }
    if (_json.containsKey("headerAction")) {
      headerAction = new HttpHeaderAction.fromJson(_json["headerAction"]);
    }
    if (_json.containsKey("hostRules")) {
      hostRules = (_json["hostRules"] as core.List)
          .map<HostRule>((value) => new HostRule.fromJson(value))
          .toList();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("pathMatchers")) {
      pathMatchers = (_json["pathMatchers"] as core.List)
          .map<PathMatcher>((value) => new PathMatcher.fromJson(value))
          .toList();
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("tests")) {
      tests = (_json["tests"] as core.List)
          .map<UrlMapTest>((value) => new UrlMapTest.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (defaultRouteAction != null) {
      _json["defaultRouteAction"] = (defaultRouteAction).toJson();
    }
    if (defaultService != null) {
      _json["defaultService"] = defaultService;
    }
    if (defaultUrlRedirect != null) {
      _json["defaultUrlRedirect"] = (defaultUrlRedirect).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (fingerprint != null) {
      _json["fingerprint"] = fingerprint;
    }
    if (headerAction != null) {
      _json["headerAction"] = (headerAction).toJson();
    }
    if (hostRules != null) {
      _json["hostRules"] = hostRules.map((value) => (value).toJson()).toList();
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (pathMatchers != null) {
      _json["pathMatchers"] =
          pathMatchers.map((value) => (value).toJson()).toList();
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (tests != null) {
      _json["tests"] = tests.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class UrlMapListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UrlMapListWarningData();

  UrlMapListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class UrlMapListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UrlMapListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UrlMapListWarning();

  UrlMapListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<UrlMapListWarningData>(
              (value) => new UrlMapListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of UrlMap resources.
class UrlMapList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of UrlMap resources.
  core.List<UrlMap> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  UrlMapListWarning warning;

  UrlMapList();

  UrlMapList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<UrlMap>((value) => new UrlMap.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new UrlMapListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class UrlMapReference {
  core.String urlMap;

  UrlMapReference();

  UrlMapReference.fromJson(core.Map _json) {
    if (_json.containsKey("urlMap")) {
      urlMap = _json["urlMap"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (urlMap != null) {
      _json["urlMap"] = urlMap;
    }
    return _json;
  }
}

/// Message for the expected URL mappings.
class UrlMapTest {
  /// Description of this test case.
  core.String description;

  /// Host portion of the URL.
  core.String host;

  /// Path portion of the URL.
  core.String path;

  /// Expected BackendService resource the given URL should be mapped to.
  core.String service;

  UrlMapTest();

  UrlMapTest.fromJson(core.Map _json) {
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("host")) {
      host = _json["host"];
    }
    if (_json.containsKey("path")) {
      path = _json["path"];
    }
    if (_json.containsKey("service")) {
      service = _json["service"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (description != null) {
      _json["description"] = description;
    }
    if (host != null) {
      _json["host"] = host;
    }
    if (path != null) {
      _json["path"] = path;
    }
    if (service != null) {
      _json["service"] = service;
    }
    return _json;
  }
}

/// Message representing the validation result for a UrlMap.
class UrlMapValidationResult {
  core.List<core.String> loadErrors;

  /// Whether the given UrlMap can be successfully loaded. If false,
  /// 'loadErrors' indicates the reasons.
  core.bool loadSucceeded;
  core.List<TestFailure> testFailures;

  /// If successfully loaded, this field indicates whether the test passed. If
  /// false, 'testFailures's indicate the reason of failure.
  core.bool testPassed;

  UrlMapValidationResult();

  UrlMapValidationResult.fromJson(core.Map _json) {
    if (_json.containsKey("loadErrors")) {
      loadErrors = (_json["loadErrors"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("loadSucceeded")) {
      loadSucceeded = _json["loadSucceeded"];
    }
    if (_json.containsKey("testFailures")) {
      testFailures = (_json["testFailures"] as core.List)
          .map<TestFailure>((value) => new TestFailure.fromJson(value))
          .toList();
    }
    if (_json.containsKey("testPassed")) {
      testPassed = _json["testPassed"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (loadErrors != null) {
      _json["loadErrors"] = loadErrors;
    }
    if (loadSucceeded != null) {
      _json["loadSucceeded"] = loadSucceeded;
    }
    if (testFailures != null) {
      _json["testFailures"] =
          testFailures.map((value) => (value).toJson()).toList();
    }
    if (testPassed != null) {
      _json["testPassed"] = testPassed;
    }
    return _json;
  }
}

class UrlMapsAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UrlMapsAggregatedListWarningData();

  UrlMapsAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class UrlMapsAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UrlMapsAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UrlMapsAggregatedListWarning();

  UrlMapsAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<UrlMapsAggregatedListWarningData>(
              (value) => new UrlMapsAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class UrlMapsAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of UrlMapsScopedList resources.
  core.Map<core.String, UrlMapsScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  UrlMapsAggregatedListWarning warning;

  UrlMapsAggregatedList();

  UrlMapsAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, UrlMapsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new UrlMapsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new UrlMapsAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] =
          commons.mapMap<UrlMapsScopedList, core.Map<core.String, core.Object>>(
              items, (UrlMapsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class UrlMapsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UrlMapsScopedListWarningData();

  UrlMapsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class UrlMapsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UrlMapsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UrlMapsScopedListWarning();

  UrlMapsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<UrlMapsScopedListWarningData>(
              (value) => new UrlMapsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class UrlMapsScopedList {
  /// A list of UrlMaps contained in this scope.
  core.List<UrlMap> urlMaps;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  UrlMapsScopedListWarning warning;

  UrlMapsScopedList();

  UrlMapsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("urlMaps")) {
      urlMaps = (_json["urlMaps"] as core.List)
          .map<UrlMap>((value) => new UrlMap.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new UrlMapsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (urlMaps != null) {
      _json["urlMaps"] = urlMaps.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class UrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap resource;

  UrlMapsValidateRequest();

  UrlMapsValidateRequest.fromJson(core.Map _json) {
    if (_json.containsKey("resource")) {
      resource = new UrlMap.fromJson(_json["resource"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (resource != null) {
      _json["resource"] = (resource).toJson();
    }
    return _json;
  }
}

class UrlMapsValidateResponse {
  UrlMapValidationResult result;

  UrlMapsValidateResponse();

  UrlMapsValidateResponse.fromJson(core.Map _json) {
    if (_json.containsKey("result")) {
      result = new UrlMapValidationResult.fromJson(_json["result"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (result != null) {
      _json["result"] = (result).toJson();
    }
    return _json;
  }
}

/// The spec for modifying the path before sending the request to the matched
/// backend service.
class UrlRewrite {
  /// Prior to forwarding the request to the selected service, the request's
  /// host header is replaced with contents of hostRewrite.
  /// The value must be between 1 and 255 characters.
  core.String hostRewrite;

  /// Prior to forwarding the request to the selected backend service, the
  /// matching portion of the request's path is replaced by pathPrefixRewrite.
  /// The value must be between 1 and 1024 characters.
  core.String pathPrefixRewrite;

  UrlRewrite();

  UrlRewrite.fromJson(core.Map _json) {
    if (_json.containsKey("hostRewrite")) {
      hostRewrite = _json["hostRewrite"];
    }
    if (_json.containsKey("pathPrefixRewrite")) {
      pathPrefixRewrite = _json["pathPrefixRewrite"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (hostRewrite != null) {
      _json["hostRewrite"] = hostRewrite;
    }
    if (pathPrefixRewrite != null) {
      _json["pathPrefixRewrite"] = pathPrefixRewrite;
    }
    return _json;
  }
}

/// Subnetwork which the current user has compute.subnetworks.use permission on.
class UsableSubnetwork {
  /// The range of internal addresses that are owned by this subnetwork.
  core.String ipCidrRange;

  /// Network URL.
  core.String network;

  /// Secondary IP ranges.
  core.List<UsableSubnetworkSecondaryRange> secondaryIpRanges;

  /// Subnetwork URL.
  core.String subnetwork;

  UsableSubnetwork();

  UsableSubnetwork.fromJson(core.Map _json) {
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("secondaryIpRanges")) {
      secondaryIpRanges = (_json["secondaryIpRanges"] as core.List)
          .map<UsableSubnetworkSecondaryRange>(
              (value) => new UsableSubnetworkSecondaryRange.fromJson(value))
          .toList();
    }
    if (_json.containsKey("subnetwork")) {
      subnetwork = _json["subnetwork"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (secondaryIpRanges != null) {
      _json["secondaryIpRanges"] =
          secondaryIpRanges.map((value) => (value).toJson()).toList();
    }
    if (subnetwork != null) {
      _json["subnetwork"] = subnetwork;
    }
    return _json;
  }
}

/// Secondary IP range of a usable subnetwork.
class UsableSubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  core.String ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance. The name must be 1-63 characters long,
  /// and comply with RFC1035. The name must be unique within the subnetwork.
  core.String rangeName;

  UsableSubnetworkSecondaryRange();

  UsableSubnetworkSecondaryRange.fromJson(core.Map _json) {
    if (_json.containsKey("ipCidrRange")) {
      ipCidrRange = _json["ipCidrRange"];
    }
    if (_json.containsKey("rangeName")) {
      rangeName = _json["rangeName"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (ipCidrRange != null) {
      _json["ipCidrRange"] = ipCidrRange;
    }
    if (rangeName != null) {
      _json["rangeName"] = rangeName;
    }
    return _json;
  }
}

class UsableSubnetworksAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UsableSubnetworksAggregatedListWarningData();

  UsableSubnetworksAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class UsableSubnetworksAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UsableSubnetworksAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UsableSubnetworksAggregatedListWarning();

  UsableSubnetworksAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<UsableSubnetworksAggregatedListWarningData>((value) =>
              new UsableSubnetworksAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class UsableSubnetworksAggregatedList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output] A list of usable subnetwork URLs.
  core.List<UsableSubnetwork> items;

  /// [Output Only] Type of resource. Always
  /// compute#usableSubnetworksAggregatedList for aggregated lists of usable
  /// subnetworks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  UsableSubnetworksAggregatedListWarning warning;

  UsableSubnetworksAggregatedList();

  UsableSubnetworksAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<UsableSubnetwork>(
              (value) => new UsableSubnetwork.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning =
          new UsableSubnetworksAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// The location in Cloud Storage and naming method of the daily usage report.
/// Contains bucket_name and report_name prefix.
class UsageExportLocation {
  /// The name of an existing bucket in Cloud Storage where the usage report
  /// object is stored. The Google Service Account is granted write access to
  /// this bucket. This can either be the bucket name by itself, such as
  /// example-bucket, or the bucket name with gs:// or
  /// https://storage.googleapis.com/ in front of it, such as
  /// gs://example-bucket.
  core.String bucketName;

  /// An optional prefix for the name of the usage report object stored in
  /// bucketName. If not supplied, defaults to usage. The report is stored as a
  /// CSV file named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the
  /// day of the usage according to Pacific Time. If you supply a prefix, it
  /// should conform to Cloud Storage object naming conventions.
  core.String reportNamePrefix;

  UsageExportLocation();

  UsageExportLocation.fromJson(core.Map _json) {
    if (_json.containsKey("bucketName")) {
      bucketName = _json["bucketName"];
    }
    if (_json.containsKey("reportNamePrefix")) {
      reportNamePrefix = _json["reportNamePrefix"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bucketName != null) {
      _json["bucketName"] = bucketName;
    }
    if (reportNamePrefix != null) {
      _json["reportNamePrefix"] = reportNamePrefix;
    }
    return _json;
  }
}

/// Contain information of Nat mapping for a VM endpoint (i.e., NIC).
class VmEndpointNatMappings {
  /// Name of the VM instance which the endpoint belongs to
  core.String instanceName;
  core.List<VmEndpointNatMappingsInterfaceNatMappings> interfaceNatMappings;

  VmEndpointNatMappings();

  VmEndpointNatMappings.fromJson(core.Map _json) {
    if (_json.containsKey("instanceName")) {
      instanceName = _json["instanceName"];
    }
    if (_json.containsKey("interfaceNatMappings")) {
      interfaceNatMappings = (_json["interfaceNatMappings"] as core.List)
          .map<VmEndpointNatMappingsInterfaceNatMappings>((value) =>
              new VmEndpointNatMappingsInterfaceNatMappings.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (instanceName != null) {
      _json["instanceName"] = instanceName;
    }
    if (interfaceNatMappings != null) {
      _json["interfaceNatMappings"] =
          interfaceNatMappings.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// Contain information of Nat mapping for an interface of this endpoint.
class VmEndpointNatMappingsInterfaceNatMappings {
  /// List of all drain IP:port-range mappings assigned to this interface. These
  /// ranges are inclusive, that is, both the first and the last ports can be
  /// used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
  core.List<core.String> drainNatIpPortRanges;

  /// A list of all IP:port-range mappings assigned to this interface. These
  /// ranges are inclusive, that is, both the first and the last ports can be
  /// used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
  core.List<core.String> natIpPortRanges;

  /// Total number of drain ports across all NAT IPs allocated to this
  /// interface. It equals to the aggregated port number in the field
  /// drain_nat_ip_port_ranges.
  core.int numTotalDrainNatPorts;

  /// Total number of ports across all NAT IPs allocated to this interface. It
  /// equals to the aggregated port number in the field nat_ip_port_ranges.
  core.int numTotalNatPorts;

  /// Alias IP range for this interface endpoint. It will be a private (RFC
  /// 1918) IP range. Examples: "10.33.4.55/32", or "192.168.5.0/24".
  core.String sourceAliasIpRange;

  /// Primary IP of the VM for this NIC.
  core.String sourceVirtualIp;

  VmEndpointNatMappingsInterfaceNatMappings();

  VmEndpointNatMappingsInterfaceNatMappings.fromJson(core.Map _json) {
    if (_json.containsKey("drainNatIpPortRanges")) {
      drainNatIpPortRanges =
          (_json["drainNatIpPortRanges"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("natIpPortRanges")) {
      natIpPortRanges =
          (_json["natIpPortRanges"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("numTotalDrainNatPorts")) {
      numTotalDrainNatPorts = _json["numTotalDrainNatPorts"];
    }
    if (_json.containsKey("numTotalNatPorts")) {
      numTotalNatPorts = _json["numTotalNatPorts"];
    }
    if (_json.containsKey("sourceAliasIpRange")) {
      sourceAliasIpRange = _json["sourceAliasIpRange"];
    }
    if (_json.containsKey("sourceVirtualIp")) {
      sourceVirtualIp = _json["sourceVirtualIp"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (drainNatIpPortRanges != null) {
      _json["drainNatIpPortRanges"] = drainNatIpPortRanges;
    }
    if (natIpPortRanges != null) {
      _json["natIpPortRanges"] = natIpPortRanges;
    }
    if (numTotalDrainNatPorts != null) {
      _json["numTotalDrainNatPorts"] = numTotalDrainNatPorts;
    }
    if (numTotalNatPorts != null) {
      _json["numTotalNatPorts"] = numTotalNatPorts;
    }
    if (sourceAliasIpRange != null) {
      _json["sourceAliasIpRange"] = sourceAliasIpRange;
    }
    if (sourceVirtualIp != null) {
      _json["sourceVirtualIp"] = sourceVirtualIp;
    }
    return _json;
  }
}

class VmEndpointNatMappingsListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VmEndpointNatMappingsListWarningData();

  VmEndpointNatMappingsListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VmEndpointNatMappingsListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VmEndpointNatMappingsListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VmEndpointNatMappingsListWarning();

  VmEndpointNatMappingsListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<VmEndpointNatMappingsListWarningData>((value) =>
              new VmEndpointNatMappingsListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of VmEndpointNatMappings.
class VmEndpointNatMappingsList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#vmEndpointNatMappingsList
  /// for lists of Nat mappings of VM endpoints.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] A list of Nat mapping information of VM endpoints.
  core.List<VmEndpointNatMappings> result;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VmEndpointNatMappingsListWarning warning;

  VmEndpointNatMappingsList();

  VmEndpointNatMappingsList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("result")) {
      result = (_json["result"] as core.List)
          .map<VmEndpointNatMappings>(
              (value) => new VmEndpointNatMappings.fromJson(value))
          .toList();
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new VmEndpointNatMappingsListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (result != null) {
      _json["result"] = result.map((value) => (value).toJson()).toList();
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a VPN gateway resource. Next ID: 13
class VpnGateway {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#vpnGateway for VPN
  /// gateways.
  core.String kind;

  /// A fingerprint for the labels being applied to this VpnGateway, which is
  /// essentially a hash of the labels set used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// VpnGateway.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// Labels for this resource. These can only be added or modified by the
  /// setLabels method. Each label key/value pair must comply with RFC1035.
  /// Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URL of the network to which this VPN gateway is attached. Provided by the
  /// client when the VPN gateway is created.
  core.String network;

  /// [Output Only] URL of the region where the VPN gateway resides.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// A list of interfaces on this VPN gateway.
  core.List<VpnGatewayVpnGatewayInterface> vpnInterfaces;

  VpnGateway();

  VpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("network")) {
      network = _json["network"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("vpnInterfaces")) {
      vpnInterfaces = (_json["vpnInterfaces"] as core.List)
          .map<VpnGatewayVpnGatewayInterface>(
              (value) => new VpnGatewayVpnGatewayInterface.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (network != null) {
      _json["network"] = network;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (vpnInterfaces != null) {
      _json["vpnInterfaces"] =
          vpnInterfaces.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

class VpnGatewayAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnGatewayAggregatedListWarningData();

  VpnGatewayAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnGatewayAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnGatewayAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnGatewayAggregatedListWarning();

  VpnGatewayAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<VpnGatewayAggregatedListWarningData>((value) =>
              new VpnGatewayAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class VpnGatewayAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnGateway resources.
  core.Map<core.String, VpnGatewaysScopedList> items;

  /// [Output Only] Type of resource. Always compute#vpnGateway for VPN
  /// gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VpnGatewayAggregatedListWarning warning;

  VpnGatewayAggregatedList();

  VpnGatewayAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, VpnGatewaysScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new VpnGatewaysScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new VpnGatewayAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<VpnGatewaysScopedList, core.Map<core.String, core.Object>>(
              items, (VpnGatewaysScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class VpnGatewayListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnGatewayListWarningData();

  VpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnGatewayListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnGatewayListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnGatewayListWarning();

  VpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<VpnGatewayListWarningData>(
              (value) => new VpnGatewayListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of VpnGateway resources.
class VpnGatewayList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnGateway resources.
  core.List<VpnGateway> items;

  /// [Output Only] Type of resource. Always compute#vpnGateway for VPN
  /// gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VpnGatewayListWarning warning;

  VpnGatewayList();

  VpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<VpnGateway>((value) => new VpnGateway.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new VpnGatewayListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class VpnGatewayStatus {
  /// List of VPN connection for this VpnGateway.
  core.List<VpnGatewayStatusVpnConnection> vpnConnections;

  VpnGatewayStatus();

  VpnGatewayStatus.fromJson(core.Map _json) {
    if (_json.containsKey("vpnConnections")) {
      vpnConnections = (_json["vpnConnections"] as core.List)
          .map<VpnGatewayStatusVpnConnection>(
              (value) => new VpnGatewayStatusVpnConnection.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (vpnConnections != null) {
      _json["vpnConnections"] =
          vpnConnections.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// Describes the high availability requirement state for the VPN connection
/// between this Cloud VPN gateway and a peer gateway.
class VpnGatewayStatusHighAvailabilityRequirementState {
  /// Indicates the high availability requirement state for the VPN connection.
  /// Valid values are CONNECTION_REDUNDANCY_MET, CONNECTION_REDUNDANCY_NOT_MET.
  /// Possible string values are:
  /// - "CONNECTION_REDUNDANCY_MET"
  /// - "CONNECTION_REDUNDANCY_NOT_MET"
  core.String state;

  /// Indicates the reason why the VPN connection does not meet the high
  /// availability redundancy criteria/requirement. Valid values is
  /// INCOMPLETE_TUNNELS_COVERAGE.
  /// Possible string values are:
  /// - "INCOMPLETE_TUNNELS_COVERAGE"
  core.String unsatisfiedReason;

  VpnGatewayStatusHighAvailabilityRequirementState();

  VpnGatewayStatusHighAvailabilityRequirementState.fromJson(core.Map _json) {
    if (_json.containsKey("state")) {
      state = _json["state"];
    }
    if (_json.containsKey("unsatisfiedReason")) {
      unsatisfiedReason = _json["unsatisfiedReason"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (state != null) {
      _json["state"] = state;
    }
    if (unsatisfiedReason != null) {
      _json["unsatisfiedReason"] = unsatisfiedReason;
    }
    return _json;
  }
}

/// Contains some information about a VPN tunnel.
class VpnGatewayStatusTunnel {
  /// The VPN gateway interface this VPN tunnel is associated with.
  core.int localGatewayInterface;

  /// The peer gateway interface this VPN tunnel is connected to, the peer
  /// gateway could either be an external VPN gateway or GCP VPN gateway.
  core.int peerGatewayInterface;

  /// URL reference to the VPN tunnel.
  core.String tunnelUrl;

  VpnGatewayStatusTunnel();

  VpnGatewayStatusTunnel.fromJson(core.Map _json) {
    if (_json.containsKey("localGatewayInterface")) {
      localGatewayInterface = _json["localGatewayInterface"];
    }
    if (_json.containsKey("peerGatewayInterface")) {
      peerGatewayInterface = _json["peerGatewayInterface"];
    }
    if (_json.containsKey("tunnelUrl")) {
      tunnelUrl = _json["tunnelUrl"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (localGatewayInterface != null) {
      _json["localGatewayInterface"] = localGatewayInterface;
    }
    if (peerGatewayInterface != null) {
      _json["peerGatewayInterface"] = peerGatewayInterface;
    }
    if (tunnelUrl != null) {
      _json["tunnelUrl"] = tunnelUrl;
    }
    return _json;
  }
}

/// A VPN connection contains all VPN tunnels connected from this VpnGateway to
/// the same peer gateway. The peer gateway could either be a external VPN
/// gateway or GCP VPN gateway.
class VpnGatewayStatusVpnConnection {
  /// URL reference to the peer external VPN gateways to which the VPN tunnels
  /// in this VPN connection are connected. This field is mutually exclusive
  /// with peer_gcp_gateway.
  core.String peerExternalGateway;

  /// URL reference to the peer side VPN gateways to which the VPN tunnels in
  /// this VPN connection are connected. This field is mutually exclusive with
  /// peer_gcp_gateway.
  core.String peerGcpGateway;

  /// HighAvailabilityRequirementState for the VPN connection.
  VpnGatewayStatusHighAvailabilityRequirementState state;

  /// List of VPN tunnels that are in this VPN connection.
  core.List<VpnGatewayStatusTunnel> tunnels;

  VpnGatewayStatusVpnConnection();

  VpnGatewayStatusVpnConnection.fromJson(core.Map _json) {
    if (_json.containsKey("peerExternalGateway")) {
      peerExternalGateway = _json["peerExternalGateway"];
    }
    if (_json.containsKey("peerGcpGateway")) {
      peerGcpGateway = _json["peerGcpGateway"];
    }
    if (_json.containsKey("state")) {
      state = new VpnGatewayStatusHighAvailabilityRequirementState.fromJson(
          _json["state"]);
    }
    if (_json.containsKey("tunnels")) {
      tunnels = (_json["tunnels"] as core.List)
          .map<VpnGatewayStatusTunnel>(
              (value) => new VpnGatewayStatusTunnel.fromJson(value))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (peerExternalGateway != null) {
      _json["peerExternalGateway"] = peerExternalGateway;
    }
    if (peerGcpGateway != null) {
      _json["peerGcpGateway"] = peerGcpGateway;
    }
    if (state != null) {
      _json["state"] = (state).toJson();
    }
    if (tunnels != null) {
      _json["tunnels"] = tunnels.map((value) => (value).toJson()).toList();
    }
    return _json;
  }
}

/// A VPN gateway interface.
class VpnGatewayVpnGatewayInterface {
  /// The numeric ID of this VPN gateway interface.
  core.int id;

  /// [Output Only] The external IP address for this VPN gateway interface.
  core.String ipAddress;

  VpnGatewayVpnGatewayInterface();

  VpnGatewayVpnGatewayInterface.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ipAddress")) {
      ipAddress = _json["ipAddress"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (ipAddress != null) {
      _json["ipAddress"] = ipAddress;
    }
    return _json;
  }
}

class VpnGatewaysGetStatusResponse {
  VpnGatewayStatus result;

  VpnGatewaysGetStatusResponse();

  VpnGatewaysGetStatusResponse.fromJson(core.Map _json) {
    if (_json.containsKey("result")) {
      result = new VpnGatewayStatus.fromJson(_json["result"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (result != null) {
      _json["result"] = (result).toJson();
    }
    return _json;
  }
}

class VpnGatewaysScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnGatewaysScopedListWarningData();

  VpnGatewaysScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of addresses
/// when the list is empty.
class VpnGatewaysScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnGatewaysScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnGatewaysScopedListWarning();

  VpnGatewaysScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<VpnGatewaysScopedListWarningData>(
              (value) => new VpnGatewaysScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class VpnGatewaysScopedList {
  /// [Output Only] A list of VPN gateways contained in this scope.
  core.List<VpnGateway> vpnGateways;

  /// [Output Only] Informational warning which replaces the list of addresses
  /// when the list is empty.
  VpnGatewaysScopedListWarning warning;

  VpnGatewaysScopedList();

  VpnGatewaysScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("vpnGateways")) {
      vpnGateways = (_json["vpnGateways"] as core.List)
          .map<VpnGateway>((value) => new VpnGateway.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new VpnGatewaysScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (vpnGateways != null) {
      _json["vpnGateways"] =
          vpnGateways.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Represents a Cloud VPN Tunnel resource.
///
/// For more information about VPN, read the the Cloud VPN Overview. (==
/// resource_for {$api_version}.vpnTunnels ==)
class VpnTunnel {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Detailed status message for the VPN tunnel.
  core.String detailedStatus;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// IKE protocol version to use when establishing the VPN tunnel with the peer
  /// VPN gateway. Acceptable IKE versions are 1 or 2. The default version is 2.
  core.int ikeVersion;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// Local traffic selector to use when establishing the VPN tunnel with the
  /// peer VPN gateway. The value should be a CIDR formatted string, for
  /// example: 192.168.0.0/16. The ranges must be disjoint. Only IPv4 is
  /// supported.
  core.List<core.String> localTrafficSelector;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URL of the peer side external VPN gateway to which this VPN tunnel is
  /// connected. Provided by the client when the VPN tunnel is created. This
  /// field is exclusive with the field peerGcpGateway.
  core.String peerExternalGateway;

  /// The interface ID of the external VPN gateway to which this VPN tunnel is
  /// connected. Provided by the client when the VPN tunnel is created.
  core.int peerExternalGatewayInterface;

  /// URL of the peer side HA GCP VPN gateway to which this VPN tunnel is
  /// connected. Provided by the client when the VPN tunnel is created. This
  /// field can be used when creating highly available VPN from VPC network to
  /// VPC network, the field is exclusive with the field peerExternalGateway. If
  /// provided, the VPN tunnel will automatically use the same
  /// vpnGatewayInterface ID in the peer GCP VPN gateway.
  core.String peerGcpGateway;

  /// IP address of the peer VPN gateway. Only IPv4 is supported.
  core.String peerIp;

  /// [Output Only] URL of the region where the VPN tunnel resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// Remote traffic selectors to use when establishing the VPN tunnel with the
  /// peer VPN gateway. The value should be a CIDR formatted string, for
  /// example: 192.168.0.0/16. The ranges should be disjoint. Only IPv4 is
  /// supported.
  core.List<core.String> remoteTrafficSelector;

  /// URL of the router resource to be used for dynamic routing.
  core.String router;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Shared secret used to set the secure session between the Cloud VPN gateway
  /// and the peer VPN gateway.
  core.String sharedSecret;

  /// Hash of the shared secret.
  core.String sharedSecretHash;

  /// [Output Only] The status of the VPN tunnel, which can be one of the
  /// following:
  /// - PROVISIONING: Resource is being allocated for the VPN tunnel.
  /// - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from
  /// the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route
  /// resources are needed to setup the VPN tunnel.
  /// - FIRST_HANDSHAKE: Successful first handshake with the peer VPN.
  /// - ESTABLISHED: Secure session is successfully established with the peer
  /// VPN.
  /// - NETWORK_ERROR: Deprecated, replaced by NO_INCOMING_PACKETS
  /// - AUTHORIZATION_ERROR: Auth error (for example, bad shared secret).
  /// - NEGOTIATION_FAILURE: Handshake failed.
  /// - DEPROVISIONING: Resources are being deallocated for the VPN tunnel.
  /// - FAILED: Tunnel creation has failed and the tunnel is not ready to be
  /// used.
  /// - NO_INCOMING_PACKETS: No incoming packets from peer.
  /// - REJECTED: Tunnel configuration was rejected, can be result of being
  /// blacklisted.
  /// - ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating all
  /// required resources.
  /// - STOPPED: Tunnel is stopped due to its Forwarding Rules being deleted for
  /// Classic VPN tunnels or the project is in frozen state.
  /// - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP, probably
  /// behind NAT.
  /// - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing not allowed for an
  /// HA-VPN tunnel.
  /// Possible string values are:
  /// - "ALLOCATING_RESOURCES"
  /// - "AUTHORIZATION_ERROR"
  /// - "DEPROVISIONING"
  /// - "ESTABLISHED"
  /// - "FAILED"
  /// - "FIRST_HANDSHAKE"
  /// - "NEGOTIATION_FAILURE"
  /// - "NETWORK_ERROR"
  /// - "NO_INCOMING_PACKETS"
  /// - "PROVISIONING"
  /// - "REJECTED"
  /// - "STOPPED"
  /// - "WAITING_FOR_FULL_CONFIG"
  core.String status;

  /// URL of the Target VPN gateway with which this VPN tunnel is associated.
  /// Provided by the client when the VPN tunnel is created.
  core.String targetVpnGateway;

  /// URL of the VPN gateway with which this VPN tunnel is associated. Provided
  /// by the client when the VPN tunnel is created. This must be used (instead
  /// of target_vpn_gateway) if a High Availability VPN gateway resource is
  /// created.
  core.String vpnGateway;

  /// The interface ID of the VPN gateway with which this VPN tunnel is
  /// associated.
  core.int vpnGatewayInterface;

  VpnTunnel();

  VpnTunnel.fromJson(core.Map _json) {
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("detailedStatus")) {
      detailedStatus = _json["detailedStatus"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("ikeVersion")) {
      ikeVersion = _json["ikeVersion"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("localTrafficSelector")) {
      localTrafficSelector =
          (_json["localTrafficSelector"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("peerExternalGateway")) {
      peerExternalGateway = _json["peerExternalGateway"];
    }
    if (_json.containsKey("peerExternalGatewayInterface")) {
      peerExternalGatewayInterface = _json["peerExternalGatewayInterface"];
    }
    if (_json.containsKey("peerGcpGateway")) {
      peerGcpGateway = _json["peerGcpGateway"];
    }
    if (_json.containsKey("peerIp")) {
      peerIp = _json["peerIp"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("remoteTrafficSelector")) {
      remoteTrafficSelector =
          (_json["remoteTrafficSelector"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("router")) {
      router = _json["router"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("sharedSecret")) {
      sharedSecret = _json["sharedSecret"];
    }
    if (_json.containsKey("sharedSecretHash")) {
      sharedSecretHash = _json["sharedSecretHash"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
    if (_json.containsKey("targetVpnGateway")) {
      targetVpnGateway = _json["targetVpnGateway"];
    }
    if (_json.containsKey("vpnGateway")) {
      vpnGateway = _json["vpnGateway"];
    }
    if (_json.containsKey("vpnGatewayInterface")) {
      vpnGatewayInterface = _json["vpnGatewayInterface"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (detailedStatus != null) {
      _json["detailedStatus"] = detailedStatus;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (ikeVersion != null) {
      _json["ikeVersion"] = ikeVersion;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (localTrafficSelector != null) {
      _json["localTrafficSelector"] = localTrafficSelector;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (peerExternalGateway != null) {
      _json["peerExternalGateway"] = peerExternalGateway;
    }
    if (peerExternalGatewayInterface != null) {
      _json["peerExternalGatewayInterface"] = peerExternalGatewayInterface;
    }
    if (peerGcpGateway != null) {
      _json["peerGcpGateway"] = peerGcpGateway;
    }
    if (peerIp != null) {
      _json["peerIp"] = peerIp;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (remoteTrafficSelector != null) {
      _json["remoteTrafficSelector"] = remoteTrafficSelector;
    }
    if (router != null) {
      _json["router"] = router;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (sharedSecret != null) {
      _json["sharedSecret"] = sharedSecret;
    }
    if (sharedSecretHash != null) {
      _json["sharedSecretHash"] = sharedSecretHash;
    }
    if (status != null) {
      _json["status"] = status;
    }
    if (targetVpnGateway != null) {
      _json["targetVpnGateway"] = targetVpnGateway;
    }
    if (vpnGateway != null) {
      _json["vpnGateway"] = vpnGateway;
    }
    if (vpnGatewayInterface != null) {
      _json["vpnGatewayInterface"] = vpnGatewayInterface;
    }
    return _json;
  }
}

class VpnTunnelAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelAggregatedListWarningData();

  VpnTunnelAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnTunnelAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelAggregatedListWarning();

  VpnTunnelAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<VpnTunnelAggregatedListWarningData>(
              (value) => new VpnTunnelAggregatedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class VpnTunnelAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnTunnelsScopedList resources.
  core.Map<core.String, VpnTunnelsScopedList> items;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VpnTunnelAggregatedListWarning warning;

  VpnTunnelAggregatedList();

  VpnTunnelAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = commons.mapMap<core.Map, VpnTunnelsScopedList>(
          _json["items"].cast<core.String, core.Map>(),
          (core.Map item) => new VpnTunnelsScopedList.fromJson(item));
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new VpnTunnelAggregatedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = commons
          .mapMap<VpnTunnelsScopedList, core.Map<core.String, core.Object>>(
              items, (VpnTunnelsScopedList item) => (item).toJson());
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class VpnTunnelListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelListWarningData();

  VpnTunnelListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnTunnelListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelListWarning();

  VpnTunnelListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<VpnTunnelListWarningData>(
              (value) => new VpnTunnelListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of VpnTunnel resources.
class VpnTunnelList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnTunnel resources.
  core.List<VpnTunnel> items;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VpnTunnelListWarning warning;

  VpnTunnelList();

  VpnTunnelList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<VpnTunnel>((value) => new VpnTunnel.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new VpnTunnelListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class VpnTunnelsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelsScopedListWarningData();

  VpnTunnelsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class VpnTunnelsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelsScopedListWarning();

  VpnTunnelsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<VpnTunnelsScopedListWarningData>(
              (value) => new VpnTunnelsScopedListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class VpnTunnelsScopedList {
  /// A list of VPN tunnels contained in this scope.
  core.List<VpnTunnel> vpnTunnels;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  VpnTunnelsScopedListWarning warning;

  VpnTunnelsScopedList();

  VpnTunnelsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey("vpnTunnels")) {
      vpnTunnels = (_json["vpnTunnels"] as core.List)
          .map<VpnTunnel>((value) => new VpnTunnel.fromJson(value))
          .toList();
    }
    if (_json.containsKey("warning")) {
      warning = new VpnTunnelsScopedListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (vpnTunnels != null) {
      _json["vpnTunnels"] =
          vpnTunnels.map((value) => (value).toJson()).toList();
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class WafExpressionSet {
  /// A list of alternate IDs. The format should be: - E.g. XSS-stable Generic
  /// suffix like "stable" is particularly useful if a policy likes to avail
  /// newer set of expressions without having to change the policy. A given
  /// alias name can't be used for more than one entity set.
  core.List<core.String> aliases;

  /// List of available expressions.
  core.List<WafExpressionSetExpression> expressions;

  /// Google specified expression set ID. The format should be: - E.g.
  /// XSS-20170329
  core.String id;

  WafExpressionSet();

  WafExpressionSet.fromJson(core.Map _json) {
    if (_json.containsKey("aliases")) {
      aliases = (_json["aliases"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("expressions")) {
      expressions = (_json["expressions"] as core.List)
          .map<WafExpressionSetExpression>(
              (value) => new WafExpressionSetExpression.fromJson(value))
          .toList();
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (aliases != null) {
      _json["aliases"] = aliases;
    }
    if (expressions != null) {
      _json["expressions"] =
          expressions.map((value) => (value).toJson()).toList();
    }
    if (id != null) {
      _json["id"] = id;
    }
    return _json;
  }
}

class WafExpressionSetExpression {
  /// Expression ID should uniquely identify the origin of the expression. E.g.
  /// owasp-crs-v020901-id973337 identifies Owasp core rule set version 2.9.1
  /// rule id 973337. The ID could be used to determine the individual attack
  /// definition that has been detected. It could also be used to exclude it
  /// from the policy in case of false positive.
  core.String id;

  WafExpressionSetExpression();

  WafExpressionSetExpression.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    return _json;
  }
}

/// In contrast to a single BackendService in  HttpRouteAction to which all
/// matching traffic is directed to, WeightedBackendService allows traffic to be
/// split across multiple BackendServices. The volume of traffic for each
/// BackendService is proportional to the weight specified in each
/// WeightedBackendService
class WeightedBackendService {
  /// The full or partial URL to the default BackendService resource. Before
  /// forwarding the request to backendService, the loadbalancer applies any
  /// relevant headerActions specified as part of this backendServiceWeight.
  core.String backendService;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// headerAction specified here take effect before headerAction in the
  /// enclosing HttpRouteRule, PathMatcher and UrlMap.
  HttpHeaderAction headerAction;

  /// Specifies the fraction of traffic sent to backendService, computed as
  /// weight / (sum of all weightedBackendService weights in routeAction) .
  /// The selection of a backend service is determined only for new traffic.
  /// Once a user's request has been directed to a backendService, subsequent
  /// requests will be sent to the same backendService as determined by the
  /// BackendService's session affinity policy.
  /// The value must be between 0 and 1000
  core.int weight;

  WeightedBackendService();

  WeightedBackendService.fromJson(core.Map _json) {
    if (_json.containsKey("backendService")) {
      backendService = _json["backendService"];
    }
    if (_json.containsKey("headerAction")) {
      headerAction = new HttpHeaderAction.fromJson(_json["headerAction"]);
    }
    if (_json.containsKey("weight")) {
      weight = _json["weight"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (backendService != null) {
      _json["backendService"] = backendService;
    }
    if (headerAction != null) {
      _json["headerAction"] = (headerAction).toJson();
    }
    if (weight != null) {
      _json["weight"] = weight;
    }
    return _json;
  }
}

class XpnHostListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  XpnHostListWarningData();

  XpnHostListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class XpnHostListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<XpnHostListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  XpnHostListWarning();

  XpnHostListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<XpnHostListWarningData>(
              (value) => new XpnHostListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

class XpnHostList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// [Output Only] A list of shared VPC host project URLs.
  core.List<Project> items;

  /// [Output Only] Type of resource. Always compute#xpnHostList for lists of
  /// shared VPC hosts.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  XpnHostListWarning warning;

  XpnHostList();

  XpnHostList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Project>((value) => new Project.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new XpnHostListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

/// Service resource (a.k.a service project) ID.
class XpnResourceId {
  /// The ID of the service resource. In the case of projects, this field
  /// supports project id (e.g., my-project-123) and project number (e.g.
  /// 12345678).
  core.String id;

  /// The type of the service resource.
  /// Possible string values are:
  /// - "PROJECT"
  /// - "XPN_RESOURCE_TYPE_UNSPECIFIED"
  core.String type;

  XpnResourceId();

  XpnResourceId.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("type")) {
      type = _json["type"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (type != null) {
      _json["type"] = type;
    }
    return _json;
  }
}

/// Represents a Zone resource.
///
/// A zone is a deployment area. These deployment areas are subsets of a region.
/// For example the zone us-east1-a is located in the us-east1 region. For more
/// information, read Regions and Zones. (== resource_for {$api_version}.zones
/// ==)
class Zone {
  /// [Output Only] Available cpu/platform selections for the zone.
  core.List<core.String> availableCpuPlatforms;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this zone.
  DeprecationStatus deprecated;

  /// [Output Only] Textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#zone for zones.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Full URL reference to the region which hosts the zone.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Status of the zone, either UP or DOWN.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String status;

  Zone();

  Zone.fromJson(core.Map _json) {
    if (_json.containsKey("availableCpuPlatforms")) {
      availableCpuPlatforms =
          (_json["availableCpuPlatforms"] as core.List).cast<core.String>();
    }
    if (_json.containsKey("creationTimestamp")) {
      creationTimestamp = _json["creationTimestamp"];
    }
    if (_json.containsKey("deprecated")) {
      deprecated = new DeprecationStatus.fromJson(_json["deprecated"]);
    }
    if (_json.containsKey("description")) {
      description = _json["description"];
    }
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("name")) {
      name = _json["name"];
    }
    if (_json.containsKey("region")) {
      region = _json["region"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("status")) {
      status = _json["status"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (availableCpuPlatforms != null) {
      _json["availableCpuPlatforms"] = availableCpuPlatforms;
    }
    if (creationTimestamp != null) {
      _json["creationTimestamp"] = creationTimestamp;
    }
    if (deprecated != null) {
      _json["deprecated"] = (deprecated).toJson();
    }
    if (description != null) {
      _json["description"] = description;
    }
    if (id != null) {
      _json["id"] = id;
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (name != null) {
      _json["name"] = name;
    }
    if (region != null) {
      _json["region"] = region;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (status != null) {
      _json["status"] = status;
    }
    return _json;
  }
}

class ZoneListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ZoneListWarningData();

  ZoneListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey("key")) {
      key = _json["key"];
    }
    if (_json.containsKey("value")) {
      value = _json["value"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (key != null) {
      _json["key"] = key;
    }
    if (value != null) {
      _json["value"] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ZoneListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ZoneListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ZoneListWarning();

  ZoneListWarning.fromJson(core.Map _json) {
    if (_json.containsKey("code")) {
      code = _json["code"];
    }
    if (_json.containsKey("data")) {
      data = (_json["data"] as core.List)
          .map<ZoneListWarningData>(
              (value) => new ZoneListWarningData.fromJson(value))
          .toList();
    }
    if (_json.containsKey("message")) {
      message = _json["message"];
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (code != null) {
      _json["code"] = code;
    }
    if (data != null) {
      _json["data"] = data.map((value) => (value).toJson()).toList();
    }
    if (message != null) {
      _json["message"] = message;
    }
    return _json;
  }
}

/// Contains a list of zone resources.
class ZoneList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Zone resources.
  core.List<Zone> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ZoneListWarning warning;

  ZoneList();

  ZoneList.fromJson(core.Map _json) {
    if (_json.containsKey("id")) {
      id = _json["id"];
    }
    if (_json.containsKey("items")) {
      items = (_json["items"] as core.List)
          .map<Zone>((value) => new Zone.fromJson(value))
          .toList();
    }
    if (_json.containsKey("kind")) {
      kind = _json["kind"];
    }
    if (_json.containsKey("nextPageToken")) {
      nextPageToken = _json["nextPageToken"];
    }
    if (_json.containsKey("selfLink")) {
      selfLink = _json["selfLink"];
    }
    if (_json.containsKey("warning")) {
      warning = new ZoneListWarning.fromJson(_json["warning"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (id != null) {
      _json["id"] = id;
    }
    if (items != null) {
      _json["items"] = items.map((value) => (value).toJson()).toList();
    }
    if (kind != null) {
      _json["kind"] = kind;
    }
    if (nextPageToken != null) {
      _json["nextPageToken"] = nextPageToken;
    }
    if (selfLink != null) {
      _json["selfLink"] = selfLink;
    }
    if (warning != null) {
      _json["warning"] = (warning).toJson();
    }
    return _json;
  }
}

class ZoneSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts. The fingerprint is initially generated by Compute Engine
  /// and changes after every request to modify or update labels. You must
  /// always provide an up-to-date fingerprint hash in order to update or change
  /// labels. Make a get() request to the resource to get the latest
  /// fingerprint.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes {
    return convert.base64.decode(labelFingerprint);
  }

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String> labels;

  ZoneSetLabelsRequest();

  ZoneSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey("labelFingerprint")) {
      labelFingerprint = _json["labelFingerprint"];
    }
    if (_json.containsKey("labels")) {
      labels = (_json["labels"] as core.Map).cast<core.String, core.String>();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (labelFingerprint != null) {
      _json["labelFingerprint"] = labelFingerprint;
    }
    if (labels != null) {
      _json["labels"] = labels;
    }
    return _json;
  }
}

class ZoneSetPolicyRequest {
  /// Flatten Policy to create a backwacd compatible wire-format. Deprecated.
  /// Use 'policy' to specify bindings.
  core.List<Binding> bindings;

  /// Flatten Policy to create a backward compatible wire-format. Deprecated.
  /// Use 'policy' to specify the etag.
  core.String etag;
  core.List<core.int> get etagAsBytes {
    return convert.base64.decode(etag);
  }

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll("/", "_").replaceAll("+", "-");
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'. The size of
  /// the policy is limited to a few 10s of KB. An empty policy is in general a
  /// valid policy but certain services (like Projects) might reject them.
  Policy policy;

  ZoneSetPolicyRequest();

  ZoneSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey("bindings")) {
      bindings = (_json["bindings"] as core.List)
          .map<Binding>((value) => new Binding.fromJson(value))
          .toList();
    }
    if (_json.containsKey("etag")) {
      etag = _json["etag"];
    }
    if (_json.containsKey("policy")) {
      policy = new Policy.fromJson(_json["policy"]);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final core.Map<core.String, core.Object> _json =
        new core.Map<core.String, core.Object>();
    if (bindings != null) {
      _json["bindings"] = bindings.map((value) => (value).toJson()).toList();
    }
    if (etag != null) {
      _json["etag"] = etag;
    }
    if (policy != null) {
      _json["policy"] = (policy).toJson();
    }
    return _json;
  }
}
